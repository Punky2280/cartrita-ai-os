[
  {
    "file_path": "frontend/src/services/api.ts",
    "modifications": [
      {
        "line": 695,
        "original": "const apiKey = this.client.defaults.headers.common[\"X-API-Key\"] as string || \"\";",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Cartrita AI OS - API Client\n// Comprehensive API client for frontend-backend communication\n\nimport axios, {\n  AxiosInstance,\n  AxiosRequestConfig,\n  AxiosResponse,\n  InternalAxiosRequestConfig,\n} from \"axios\";\nimport { z } from \"zod\";\nimport type {\n  User,\n  Conversation,\n  Message,\n  Agent,\n  ChatRequest,\n  ChatResponse,\n  ApiResponse,\n  StreamingChunk,\n  HealthStatus,\n  MetricsData,\n  SearchFilters,\n  Plugin,\n  Workspace,\n  Notification,\n  VoiceSettings,\n  ThemeConfig,\n  FileUploadResult,\n} from \"@/types\";\nimport {\n  createApiResponse,\n  handleApiError,\n  createStreamingChunk,\n  logError,\n} from \"@/utils\";\n\n// SSE Event Types based on our schema\nexport type SSEEvent =\n  | {\n      event: \"stream_start\";\n      data: { conversation_id: string };\n      id?: string;\n      retry?: number;\n    }\n  | {\n      event: \"token\";\n      data: { content: string; delta?: string };\n      id?: string;\n      retry?: number;\n    }\n  | {\n      event: \"function_call\";\n      data: { function_name: string; arguments: unknown };\n      id?: string;\n      retry?: number;\n    }\n  | {\n      event: \"tool_result\";\n      data: { tool_name: string; result: unknown };\n      id?: string;\n      retry?: number;\n    }\n  | {\n      event: \"agent_task_start\";\n      data: { task_id: string; agent_type: string; description: string };\n      id?: string;\n      retry?: number;\n    }\n  | {\n      event: \"agent_task_progress\";\n      data: { task_id: string; progress: number; status: string };\n      id?: string;\n      retry?: number;\n    }\n  | {\n      event: \"agent_task_complete\";\n      data: { task_id: string; result: unknown; success: boolean };\n      id?: string;\n      retry?: number;\n    }\n  | {\n      event: \"metrics\";\n      data: Record<string, unknown>;\n      id?: string;\n      retry?: number;\n    }\n  | {\n      event: \"error\";\n      data: { error: string; code?: string; recoverable?: boolean };\n      id?: string;\n      retry?: number;\n    }\n  | {\n      event: \"done\";\n      data: {\n        final_response: string;\n        conversation_id: string;\n        agent_type?: string;\n        processing_time?: number;\n        token_usage?: unknown;\n        sources?: unknown;\n        message_id?: string;\n      };\n      id?: string;\n      retry?: number;\n    };\n\n// Narrow helper\nfunction isSSEEvent(value: unknown): value is SSEEvent {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"event\" in (value as any) &&\n    \"data\" in (value as any)\n  );\n}\n\nexport interface StreamingCallbacks {\n  onToken?: (content: string, delta?: string) => void;\n  onFunctionCall?: (functionName: string, args: unknown) => void;\n  onToolResult?: (toolName: string, result: unknown) => void;\n  onAgentTaskStart?: (\n    taskId: string,\n    agentType: string,\n    description: string,\n  ) => void;\n  onAgentTaskProgress?: (\n    taskId: string,\n    progress: number,\n    status: string,\n  ) => void;\n  onAgentTaskComplete?: (\n    taskId: string,\n    result: unknown,\n    success: boolean,\n  ) => void;\n  onMetrics?: (metrics: unknown) => void;\n  onError?: (error: string, code: string, recoverable: boolean) => void;\n  onDone?: (finalResponse: string, metadata: unknown) => void;\n}\n\n// WebSocket Message Types\nexport interface WebSocketMessage {\n  type: \"auth\" | \"chat\" | \"ping\" | \"pong\";\n  api_key?: string;\n  message?: string;\n  context?: Record<string, unknown>;\n  conversation_id?: string;\n}\n\n// Extend AxiosRequestConfig to include metadata\ndeclare module \"axios\" {\n  interface AxiosRequestConfig {\n    metadata?: {\n      requestId: string;\n      startTime: number;\n    };\n  }\n}\n\n// API Response Schemas for Runtime Validation\n// Some legacy endpoints (e.g. /health) may not include `success`; we'll handle that gracefully.\nconst ApiResponseSchema = z.object({\n  success: z.boolean().optional(),\n  data: z.any().optional(),\n  error: z.string().optional(),\n  message: z.string().optional(),\n  metadata: z\n    .object({\n      timestamp: z.string().optional(),\n      version: z.string().optional(),\n      requestId: z.string().optional(),\n      processingTime: z.number().optional(),\n    })\n    .optional(),\n});\n\n// Health status schema reflecting backend expectations (success may be absent)\nconst HealthStatusSchema = z\n  .object({\n    status: z.enum([\"healthy\", \"unhealthy\", \"degraded\"]).optional(),\n    version: z.string().optional(),\n    uptime: z.number().optional(),\n    timestamp: z.string().optional(),\n    services: z.record(z.any()).optional(),\n  })\n  .passthrough();\n\nconst UserSchema = z.object({\n  id: z.string(),\n  email: z.string().email(),\n  name: z.string(),\n  avatar: z.string().optional(),\n  preferences: z.object({\n    theme: z.enum([\"light\", \"dark\", \"system\"]),\n    language: z.string(),\n    notifications: z.boolean(),\n    autoSave: z.boolean(),\n  }),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n  lastLoginAt: z.string().optional(),\n  isActive: z.boolean(),\n  role: z.enum([\"user\", \"admin\", \"moderator\"]),\n});\n\nconst ConversationSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  messages: z.array(z.any()), // Will be validated separately\n  agentId: z.string().optional(),\n  workspaceId: z.string().optional(),\n  userId: z.string(),\n  isArchived: z.boolean(),\n  isPinned: z.boolean(),\n  tags: z.array(z.string()),\n  metadata: z.record(z.any()),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n  lastMessageAt: z.string().optional(),\n});\n\nconst MessageSchema = z.object({\n  id: z.string(),\n  conversationId: z.string(),\n  role: z.enum([\"user\", \"assistant\", \"system\"]),\n  content: z.string(),\n  attachments: z.array(z.any()).optional(),\n  metadata: z.record(z.any()),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n  isEdited: z.boolean(),\n  tokens: z.number().optional(),\n  processingTime: z.number().optional(),\n});\n\nconst AgentSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  description: z.string(),\n  type: z.string(),\n  capabilities: z.array(z.string()),\n  model: z.string(),\n  parameters: z.record(z.any()),\n  isActive: z.boolean(),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n  metrics: z.object({\n    totalRequests: z.number(),\n    successRate: z.number(),\n    avgLatency: z.number(),\n    lastActive: z.string(),\n  }),\n});\n\n// Custom Error Classes\nexport class ApiError extends Error {\n  constructor(\n    public status: number,\n    message: string,\n    public response?: unknown,\n    public requestId?: string,\n  ) {\n    super(message);\n    this.name = \"ApiError\";\n  }\n}\n\nexport class NetworkError extends Error {\n  constructor(\n    message: string,\n    public originalError?: unknown,\n  ) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n}\n\nexport class ValidationError extends Error {\n  constructor(\n    message: string,\n    public errors?: Record<string, string[]>,\n  ) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\n// Main API Client Class\nexport class CartritaApiClient {\n  private client: AxiosInstance;\n  private baseURL: string;\n  private timeout: number;\n  private retryCount: number;\n  private requestQueue: Map<string, AbortController> = new Map();\n\n  constructor(\n    config: {\n      baseURL?: string;\n      timeout?: number;\n      retryCount?: number;\n      apiKey?: string;\n    } = {},\n  ) {\n    this.baseURL = config.baseURL || process.env.NEXT_PUBLIC_API_URL || \"/api\";\n    this.timeout = config.timeout || 30000;\n    this.retryCount = config.retryCount || 3;\n\n    // Get API key from multiple sources\n    const apiKey =\n      config.apiKey ||\n      process.env.NEXT_PUBLIC_CARTRITA_API_KEY ||\n      \"dev-key-cartrita-ai-os\";\n\n    this.client = axios.create({\n      baseURL: this.baseURL,\n      timeout: this.timeout,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-Client-Version\": \"Cartrita-Client/2.0.0\",\n        // Support both header formats for compatibility\n        \"X-API-Key\": apiKey,\n        Authorization: `Bearer ${apiKey}`,\n      },\n    });\n\n    this.setupInterceptors();\n  }\n\n  // Static method to create instance\n  static createInstance(config?: {\n    baseURL?: string;\n    timeout?: number;\n    retryCount?: number;\n    apiKey?: string;\n  }): CartritaApiClient {\n    return new CartritaApiClient(config);\n  }\n\n  // Set authentication token\n  setAuthToken(token: string): void {\n    this.client.defaults.headers.common[\"Authorization\"] = `Bearer ${token}`;\n    this.client.defaults.headers.common[\"X-API-Key\"] = token;\n  }\n\n  // Remove authentication token\n  removeAuthToken(): void {\n    delete this.client.defaults.headers.common[\"Authorization\"];\n    delete this.client.defaults.headers.common[\"X-API-Key\"];\n  }\n\n  private setupInterceptors() {\n    // Request interceptor\n    this.client.interceptors.request.use(\n      (config: InternalAxiosRequestConfig) => {\n        const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        config.metadata = { requestId, startTime: Date.now() };\n\n        // Add to request queue for cancellation\n        const controller = new AbortController();\n        config.signal = controller.signal;\n        this.requestQueue.set(requestId, controller);\n\n        return config;\n      },\n      (error) => {\n        logError(error, { context: \"request_interceptor\" });\n        return Promise.reject(error);\n      },\n    );\n\n    // Response interceptor\n    this.client.interceptors.response.use(\n      (response) => {\n        const requestId = response.config.metadata?.requestId;\n        if (requestId) {\n          this.requestQueue.delete(requestId);\n        }\n\n        // Validate response structure\n        try {\n          // Attempt generic API response validation; tolerate health/status endpoints\n          ApiResponseSchema.parse(response.data);\n        } catch (validationError) {\n          // Special-case: /health endpoint often returns a plain object without success flag\n          if (response.config.url?.includes(\"/health\")) {\n            try {\n              HealthStatusSchema.parse(response.data);\n            } catch (healthErr) {\n              logError(healthErr as Error, {\n                context: \"health_response_validation\",\n                requestId,\n                url: response.config.url,\n              });\n            }\n          } else {\n            logError(validationError as Error, {\n              context: \"response_validation\",\n              requestId,\n              url: response.config.url,\n            });\n          }\n        }\n\n        return response;\n      },\n      (error) => {\n        const requestId = error.config?.metadata?.requestId;\n        if (requestId) {\n          this.requestQueue.delete(requestId);\n        }\n\n        if (error.code === \"ECONNABORTED\" || error.code === \"ENOTFOUND\") {\n          return Promise.reject(\n            new NetworkError(\"Network connection failed\", error),\n          );\n        }\n\n        if (error.response?.status === 422) {\n          const validationErrors = error.response.data?.errors;\n          return Promise.reject(\n            new ValidationError(\"Validation failed\", validationErrors),\n          );\n        }\n\n        if (error.response) {\n          return Promise.reject(\n            new ApiError(\n              error.response.status,\n              error.response.data?.error || error.message,\n              error.response.data,\n              requestId,\n            ),\n          );\n        }\n\n        logError(error, { context: \"response_interceptor\", requestId });\n        return Promise.reject(error);\n      },\n    );\n  }\n\n  // Generic request method with retry logic\n  private async request<T>(\n    method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\",\n    endpoint: string,\n    data?: unknown,\n    config?: AxiosRequestConfig,\n  ): Promise<ApiResponse<T>> {\n    const requestConfig: AxiosRequestConfig = {\n      method,\n      url: endpoint,\n      ...(data && { data }),\n      ...config,\n    };\n\n    let lastError: unknown;\n\n    for (let attempt = 1; attempt <= this.retryCount; attempt++) {\n      try {\n        const response: AxiosResponse<ApiResponse<T>> =\n          await this.client.request(requestConfig);\n        return response.data;\n      } catch (error) {\n        lastError = error;\n\n        // Don't retry on client errors (4xx) except 429 (rate limit)\n        if (\n          error instanceof ApiError &&\n          error.status >= 400 &&\n          error.status < 500 &&\n          error.status !== 429\n        ) {\n          break;\n        }\n\n        // Don't retry on the last attempt\n        if (attempt === this.retryCount) {\n          break;\n        }\n\n        // Exponential backoff\n        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n\n    throw lastError;\n  }\n\n  // Authentication methods\n  async login(\n    email: string,\n    password: string,\n  ): Promise<ApiResponse<{ user: User; token: string }>> {\n    return this.request(\"POST\", \"/auth/login\", { email, password });\n  }\n\n  async register(userData: {\n    email: string;\n    password: string;\n    name: string;\n  }): Promise<ApiResponse<{ user: User; token: string }>> {\n    return this.request(\"POST\", \"/auth/register\", userData);\n  }\n\n  async logout(): Promise<ApiResponse<void>> {\n    return this.request(\"POST\", \"/auth/logout\");\n  }\n\n  async refreshToken(): Promise<ApiResponse<{ token: string }>> {\n    return this.request(\"POST\", \"/auth/refresh\");\n  }\n\n  async getCurrentUser(): Promise<ApiResponse<User>> {\n    const response = await this.request<User>(\"GET\", \"/auth/me\");\n    try {\n      UserSchema.parse(response.data);\n    } catch (error) {\n      throw new ValidationError(\"Invalid user data received\");\n    }\n    return response;\n  }\n\n  async updateUserPreferences(\n    preferences: Partial<User[\"preferences\"]>,\n  ): Promise<ApiResponse<User>> {\n    return this.request(\"PUT\", \"/auth/preferences\", { preferences });\n  }\n\n  async updateThemeConfig(\n    themeConfig: ThemeConfig,\n  ): Promise<ApiResponse<User>> {\n    return this.request(\"PUT\", \"/auth/theme\", { themeConfig });\n  }\n\n  async updateVoiceSettings(\n    voiceSettings: VoiceSettings,\n  ): Promise<ApiResponse<User>> {\n    return this.request(\"PUT\", \"/auth/voice\", { voiceSettings });\n  }\n\n  // Conversation methods\n  async getConversations(\n    filters?: SearchFilters,\n  ): Promise<ApiResponse<Conversation[]>> {\n    const params = filters\n      ? new URLSearchParams(filters as any).toString()\n      : \"\";\n    const endpoint = `/conversations${params ? `?${params}` : \"\"}`;\n    return this.request(\"GET\", endpoint);\n  }\n\n  async getConversation(id: string): Promise<ApiResponse<Conversation>> {\n    const response = await this.request<Conversation>(\n      \"GET\",\n      `/conversations/${id}`,\n    );\n    try {\n      ConversationSchema.parse(response.data);\n    } catch (error) {\n      throw new ValidationError(\"Invalid conversation data received\");\n    }\n    return response;\n  }\n\n  async createConversation(data: {\n    title?: string;\n    agentId?: string;\n    workspaceId?: string;\n    initialMessage?: string;\n  }): Promise<ApiResponse<Conversation>> {\n    return this.request(\"POST\", \"/conversations\", data);\n  }\n\n  async updateConversation(\n    id: string,\n    data: Partial<Pick<Conversation, \"title\" | \"isArchived\" | \"tags\">>,\n  ): Promise<ApiResponse<Conversation>> {\n    return this.request(\"PUT\", `/conversations/${id}`, data);\n  }\n\n  async deleteConversation(id: string): Promise<ApiResponse<void>> {\n    return this.request(\"DELETE\", `/conversations/${id}`);\n  }\n\n  async archiveConversation(id: string): Promise<ApiResponse<Conversation>> {\n    return this.request(\"PUT\", `/conversations/${id}/archive`);\n  }\n\n  async pinConversation(id: string): Promise<ApiResponse<Conversation>> {\n    return this.request(\"PUT\", `/conversations/${id}/pin`);\n  }\n\n  // Message methods\n  async getMessages(\n    conversationId: string,\n    params?: {\n      limit?: number;\n      offset?: number;\n      before?: string;\n      after?: string;\n    },\n  ): Promise<ApiResponse<Message[]>> {\n    const queryParams = params\n      ? new URLSearchParams(params as any).toString()\n      : \"\";\n    const endpoint = `/conversations/${conversationId}/messages${queryParams ? `?${queryParams}` : \"\"}`;\n    const response = await this.request<Message[]>(\"GET\", endpoint);\n\n    // Validate each message\n    if (Array.isArray(response.data)) {\n      response.data.forEach((message, index) => {\n        try {\n          MessageSchema.parse(message);\n        } catch (error) {\n          logError(error as Error, {\n            context: \"message_validation\",\n            conversationId,\n            messageIndex: index,\n          });\n        }\n      });\n    }\n\n    return response;\n  }\n\n  async sendMessage(\n    conversationId: string,\n    message: ChatRequest,\n  ): Promise<ApiResponse<ChatResponse>> {\n    return this.request(\n      \"POST\",\n      `/conversations/${conversationId}/messages`,\n      message,\n    );\n  }\n\n  // New chat method that matches backend\n  async postChat(request: ChatRequest): Promise<ApiResponse<ChatResponse>> {\n    const response = await this.request<ChatResponse>(\"POST\", \"/chat\", request);\n\n    // Normalize backend response to frontend Message shape\n    if (response.data) {\n      const normalizedMessage: Message = {\n        id: crypto.randomUUID(),\n        conversationId: response.data.conversation_id as string,\n        role: \"assistant\",\n        content: response.data.response,\n        attachments: [],\n        metadata: response.data.metadata || {},\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        isEdited: false,\n        tokens: response.data.token_usage?.total_tokens,\n        processingTime: response.data.processing_time,\n      };\n\n      // Attach normalized message\n      response.data.message = normalizedMessage;\n    }\n\n    return response;\n  }\n\n  async editMessage(\n    conversationId: string,\n    messageId: string,\n    content: string,\n  ): Promise<ApiResponse<Message>> {\n    return this.request(\n      \"PUT\",\n      `/conversations/${conversationId}/messages/${messageId}`,\n      { content },\n    );\n  }\n\n  async deleteMessage(\n    conversationId: string,\n    messageId: string,\n  ): Promise<ApiResponse<void>> {\n    return this.request(\n      \"DELETE\",\n      `/conversations/${conversationId}/messages/${messageId}`,\n    );\n  }\n\n  // SSE Streaming chat method (primary)\n  async streamChatSSE(\n    request: ChatRequest,\n    callbacks: StreamingCallbacks,\n  ): Promise<{ eventSource: EventSource; conversationId: string }> {\n    const endpoint = `${this.baseURL.replace(\"/api\", \"\")}/api/chat/stream`;\nconst apiKey = process.env.CONST APIKEY || \"\";\n\n    // Create EventSource with POST data via URL params (EventSource limitation workaround)\n    const params = new URLSearchParams({\n      message: request.message,\n      ...(request.conversation_id && {\n        conversation_id: request.conversation_id,\n      }),\n      ...(request.agent_override && { agent_override: request.agent_override }),\n      ...(request.context && { context: JSON.stringify(request.context) }),\n      api_key: apiKey,\n    });\n\n    const eventSource = new EventSource(`${endpoint}?${params}`);\n    let conversationId = request.conversation_id || \"\";\n\n    eventSource.onmessage = (event) => {\n      try {\n        const parsed = JSON.parse(event.data);\n        if (!isSSEEvent(parsed)) return;\n        const sseEvent = parsed;\n        switch (sseEvent.event) {\n          case \"stream_start\":\n            conversationId = sseEvent.data.conversation_id;\n            break;\n          case \"token\":\n            callbacks.onToken?.(sseEvent.data.content, sseEvent.data.delta);\n            break;\n          case \"function_call\":\n            callbacks.onFunctionCall?.(\n              sseEvent.data.function_name,\n              sseEvent.data.arguments,\n            );\n            break;\n          case \"tool_result\":\n            callbacks.onToolResult?.(\n              sseEvent.data.tool_name,\n              sseEvent.data.result,\n            );\n            break;\n          case \"agent_task_start\":\n            callbacks.onAgentTaskStart?.(\n              sseEvent.data.task_id,\n              sseEvent.data.agent_type,\n              sseEvent.data.description,\n            );\n            break;\n          case \"agent_task_progress\":\n            callbacks.onAgentTaskProgress?.(\n              sseEvent.data.task_id,\n              sseEvent.data.progress,\n              sseEvent.data.status,\n            );\n            break;\n          case \"agent_task_complete\":\n            callbacks.onAgentTaskComplete?.(\n              sseEvent.data.task_id,\n              sseEvent.data.result,\n              sseEvent.data.success,\n            );\n            break;\n          case \"metrics\":\n            callbacks.onMetrics?.(sseEvent.data);\n            break;\n          case \"error\":\n            callbacks.onError?.(\n              sseEvent.data.error,\n              sseEvent.data.code,\n              sseEvent.data.recoverable ?? false,\n            );\n            break;\n          case \"done\":\n            callbacks.onDone?.(sseEvent.data.final_response, sseEvent.data);\n            eventSource.close();\n            break;\n        }\n      } catch (error) {\n        logError(error as Error, {\n          context: \"sse_parse_error\",\n          rawData: event.data,\n        });\n      }\n    };\n\n    eventSource.onerror = (error) => {\n      logError(new Error(\"SSE connection error\"), {\n        context: \"sse_connection_error\",\n        error,\n      });\n      callbacks.onError?.(\"SSE connection failed\", \"SSE_ERROR\", true);\n    };\n\n    return { eventSource, conversationId };\n  }\n\n  // WebSocket streaming chat method (fallback)\n  async streamChatWebSocket(\n    request: ChatRequest,\n    callbacks: StreamingCallbacks,\n  ): Promise<{ websocket: WebSocket; conversationId: string }> {\n    const wsUrl =\n      this.baseURL.replace(\"http\", \"ws\").replace(\"/api\", \"\") + \"/ws/chat\";\n    const websocket = new WebSocket(wsUrl);\n    let conversationId = request.conversation_id || \"\";\n\n    return new Promise((resolve, reject) => {\n      websocket.onopen = () => {\n        // Authenticate\n        const authMessage: WebSocketMessage = {\n          type: \"auth\",\n          api_key: this.client.defaults.headers.common[\"X-API-Key\"] as string,\n        };\n        websocket.send(JSON.stringify(authMessage));\n\n        // Send chat message\n        const chatMessage: WebSocketMessage = {\n          type: \"chat\",\n          message: request.message,\n          context: request.context,\n          conversation_id: request.conversation_id,\n        };\n        websocket.send(JSON.stringify(chatMessage));\n\n        resolve({ websocket, conversationId });\n      };\n\n      websocket.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n\n          if (data.error) {\n            callbacks.onError?.(data.error, \"WS_ERROR\", false);\n            return;\n          }\n\n          // Handle current backend format (single response)\n          if (data.response && data.done) {\n            conversationId = data.conversation_id;\n            callbacks.onDone?.(data.response, {\n              conversation_id: data.conversation_id,\n              agent_type: data.agent_type,\n              processing_time: data.processing_time,\n            });\n          }\n        } catch (error) {\n          logError(error as Error, {\n            context: \"websocket_parse_error\",\n            rawData: event.data,\n          });\n        }\n      };\n\n      websocket.onerror = (error) => {\n        logError(new Error(\"WebSocket connection error\"), {\n          context: \"websocket_connection_error\",\n          error,\n        });\n        callbacks.onError?.(\"WebSocket connection failed\", \"WS_ERROR\", false);\n        reject(error);\n      };\n\n      websocket.onclose = () => {\n        // Connection closed\n      };\n    });\n  }\n\n  // Unified streaming method with SSE primary, WebSocket fallback\n  async streamChat(\n    request: ChatRequest,\n    callbacks: StreamingCallbacks,\n  ): Promise<{ close: () => void; conversationId: string }> {\n    try {\n      // Try SSE first\n      const { eventSource, conversationId } = await this.streamChatSSE(\n        request,\n        callbacks,\n      );\n\n      return {\n        close: () => eventSource.close(),\n        conversationId,\n      };\n    } catch (sseError) {\n      logError(sseError as Error, {\n        context: \"sse_fallback_to_websocket\",\n      });\n\n      // Fallback to WebSocket\n      try {\n        const { websocket, conversationId } = await this.streamChatWebSocket(\n          request,\n          callbacks,\n        );\n\n        return {\n          close: () => websocket.close(),\n          conversationId,\n        };\n      } catch (wsError) {\n        logError(wsError as Error, {\n          context: \"websocket_fallback_failed\",\n        });\n        throw new Error(\"Both SSE and WebSocket streaming failed\");\n      }\n    }\n  }\n\n  // Legacy streaming method for backward compatibility\n  async *streamChatLegacy(\n    conversationId: string,\n    message: ChatRequest,\n  ): AsyncGenerator<StreamingChunk, void, unknown> {\n    let finalContent = \"\";\n    let isDone = false;\n\n    const { close } = await this.streamChat(message, {\n      onToken: (content, delta) => {\n        finalContent += delta || content;\n      },\n      onDone: (finalResponse) => {\n        finalContent = finalResponse;\n        isDone = true;\n      },\n      onError: () => {\n        isDone = true;\n      },\n    });\n\n    // Simulate async generator behavior\n    while (!isDone) {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n      if (finalContent) {\n        yield createStreamingChunk(finalContent, isDone);\n      }\n    }\n\n    close();\n  }\n\n  // Agent methods\n  async getAgents(): Promise<ApiResponse<Agent[]>> {\n    const response = await this.request<Agent[]>(\"GET\", \"/agents\");\n    if (Array.isArray(response.data)) {\n      response.data.forEach((agent, index) => {\n        try {\n          AgentSchema.parse(agent);\n        } catch (error) {\n          logError(error as Error, {\n            context: \"agent_validation\",\n            agentIndex: index,\n          });\n        }\n      });\n    }\n    return response;\n  }\n\n  async getAgent(id: string): Promise<ApiResponse<Agent>> {\n    const response = await this.request<Agent>(\"GET\", `/agents/${id}`);\n    try {\n      AgentSchema.parse(response.data);\n    } catch (error) {\n      throw new ValidationError(\"Invalid agent data received\");\n    }\n    return response;\n  }\n\n  async createAgent(\n    agentData: Omit<Agent, \"id\" | \"createdAt\" | \"updatedAt\" | \"metrics\">,\n  ): Promise<ApiResponse<Agent>> {\n    return this.request(\"POST\", \"/agents\", agentData);\n  }\n\n  async updateAgent(\n    id: string,\n    updates: Partial<Agent>,\n  ): Promise<ApiResponse<Agent>> {\n    return this.request(\"PUT\", `/agents/${id}`, updates);\n  }\n\n  async deleteAgent(id: string): Promise<ApiResponse<void>> {\n    return this.request(\"DELETE\", `/agents/${id}`);\n  }\n\n  // Workspace methods\n  async getWorkspaces(): Promise<ApiResponse<Workspace[]>> {\n    return this.request(\"GET\", \"/workspaces\");\n  }\n\n  async getWorkspace(id: string): Promise<ApiResponse<Workspace>> {\n    return this.request(\"GET\", `/workspaces/${id}`);\n  }\n\n  async createWorkspace(\n    data: Omit<Workspace, \"id\" | \"createdAt\" | \"updatedAt\">,\n  ): Promise<ApiResponse<Workspace>> {\n    return this.request(\"POST\", \"/workspaces\", data);\n  }\n\n  async updateWorkspace(\n    id: string,\n    updates: Partial<Workspace>,\n  ): Promise<ApiResponse<Workspace>> {\n    return this.request(\"PUT\", `/workspaces/${id}`, updates);\n  }\n\n  async deleteWorkspace(id: string): Promise<ApiResponse<void>> {\n    return this.request(\"DELETE\", `/workspaces/${id}`);\n  }\n\n  // Plugin methods\n  async getPlugins(): Promise<ApiResponse<Plugin[]>> {\n    return this.request(\"GET\", \"/plugins\");\n  }\n\n  async installPlugin(pluginId: string): Promise<ApiResponse<Plugin>> {\n    return this.request(\"POST\", `/plugins/${pluginId}/install`);\n  }\n\n  async uninstallPlugin(pluginId: string): Promise<ApiResponse<void>> {\n    return this.request(\"DELETE\", `/plugins/${pluginId}`);\n  }\n\n  async updatePluginSettings(\n    pluginId: string,\n    settings: Record<string, unknown>,\n  ): Promise<ApiResponse<Plugin>> {\n    return this.request(\"PUT\", `/plugins/${pluginId}/settings`, { settings });\n  }\n\n  // Notifications methods\n  async getNotifications(): Promise<ApiResponse<Notification[]>> {\n    return this.request(\"GET\", \"/notifications\");\n  }\n\n  async markNotificationAsRead(id: string): Promise<ApiResponse<void>> {\n    return this.request(\"PUT\", `/notifications/${id}/read`);\n  }\n\n  async deleteNotification(id: string): Promise<ApiResponse<void>> {\n    return this.request(\"DELETE\", `/notifications/${id}`);\n  }\n\n  // Health and Metrics methods\n  async getHealthStatus(): Promise<ApiResponse<HealthStatus>> {\n    const response = await this.request<HealthStatus>(\"GET\", \"/health\");\n    // Normalize to ApiResponse shape if backend omitted success\n    if (response && typeof (response as any).success === \"undefined\") {\n      return { success: true, data: response as unknown as HealthStatus };\n    }\n    return response;\n  }\n\n  async getMetrics(): Promise<ApiResponse<MetricsData>> {\n    return this.request(\"GET\", \"/metrics\");\n  }\n\n  // File upload methods\n  async uploadFile(\n    file: File,\n    conversationId?: string,\n    onProgress?: (progress: number) => void,\n  ): Promise<ApiResponse<FileUploadResult>> {\n    const formData = new FormData();\n    formData.append(\"file\", file);\n    if (conversationId) {\n      formData.append(\"conversationId\", conversationId);\n    }\n\n    const config: AxiosRequestConfig = {\n      headers: {\n        \"Content-Type\": \"multipart/form-data\",\n      },\n    };\n\n    if (onProgress) {\n      config.onUploadProgress = (progressEvent) => {\n        if (progressEvent.total) {\n          const progress = Math.round(\n            (progressEvent.loaded * 100) / progressEvent.total,\n          );\n          onProgress(progress);\n        }\n      };\n    }\n\n    return this.request(\"POST\", \"/upload\", formData, config);\n  }\n\n  async uploadMultipleFiles(\n    files: File[],\n    conversationId?: string,\n    onProgress?: (progress: number) => void,\n  ): Promise<ApiResponse<Array<{ url: string; metadata: unknown }>>> {\n    const formData = new FormData();\n    files.forEach((file, index) => {\n      formData.append(`files[${index}]`, file);\n    });\n    if (conversationId) {\n      formData.append(\"conversationId\", conversationId);\n    }\n\n    const config: AxiosRequestConfig = {\n      headers: {\n        \"Content-Type\": \"multipart/form-data\",\n      },\n    };\n\n    if (onProgress) {\n      config.onUploadProgress = (progressEvent) => {\n        if (progressEvent.total) {\n          const progress = Math.round(\n            (progressEvent.loaded * 100) / progressEvent.total,\n          );\n          onProgress(progress);\n        }\n      };\n    }\n\n    return this.request(\"POST\", \"/upload/multiple\", formData, config);\n  }\n\n  // Voice methods\n  async transcribeAudio(\n    audioFile: File,\n  ): Promise<ApiResponse<{ text: string; confidence: number }>> {\n    const formData = new FormData();\n    formData.append(\"audio\", audioFile);\n\n    return this.request(\"POST\", \"/voice/transcribe\", formData, {\n      headers: {\n        \"Content-Type\": \"multipart/form-data\",\n      },\n    });\n  }\n\n  async generateSpeech(\n    text: string,\n    voiceSettings?: VoiceSettings,\n  ): Promise<ApiResponse<{ audioUrl: string }>> {\n    return this.request(\"POST\", \"/voice/speak\", { text, voiceSettings });\n  }\n\n  // Search methods\n  async search(params: {\n    q: string;\n    types?: string[];\n    dateRange?: string;\n    sortBy?: string;\n    limit?: number;\n    offset?: number;\n  }): Promise<unknown> {\n    const response = await this.client.get(\"/api/search\", { params });\n    return response.data;\n  }\n\n  async searchGlobal(query: string, filters?: SearchFilters): Promise<unknown> {\n    const params = { q: query, ...filters };\n    return this.search(params);\n  }\n\n  // Settings methods\n  async getSettings(): Promise<unknown> {\n    const response = await this.client.get(\"/api/settings\");\n    return response.data;\n  }\n\n  async updateSettings(settings: Partial<unknown>): Promise<unknown> {\n    const response = await this.client.put(\"/api/settings\", settings);\n    return response.data;\n  }\n\n  // File methods\n  async deleteFile(fileId: string): Promise<void> {\n    await this.client.delete(`/api/files/${fileId}`);\n  }\n\n  async getFiles(params?: {\n    limit?: number;\n    offset?: number;\n  }): Promise<unknown> {\n    const response = await this.client.get(\"/api/files\", { params });\n    return response.data;\n  }\n\n  // Generic HTTP methods for compatibility\n  async post(\n    endpoint: string,\n    data?: unknown,\n    config?: AxiosRequestConfig,\n  ): Promise<unknown> {\n    const response = await this.client.post(endpoint, data, config);\n    return response.data;\n  }\n\n  async put(\n    endpoint: string,\n    data?: unknown,\n    config?: AxiosRequestConfig,\n  ): Promise<unknown> {\n    const response = await this.client.put(endpoint, data, config);\n    return response.data;\n  }\n\n  async patch(\n    endpoint: string,\n    data?: unknown,\n    config?: AxiosRequestConfig,\n  ): Promise<unknown> {\n    const response = await this.client.patch(endpoint, data, config);\n    return response.data;\n  }\n}\n\n// Export singleton instance\nexport const apiClient = CartritaApiClient.createInstance();\n\n// Export types\nexport type {\n  ApiResponse,\n  User,\n  Conversation,\n  Message,\n  Agent,\n  ChatRequest,\n  ChatResponse,\n};"
  },
  {
    "file_path": "frontend/src/pages/api/upload/multiple.ts",
    "modifications": [
      {
        "line": 18,
        "original": "const apiKey = process.env.CARTRITA_API_KEY || process.env.NEXT_PUBLIC_CARTRITA_API_KEY || \"\";",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Next.js API Route - Multiple File Upload Proxy\n// Proxies POST /api/upload/multiple with secure CORS\n\nimport type { NextApiRequest, NextApiResponse } from \"next\";\nimport httpProxy from \"http-proxy\";\nimport { handleCorsPreflightAsync } from \"../../../utils/cors\";\n\nconst proxy = httpProxy.createProxyServer();\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  return new Promise<void>(async (resolve, reject) => {\n    // Handle CORS with secure origin validation\n    const corsHandled = await handleCorsPreflightAsync(req, res, \"POST,OPTIONS\");\n    if (corsHandled) {\n      return resolve();\n    }\n\nconst apiKey = process.env.CONST APIKEY || \"\";\n    if (apiKey) {\n      req.headers[\"x-api-key\"] = apiKey;\n      req.headers[\"authorization\"] = `Bearer ${apiKey}`;\n    }\n\n    if (req.method !== \"POST\") {\n      res.status(405).json({ error: \"Method Not Allowed\" });\n      resolve();\n      return;\n    }\n\n    proxy.web(\n      req,\n      res,\n      {\n        target:\n          process.env.BACKEND_BASE_URL ||\n          process.env.NEXT_PUBLIC_API_URL ||\n          \"http://localhost:3001\",\n        changeOrigin: true,\n        selfHandleResponse: false,\n        timeout: 70000,\n      },\n      (err: any) => {\n        console.error(\"Proxy error:\", err);\n        if (err.code === \"ECONNREFUSED\" || err.code === \"ENOTFOUND\") {\n          res\n            .status(503)\n            .json({\n              error: \"Backend unavailable\",\n              details:\n                \"AI service is not running. Please start the backend services.\",\n              code: \"BACKEND_DOWN\",\n            });\n        } else {\n          res\n            .status(500)\n            .json({\n              error: \"Proxy failed\",\n              details: err.message,\n              code: err.code || \"PROXY_ERROR\",\n            });\n        }\n        reject(err);\n      },\n    );\n  });\n}\n\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true,\n  },\n};"
  },
  {
    "file_path": "frontend/src/pages/api/upload/index.ts",
    "modifications": [
      {
        "line": 18,
        "original": "const apiKey = process.env.CARTRITA_API_KEY || process.env.NEXT_PUBLIC_CARTRITA_API_KEY || \"\";",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Next.js API Route - Single File Upload Proxy\n// Proxies POST /api/upload with secure CORS\n\nimport type { NextApiRequest, NextApiResponse } from \"next\";\nimport httpProxy from \"http-proxy\";\nimport { handleCorsPreflightAsync } from \"../../../utils/cors\";\n\nconst proxy = httpProxy.createProxyServer();\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  return new Promise<void>(async (resolve, reject) => {\n    // Handle CORS with secure origin validation\n    const corsHandled = await handleCorsPreflightAsync(req, res, \"POST,OPTIONS\");\n    if (corsHandled) {\n      return resolve();\n    }\n\nconst apiKey = process.env.CONST APIKEY || \"\";\n    if (apiKey) {\n      req.headers[\"x-api-key\"] = apiKey;\n      req.headers[\"authorization\"] = `Bearer ${apiKey}`;\n    }\n\n    if (req.method !== \"POST\") {\n      res.status(405).json({ error: \"Method Not Allowed\" });\n      resolve();\n      return;\n    }\n\n    proxy.web(\n      req,\n      res,\n      {\n        target:\n          process.env.BACKEND_BASE_URL ||\n          process.env.NEXT_PUBLIC_API_URL ||\n          \"http://localhost:3001\",\n        changeOrigin: true,\n        selfHandleResponse: false,\n        timeout: 35000,\n      },\n      (err: any) => {\n        console.error(\"Proxy error:\", err);\n        if (err.code === \"ECONNREFUSED\" || err.code === \"ENOTFOUND\") {\n          res\n            .status(503)\n            .json({\n              error: \"Backend unavailable\",\n              details:\n                \"AI service is not running. Please start the backend services.\",\n              code: \"BACKEND_DOWN\",\n            });\n        } else {\n          res\n            .status(500)\n            .json({\n              error: \"Proxy failed\",\n              details: err.message,\n              code: err.code || \"PROXY_ERROR\",\n            });\n        }\n        reject(err);\n      },\n    );\n  });\n}\n\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true,\n  },\n};"
  },
  {
    "file_path": "frontend/src/pages/api/voice/speak.ts",
    "modifications": [
      {
        "line": 18,
        "original": "const apiKey = process.env.CARTRITA_API_KEY || process.env.NEXT_PUBLIC_CARTRITA_API_KEY || \"\";",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Next.js API Route - Voice Synthesis Proxy\n// Proxies POST /api/voice/speak with secure CORS\n\nimport type { NextApiRequest, NextApiResponse } from \"next\";\nimport httpProxy from \"http-proxy\";\nimport { handleCorsPreflightAsync } from \"../../../utils/cors\";\n\nconst proxy = httpProxy.createProxyServer();\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  return new Promise<void>(async (resolve, reject) => {\n    // Handle CORS with secure origin validation\n    const corsHandled = await handleCorsPreflightAsync(req, res, \"POST,OPTIONS\");\n    if (corsHandled) {\n      return resolve();\n    }\n\nconst apiKey = process.env.CONST APIKEY || \"\";\n    if (apiKey) {\n      req.headers[\"x-api-key\"] = apiKey;\n      req.headers[\"authorization\"] = `Bearer ${apiKey}`;\n    }\n\n    if (req.method !== \"POST\") {\n      res.status(405).json({ error: \"Method Not Allowed\" });\n      resolve();\n      return;\n    }\n\n    proxy.web(\n      req,\n      res,\n      {\n        target:\n          process.env.BACKEND_BASE_URL ||\n          process.env.NEXT_PUBLIC_API_URL ||\n          \"http://localhost:3001\",\n        changeOrigin: true,\n        selfHandleResponse: false,\n        timeout: 35000,\n      },\n      (err: any) => {\n        console.error(\"Proxy error:\", err);\n        if (err.code === \"ECONNREFUSED\" || err.code === \"ENOTFOUND\") {\n          res\n            .status(503)\n            .json({\n              error: \"Backend unavailable\",\n              details:\n                \"AI service is not running. Please start the backend services.\",\n              code: \"BACKEND_DOWN\",\n            });\n        } else {\n          res\n            .status(500)\n            .json({\n              error: \"Proxy failed\",\n              details: err.message,\n              code: err.code || \"PROXY_ERROR\",\n            });\n        }\n        reject(err);\n      },\n    );\n  });\n}\n\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true,\n  },\n};"
  },
  {
    "file_path": "frontend/src/pages/api/voice/transcribe.ts",
    "modifications": [
      {
        "line": 18,
        "original": "const apiKey = process.env.CARTRITA_API_KEY || process.env.NEXT_PUBLIC_CARTRITA_API_KEY || \"\";",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Next.js API Route - Voice Transcription Proxy\n// Proxies POST /api/voice/transcribe with secure CORS\n\nimport type { NextApiRequest, NextApiResponse } from \"next\";\nimport httpProxy from \"http-proxy\";\nimport { handleCorsPreflightAsync } from \"../../../utils/cors\";\n\nconst proxy = httpProxy.createProxyServer();\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  return new Promise<void>(async (resolve, reject) => {\n    // Handle CORS with secure origin validation\n    const corsHandled = await handleCorsPreflightAsync(req, res, \"POST,OPTIONS\");\n    if (corsHandled) {\n      return resolve();\n    }\n\nconst apiKey = process.env.CONST APIKEY || \"\";\n    if (apiKey) {\n      req.headers[\"x-api-key\"] = apiKey;\n      req.headers[\"authorization\"] = `Bearer ${apiKey}`;\n    }\n\n    if (req.method !== \"POST\") {\n      res.status(405).json({ error: \"Method Not Allowed\" });\n      resolve();\n      return;\n    }\n\n    proxy.web(\n      req,\n      res,\n      {\n        target:\n          process.env.BACKEND_BASE_URL ||\n          process.env.NEXT_PUBLIC_API_URL ||\n          \"http://localhost:3001\",\n        changeOrigin: true,\n        selfHandleResponse: false,\n        timeout: 35000,\n      },\n      (err: any) => {\n        console.error(\"Proxy error:\", err);\n        if (err.code === \"ECONNREFUSED\" || err.code === \"ENOTFOUND\") {\n          res\n            .status(503)\n            .json({\n              error: \"Backend unavailable\",\n              details:\n                \"AI service is not running. Please start the backend services.\",\n              code: \"BACKEND_DOWN\",\n            });\n        } else {\n          res\n            .status(500)\n            .json({\n              error: \"Proxy failed\",\n              details: err.message,\n              code: err.code || \"PROXY_ERROR\",\n            });\n        }\n        reject(err);\n      },\n    );\n  });\n}\n\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true,\n  },\n};"
  },
  {
    "file_path": "frontend/src/pages/api/chat/voice/stream.ts",
    "modifications": [
      {
        "line": 18,
        "original": "const apiKey = process.env.CARTRITA_API_KEY || process.env.NEXT_PUBLIC_CARTRITA_API_KEY || \"\";",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Next.js API Route - Voice Chat Streaming Proxy\n// Proxies GET /api/chat/voice/stream with secure CORS\n\nimport type { NextApiRequest, NextApiResponse } from \"next\";\nimport httpProxy from \"http-proxy\";\nimport { handleCorsPreflightAsync } from \"../../../../utils/cors\";\n\nconst proxy = httpProxy.createProxyServer();\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  return new Promise<void>(async (resolve, reject) => {\n    // Handle CORS with secure origin validation\n    const corsHandled = await handleCorsPreflightAsync(req, res, \"GET,OPTIONS\");\n    if (corsHandled) {\n      return resolve();\n    }\n\nconst apiKey = process.env.CONST APIKEY || \"\";\n    if (apiKey) {\n      req.headers[\"x-api-key\"] = apiKey;\n      req.headers[\"authorization\"] = `Bearer ${apiKey}`;\n    }\n\n    proxy.web(\n      req,\n      res,\n      {\n        target:\n          process.env.BACKEND_BASE_URL ||\n          process.env.NEXT_PUBLIC_API_URL ||\n          \"http://localhost:3001\",\n        changeOrigin: true,\n        selfHandleResponse: false,\n        timeout: 35000,\n      },\n      (err: any) => {\n        console.error(\"Proxy error:\", err);\n        if (err.code === \"ECONNREFUSED\" || err.code === \"ENOTFOUND\") {\n          res\n            .status(503)\n            .json({\n              error: \"Backend unavailable\",\n              details:\n                \"AI service is not running. Please start the backend services.\",\n              code: \"BACKEND_DOWN\",\n            });\n        } else {\n          res\n            .status(500)\n            .json({\n              error: \"Proxy failed\",\n              details: err.message,\n              code: err.code || \"PROXY_ERROR\",\n            });\n        }\n        reject(err);\n      },\n    );\n  });\n}\n\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true,\n  },\n};"
  },
  {
    "file_path": "frontend/src/__tests__/hooks/useDeepgramVoice.test.tsx",
    "modifications": [
      {
        "line": 45,
        "original": "const mockApiKey = \"test-deepgram-api-key\";",
        "modified": "const mockApiKey = process.env.CONST MOCKAPIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Cartrita AI OS - Enhanced Deepgram Voice Hook Tests\n// Comprehensive tests for production-ready WebSocket integration\n\n// Mock must be at the very top\nconst mockStartVoiceRecording = vi.fn();\nconst mockStopVoiceRecording = vi.fn();\nconst mockConnect = vi.fn();\n\nvi.mock(\"@/services/deepgram\", () => {\n  class MockDeepgramVoiceService {\n    startVoiceRecording = mockStartVoiceRecording.mockImplementation(() => {\n      console.log(\"Mock startVoiceRecording called\");\n      return Promise.resolve();\n    });\n    stopVoiceRecording = mockStopVoiceRecording.mockImplementation(() => {\n      console.log(\"Mock stopVoiceRecording called\");\n      return Promise.resolve();\n    });\n    connect = mockConnect.mockImplementation(() => {\n      console.log(\"Mock connect called\");\n      return Promise.resolve();\n    });\n    on = vi.fn();\n    emit = vi.fn();\n  }\n\n  return {\n    __esModule: true,\n    default: MockDeepgramVoiceService,\n    DeepgramVoiceService: MockDeepgramVoiceService,\n    VoiceState: {},\n    VoiceTranscription: {},\n    VoiceAnalytics: {},\n    DeepgramConfig: {},\n  };\n});\n\nimport { describe, it, expect, beforeEach, afterEach, vi } from \"vitest\";\nimport { renderHook, act, waitFor } from \"@testing-library/react\";\nimport React from \"react\";\n\nimport { useDeepgramVoice } from \"@/hooks/useDeepgramVoice\";\n\n// Mock environment variables\nconst mockApiKey = process.env.CONST MOCKAPIKEY || \"\";\nvi.stubEnv(\"NEXT_PUBLIC_DEEPGRAM_API_KEY\", mockApiKey);\n\n// Mock MediaDevices\nconst mockGetUserMedia = vi.fn();\nObject.defineProperty(navigator, \"mediaDevices\", {\n  value: {\n    getUserMedia: mockGetUserMedia,\n  },\n  writable: true,\n});\n\n// Mock AudioContext\nglobal.AudioContext = vi.fn().mockImplementation(() => ({\n  createMediaStreamSource: vi.fn(),\n  createAnalyser: vi.fn(),\n  createGain: vi.fn(),\n  decodeAudioData: vi.fn().mockResolvedValue({}),\n  suspend: vi.fn(),\n  resume: vi.fn(),\n}));\n\n// Mock MediaRecorder\nconst MockMediaRecorder = vi.fn().mockImplementation(() => ({\n  start: vi.fn(),\n  stop: vi.fn(),\n  pause: vi.fn(),\n  resume: vi.fn(),\n  addEventListener: vi.fn(),\n  removeEventListener: vi.fn(),\n  dispatchEvent: vi.fn(),\n  state: \"inactive\",\n  mimeType: \"audio/webm\",\n  ondataavailable: null,\n  onstop: null,\n  onerror: null,\n}));\n\n// Add static method to MediaRecorder mock\nObject.defineProperty(MockMediaRecorder, \"isTypeSupported\", {\n  value: vi.fn().mockReturnValue(true),\n});\nglobal.MediaRecorder = MockMediaRecorder as any;\n\ndescribe(\"useDeepgramVoice\", () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n    mockGetUserMedia.mockResolvedValue({\n      getTracks: () => [{ stop: vi.fn() }],\n    });\n    mockConnect.mockResolvedValue(undefined);\n    mockStartVoiceRecording.mockResolvedValue(undefined);\n    mockStopVoiceRecording.mockResolvedValue(undefined);\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe(\"Initialization\", () => {\n    it(\"should initialize with default state\", async () => {\n      const { result } = renderHook(() => useDeepgramVoice());\n\n      // Wait for initialization to complete\n      await waitFor(() => {\n        expect(result.current.connectionState).toBe(\"connected\");\n      });\n\n      expect(result.current.isRecording).toBe(false);\n      expect(result.current.isConnected).toBe(true);\n      expect(result.current.voiceState).toBe(\"idle\");\n      expect(result.current.transcript).toBe(\"\");\n      expect(result.current.error).toBe(null);\n    });\n\n    it(\"should handle missing API key\", async () => {\n      vi.stubEnv(\"NEXT_PUBLIC_DEEPGRAM_API_KEY\", \"\");\n\n      const { result } = renderHook(() => useDeepgramVoice());\n\n      await waitFor(() => {\n        expect(result.current.error).toBe(\"Deepgram API key is required\");\n        expect(result.current.connectionState).toBe(\"error\");\n        expect(result.current.isConnected).toBe(false);\n      });\n\n      // Restore API key for other tests\n      vi.stubEnv(\"NEXT_PUBLIC_DEEPGRAM_API_KEY\", mockApiKey);\n    });\n  });\n\n  describe(\"Recording Controls\", () => {\n    it(\"should start recording successfully\", async () => {\n      const { result } = renderHook(() => useDeepgramVoice());\n\n      await act(async () => {\n        await result.current.startRecording();\n      });\n\n      expect(mockStartVoiceRecording).toHaveBeenCalled();\n      expect(result.current.error).toBe(null);\n    });\n\n    it(\"should stop recording successfully\", async () => {\n      const { result } = renderHook(() => useDeepgramVoice());\n\n      await act(async () => {\n        await result.current.stopRecording();\n      });\n\n      expect(mockStopVoiceRecording).toHaveBeenCalled();\n      expect(result.current.error).toBe(null);\n    });\n  });\n\n  describe(\"Mock Verification\", () => {\n    it(\"should use mocked service\", () => {\n      const { result } = renderHook(() => useDeepgramVoice());\n\n      // Just check that the hook initializes without error\n      expect(result.current).toBeDefined();\n    });\n  });\n});"
  },
  {
    "file_path": "tests/security/test_environment_security_validation.py",
    "modifications": [
      {
        "line": 142,
        "original": "valid_key = 'sk-abcd1234567890abcdefghijklmnopqrstuvwxyz'",
        "modified": "valid_key = os.getenv(\"VALID_KEY\", \"\")",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "#!/usr/bin/env python3\n\"\"\"\nEnvironment Variables & Secrets Management Security Validation Tests\n====================================================================\n\nComprehensive security validation tests for Task 8 implementation.\nTests environment variable validation, placeholder detection, API key format validation,\nand security enforcement mechanisms.\n\nSECURITY SCOPE:\n- OWASP A07 (Authentication Failures) prevention\n- OWASP A02 (Cryptographic Failures) mitigation\n- Hardcoded secrets detection\n- Environment variable format validation\n- Security policy enforcement\n\nUsage:\n    python tests/security/test_environment_security_validation.py\n\"\"\"\n\nimport os\nimport sys\nimport tempfile\nimport unittest\nfrom pathlib import Path\nfrom unittest.mock import patch, MagicMock\n\n# Add the services directory to the path for imports\nsys.path.insert(0, str(Path(__file__).parent.parent.parent / 'services'))\n\ntry:\n    from shared.config.secure_environment import (\n        SecureEnvironmentConfig,\n        SecurityError,\n        ValidationResult,\n        load_secure_environment,\n        get_validated_api_key\n    )\nexcept ImportError as e:\n    print(f\"\u274c Import error: {e}\")\n    print(\"Please ensure the secure_environment.py module is available\")\n    sys.exit(1)\n\nclass TestEnvironmentSecurityValidation(unittest.TestCase):\n    \"\"\"Test suite for environment variable security validation\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test environment\"\"\"\n        self.config = SecureEnvironmentConfig()\n        self.test_env_vars = {}\n        \n        # Store original environment to restore later\n        self.original_env = dict(os.environ)\n        \n    def tearDown(self):\n        \"\"\"Clean up test environment\"\"\"\n        # Restore original environment\n        os.environ.clear()\n        os.environ.update(self.original_env)\n        \n    def test_valid_api_key_formats(self):\n        \"\"\"Test valid API key format validation\"\"\"\n        valid_keys = {\n            'OPENAI_API_KEY': 'sk-abcd1234567890abcdefghijklmnopqrstuvwxyz',\n            'ANTHROPIC_API_KEY': 'sk-ant-abcd1234567890abcdefghijklmnopqr',\n            'HUGGINGFACE_TOKEN': 'hf_abcd1234567890abcdefghijklmnopqr',\n            'DEEPGRAM_API_KEY': 'abcd1234567890abcdef1234567890ab',  # 32 hex chars\n            'TAVILY_API_KEY': 'tvly-abcd1234567890abcdef',\n            'GITHUB_TOKEN': 'ghs_abcd1234567890abcdefghijklmnopqrstuvwxyz',\n            'LANGCHAIN_API_KEY': 'lsv2_pt_abcd1234567890abcdef',\n            'JWT_SECRET_KEY': 'abcd1234567890abcdefghijklmnopqrstuvwxyzABCD1234567890ABCDEFGHIJ='\n        }\n        \n        for key, value in valid_keys.items():\n            with self.subTest(key=key):\n                validation = self.config._validate_env_var(key, value)\n                self.assertEqual(validation.validation_result, ValidationResult.VALID)\n                self.assertTrue(validation.value_present)\n                \n    def test_invalid_api_key_formats(self):\n        \"\"\"Test invalid API key format detection\"\"\"\n        invalid_keys = {\n            'OPENAI_API_KEY': 'invalid-key',\n            'ANTHROPIC_API_KEY': 'sk-wrong-prefix',\n            'HUGGINGFACE_TOKEN': 'wrong_prefix_token',\n            'DEEPGRAM_API_KEY': 'too-short',\n            'TAVILY_API_KEY': 'wrong-prefix',\n            'GITHUB_TOKEN': 'invalid_github_token',\n            'LANGCHAIN_API_KEY': 'wrong_prefix_key',\n            'JWT_SECRET_KEY': 'tooshort'\n        }\n        \n        for key, value in invalid_keys.items():\n            with self.subTest(key=key):\n                validation = self.config._validate_env_var(key, value)\n                self.assertEqual(validation.validation_result, ValidationResult.INVALID_FORMAT)\n                self.assertEqual(validation.security_level, \"high\")\n                \n    def test_placeholder_detection(self):\n        \"\"\"Test placeholder pattern detection\"\"\"\n        placeholder_values = [\n            'REPLACE_WITH_YOUR_KEY',\n            'your_openai_key_here',\n            'sk-proj-your_key',\n            'lsv2_pt_your_key',\n            'INSERT_YOUR_API_KEY',\n            'CHANGE_THIS_SECRET',\n            'PLACEHOLDER_VALUE',\n            'EXAMPLE_KEY',\n            'TEST_KEY_123',\n            'DEMO_API_KEY'\n        ]\n        \n        for value in placeholder_values:\n            with self.subTest(value=value):\n                validation = self.config._validate_env_var('TEST_KEY', value)\n                self.assertEqual(validation.validation_result, ValidationResult.PLACEHOLDER_DETECTED)\n                self.assertEqual(validation.security_level, \"critical\")\n                \n    def test_minimum_length_enforcement(self):\n        \"\"\"Test minimum length requirements\"\"\"\n        short_keys = {\n            'OPENAI_API_KEY': 'sk-short',  # Too short\n            'HUGGINGFACE_TOKEN': 'hf_short',  # Too short  \n            'JWT_SECRET_KEY': 'short_secret'  # Too short\n        }\n        \n        for key, value in short_keys.items():\n            with self.subTest(key=key):\n                validation = self.config._validate_env_var(key, value)\n                self.assertEqual(validation.validation_result, ValidationResult.INSUFFICIENT_ENTROPY)\n                self.assertEqual(validation.security_level, \"high\")\n                \n    def test_missing_environment_variables(self):\n        \"\"\"Test handling of missing environment variables\"\"\"\n        validation = self.config._validate_env_var('MISSING_KEY', '')\n        self.assertEqual(validation.validation_result, ValidationResult.MISSING)\n        self.assertFalse(validation.value_present)\n        \n    def test_secure_api_key_retrieval_success(self):\n        \"\"\"Test successful secure API key retrieval\"\"\"\nvalid_key = os.getenv(\"VALID_KEY\", \"\")\n        os.environ['OPENAI_API_KEY'] = valid_key\n        \n        retrieved_key = self.config.get_secure_api_key('OPENAI_API_KEY', required=True)\n        self.assertEqual(retrieved_key, valid_key)\n        \n    def test_secure_api_key_retrieval_failure(self):\n        \"\"\"Test secure API key retrieval with invalid key\"\"\"\n        os.environ['OPENAI_API_KEY'] = 'REPLACE_WITH_YOUR_KEY'\n        \n        with self.assertRaises(SecurityError):\n            self.config.get_secure_api_key('OPENAI_API_KEY', required=True)\n            \n    def test_optional_api_key_handling(self):\n        \"\"\"Test optional API key handling\"\"\"\n        # Test with missing optional key\n        result = self.config.get_secure_api_key('OPTIONAL_KEY', required=False)\n        self.assertIsNone(result)\n        \n        # Test with invalid optional key\n        os.environ['OPTIONAL_KEY'] = 'PLACEHOLDER_VALUE'\n        result = self.config.get_secure_api_key('OPTIONAL_KEY', required=False)\n        self.assertIsNone(result)\n        \n    def test_environment_file_loading(self):\n        \"\"\"Test secure environment file loading\"\"\"\n        # Create temporary environment file\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.env', delete=False) as f:\n            f.write('TEST_VALID_KEY=sk-abcd1234567890abcdefghijklmnopqrstuvwxyz\\n')\n            f.write('TEST_PLACEHOLDER=REPLACE_WITH_YOUR_KEY\\n')\n            f.write('# This is a comment\\n')\n            f.write('\\n')  # Empty line\n            temp_file = f.name\n            \n        try:\n            # Mock the path resolution to use our temp file\n            with patch.object(Path, 'exists', return_value=True):\n                with patch('builtins.open', unittest.mock.mock_open(read_data=Path(temp_file).read_text())):\n                    env_vars = self.config.load_env_file('.env')\n                    \n            # Verify only valid keys are loaded\n            self.assertIn('TEST_VALID_KEY', env_vars)\n            self.assertNotIn('TEST_PLACEHOLDER', env_vars)\n            \n        finally:\n            # Clean up temp file\n            os.unlink(temp_file)\n            \n    def test_validation_report_generation(self):\n        \"\"\"Test validation report generation\"\"\"\n        # Add some validation results\n        self.config.validation_results = [\n            self.config._validate_env_var('VALID_KEY', 'sk-abcd1234567890abcdefghijklmnopqrstuvwxyz'),\n            self.config._validate_env_var('INVALID_KEY', 'PLACEHOLDER_VALUE'),\n            self.config._validate_env_var('MISSING_KEY', '')\n        ]\n        \n        report = self.config.get_validation_report()\n        \n        self.assertEqual(report['total_variables'], 3)\n        self.assertEqual(report['valid_variables'], 1)\n        self.assertEqual(len(report['security_issues']), 2)\n        self.assertIn('recommendations', report)\n        \n    def test_critical_failure_tracking(self):\n        \"\"\"Test critical failure tracking\"\"\"\n        # Simulate critical failure\n        validation = self.config._validate_env_var('OPENAI_API_KEY', 'REPLACE_WITH_YOUR_KEY')\n        self.config.validation_results.append(validation)\n        \n        if validation.validation_result != ValidationResult.VALID:\n            self.config.critical_failures.append(f\"Critical failure for OPENAI_API_KEY\")\n            \n        is_secure, errors = self.config.validate_all_environment_vars()\n        \n        self.assertFalse(is_secure)\n        self.assertGreater(len(errors), 0)\n        \n    def test_hardcoded_secrets_removed(self):\n        \"\"\"Test that hardcoded secrets have been removed from scripts\"\"\"\n        script_file = Path(__file__).parent.parent.parent / 'scripts' / 'test_final_integration.py'\n        \n        if script_file.exists():\n            content = script_file.read_text()\n            \n            # Patterns that should NOT be found (hardcoded secrets)\n            forbidden_patterns = [\n                r'sk-proj-[a-zA-Z0-9\\-_]{50,}',  # OpenAI keys\n                r'hf_[a-zA-Z0-9]{20,}',  # HuggingFace tokens\n                r'lsv2_pt_[a-zA-Z0-9_]{20,}'  # LangChain keys\n            ]\n            \n            for pattern in forbidden_patterns:\n                import re\n                matches = re.findall(pattern, content)\n                self.assertEqual(len(matches), 0, \n                    f\"Found hardcoded secret pattern {pattern} in test_final_integration.py\")\n                    \n    @patch('sys.exit')\n    def test_load_secure_environment_with_failures(self, mock_exit):\n        \"\"\"Test load_secure_environment with security failures\"\"\"\n        # Mock environment with security issues\n        test_env_content = \"\"\"\nOPENAI_API_KEY=REPLACE_WITH_YOUR_KEY\nJWT_SECRET_KEY=short\n\"\"\"\n        \n        with tempfile.NamedTemporaryFile(mode='w', suffix='.env', delete=False) as f:\n            f.write(test_env_content)\n            temp_file = f.name\n            \n        try:\n            with patch.object(Path, 'exists', return_value=True):\n                with patch('builtins.open', unittest.mock.mock_open(read_data=test_env_content)):\n                    result = load_secure_environment('.env')\n                    \n            self.assertFalse(result)\n            \n        finally:\n            os.unlink(temp_file)\n            \n    def test_security_logging(self):\n        \"\"\"Test security event logging\"\"\"\n        with patch('services.shared.config.secure_environment.security_logger') as mock_logger:\n            # Trigger security validation failure\n            validation = self.config._validate_env_var('OPENAI_API_KEY', 'PLACEHOLDER_VALUE')\n            self.config.validation_results.append(validation)\n            self.config.critical_failures.append(\"Test critical failure\")\n            \n            is_secure, errors = self.config.validate_all_environment_vars()\n            \n            # Verify logging was called\n            mock_logger.critical.assert_called()\n\nclass TestSecurityIntegration(unittest.TestCase):\n    \"\"\"Integration tests for complete security system\"\"\"\n    \n    def test_complete_security_workflow(self):\n        \"\"\"Test complete security validation workflow\"\"\"\n        # Test the complete workflow from loading to validation\n        config = SecureEnvironmentConfig()\n        \n        # Test with secure environment\n        secure_env = {\n            'OPENAI_API_KEY': 'sk-abcd1234567890abcdefghijklmnopqrstuvwxyz',\n            'JWT_SECRET_KEY': 'abcd1234567890abcdefghijklmnopqrstuvwxyzABCD1234567890ABCDEFGHIJ='\n        }\n        \n        for key, value in secure_env.items():\n            os.environ[key] = value\n            \n        try:\n            # Test secure API key retrieval\n            openai_key = get_validated_api_key('OPENAI_API_KEY', required=True)\n            self.assertEqual(openai_key, secure_env['OPENAI_API_KEY'])\n            \n            # Test validation passes\n            is_secure, errors = config.validate_all_environment_vars()\n            # Note: This may still fail due to missing DATABASE_PASSWORD, but OPENAI_API_KEY should be valid\n            \n        finally:\n            # Clean up\n            for key in secure_env.keys():\n                if key in os.environ:\n                    del os.environ[key]\n\ndef run_security_validation_tests():\n    \"\"\"Run all security validation tests with detailed reporting\"\"\"\n    print(\"\ud83d\udd12 Running Environment Variables & Secrets Management Security Tests\")\n    print(\"=\" * 70)\n    \n    # Create test suite\n    loader = unittest.TestLoader()\n    suite = unittest.TestSuite()\n    \n    # Add test classes\n    suite.addTests(loader.loadTestsFromTestCase(TestEnvironmentSecurityValidation))\n    suite.addTests(loader.loadTestsFromTestCase(TestSecurityIntegration))\n    \n    # Run tests with detailed output\n    runner = unittest.TextTestRunner(verbosity=2, stream=sys.stdout)\n    result = runner.run(suite)\n    \n    # Print summary\n    print(\"\\n\" + \"=\" * 70)\n    print(\"\ud83d\udd12 Security Validation Test Results:\")\n    print(f\"\u2705 Tests Run: {result.testsRun}\")\n    print(f\"\u274c Failures: {len(result.failures)}\")\n    print(f\"\u26a0\ufe0f  Errors: {len(result.errors)}\")\n    \n    if result.failures:\n        print(\"\\n\u274c Test Failures:\")\n        for test, traceback in result.failures:\n            print(f\"   - {test}: {traceback.split('AssertionError:')[-1].strip()}\")\n            \n    if result.errors:\n        print(\"\\n\u26a0\ufe0f  Test Errors:\")\n        for test, traceback in result.errors:\n            print(f\"   - {test}: {traceback.split('Exception:')[-1].strip()}\")\n            \n    success = len(result.failures) == 0 and len(result.errors) == 0\n    \n    if success:\n        print(\"\\n\ud83c\udf89 All security validation tests passed!\")\n        print(\"\u2705 Environment Variables & Secrets Management Security: VALIDATED\")\n    else:\n        print(\"\\n\u274c Security validation tests failed!\")\n        print(\"\u26a0\ufe0f  Please review and fix the reported issues.\")\n        \n    return success\n\nif __name__ == '__main__':\n    success = run_security_validation_tests()\n    sys.exit(0 if success else 1)"
  }
]

[
  {
    "file_path": "frontend/src/services/api.ts",
    "modifications": [
      {
        "line": 553,
        "original": "const apiKey = this.client.defaults.headers.common['X-API-Key'] as string",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Cartrita AI OS - API Client\n// Comprehensive API client for frontend-backend communication\n\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, InternalAxiosRequestConfig } from 'axios'\nimport { z } from 'zod'\nimport type {\n  User,\n  Conversation,\n  Message,\n  Agent,\n  ChatRequest,\n  ChatResponse,\n  ApiResponse,\n  StreamingChunk,\n  HealthStatus,\n  MetricsData,\n  SearchFilters,\n  Plugin,\n  Workspace,\n  Notification,\n  VoiceSettings,\n  ThemeConfig,\n  FileUploadResult\n} from '@/types'\nimport {\n  createApiResponse,\n  handleApiError,\n  createStreamingChunk,\n  logError\n} from '@/utils'\n\n// SSE Event Types based on our schema\nexport type SSEEvent =\n  | { event: 'stream_start'; data: { conversation_id: string }; id?: string; retry?: number }\n  | { event: 'token'; data: { content: string; delta?: string }; id?: string; retry?: number }\n  | { event: 'function_call'; data: { function_name: string; arguments: unknown }; id?: string; retry?: number }\n  | { event: 'tool_result'; data: { tool_name: string; result: unknown }; id?: string; retry?: number }\n  | { event: 'agent_task_start'; data: { task_id: string; agent_type: string; description: string }; id?: string; retry?: number }\n  | { event: 'agent_task_progress'; data: { task_id: string; progress: number; status: string }; id?: string; retry?: number }\n  | { event: 'agent_task_complete'; data: { task_id: string; result: unknown; success: boolean }; id?: string; retry?: number }\n  | { event: 'metrics'; data: Record<string, unknown>; id?: string; retry?: number }\n  | { event: 'error'; data: { error: string; code?: string; recoverable?: boolean }; id?: string; retry?: number }\n  | { event: 'done'; data: { final_response: string; conversation_id: string; agent_type?: string; processing_time?: number; token_usage?: unknown; sources?: unknown; message_id?: string }; id?: string; retry?: number }\n\n// Narrow helper\nfunction isSSEEvent(value: unknown): value is SSEEvent {\n  return typeof value === 'object' && value !== null && 'event' in (value as any) && 'data' in (value as any)\n}\n\nexport interface StreamingCallbacks {\n  onToken?: (content: string, delta?: string) => void\n  onFunctionCall?: (functionName: string, args: unknown) => void\n  onToolResult?: (toolName: string, result: unknown) => void\n  onAgentTaskStart?: (taskId: string, agentType: string, description: string) => void\n  onAgentTaskProgress?: (taskId: string, progress: number, status: string) => void\n  onAgentTaskComplete?: (taskId: string, result: unknown, success: boolean) => void\n  onMetrics?: (metrics: unknown) => void\n  onError?: (error: string, code: string, recoverable: boolean) => void\n  onDone?: (finalResponse: string, metadata: unknown) => void\n}\n\n// WebSocket Message Types\nexport interface WebSocketMessage {\n  type: 'auth' | 'chat' | 'ping' | 'pong'\n  api_key?: string\n  message?: string\n  context?: Record<string, unknown>\n  conversation_id?: string\n}\n\n// Extend AxiosRequestConfig to include metadata\ndeclare module 'axios' {\n  interface AxiosRequestConfig {\n    metadata?: {\n      requestId: string\n      startTime: number\n    }\n  }\n}\n\n// API Response Schemas for Runtime Validation\n// Some legacy endpoints (e.g. /health) may not include `success`; we'll handle that gracefully.\nconst ApiResponseSchema = z.object({\n  success: z.boolean().optional(),\n  data: z.any().optional(),\n  error: z.string().optional(),\n  message: z.string().optional(),\n  metadata: z.object({\n    timestamp: z.string().optional(),\n    version: z.string().optional(),\n    requestId: z.string().optional(),\n    processingTime: z.number().optional()\n  }).optional()\n})\n\n// Health status schema reflecting backend expectations (success may be absent)\nconst HealthStatusSchema = z.object({\n  status: z.enum(['healthy', 'unhealthy', 'degraded']).optional(),\n  version: z.string().optional(),\n  uptime: z.number().optional(),\n  timestamp: z.string().optional(),\n  services: z.record(z.any()).optional()\n}).passthrough()\n\nconst UserSchema = z.object({\n  id: z.string(),\n  email: z.string().email(),\n  name: z.string(),\n  avatar: z.string().optional(),\n  preferences: z.object({\n    theme: z.enum(['light', 'dark', 'system']),\n    language: z.string(),\n    notifications: z.boolean(),\n    autoSave: z.boolean()\n  }),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n  lastLoginAt: z.string().optional(),\n  isActive: z.boolean(),\n  role: z.enum(['user', 'admin', 'moderator'])\n})\n\nconst ConversationSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  messages: z.array(z.any()), // Will be validated separately\n  agentId: z.string().optional(),\n  workspaceId: z.string().optional(),\n  userId: z.string(),\n  isArchived: z.boolean(),\n  isPinned: z.boolean(),\n  tags: z.array(z.string()),\n  metadata: z.record(z.any()),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n  lastMessageAt: z.string().optional()\n})\n\nconst MessageSchema = z.object({\n  id: z.string(),\n  conversationId: z.string(),\n  role: z.enum(['user', 'assistant', 'system']),\n  content: z.string(),\n  attachments: z.array(z.any()).optional(),\n  metadata: z.record(z.any()),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n  isEdited: z.boolean(),\n  tokens: z.number().optional(),\n  processingTime: z.number().optional()\n})\n\nconst AgentSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  description: z.string(),\n  type: z.string(),\n  capabilities: z.array(z.string()),\n  model: z.string(),\n  parameters: z.record(z.any()),\n  isActive: z.boolean(),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n  metrics: z.object({\n    totalRequests: z.number(),\n    successRate: z.number(),\n    avgLatency: z.number(),\n    lastActive: z.string()\n  })\n})\n\n// Custom Error Classes\nexport class ApiError extends Error {\n  constructor(\n    public status: number,\n    message: string,\n    public response?: unknown,\n    public requestId?: string\n  ) {\n    super(message)\n    this.name = 'ApiError'\n  }\n}\n\nexport class NetworkError extends Error {\n  constructor(message: string, public originalError?: unknown) {\n    super(message)\n    this.name = 'NetworkError'\n  }\n}\n\nexport class ValidationError extends Error {\n  constructor(message: string, public errors?: Record<string, string[]>) {\n    super(message)\n    this.name = 'ValidationError'\n  }\n}\n\n// Main API Client Class\nexport class CartritaApiClient {\n  private client: AxiosInstance\n  private baseURL: string\n  private timeout: number\n  private retryCount: number\n  private requestQueue: Map<string, AbortController> = new Map()\n\n  constructor(config: {\n    baseURL?: string\n    timeout?: number\n    retryCount?: number\n    apiKey?: string\n  } = {}) {\n    this.baseURL = config.baseURL || process.env.NEXT_PUBLIC_API_URL || '/api'\n    this.timeout = config.timeout || 30000\n    this.retryCount = config.retryCount || 3\n\n    // Get API key from multiple sources\n    const apiKey = config.apiKey || \n                   process.env.NEXT_PUBLIC_CARTRITA_API_KEY || \n                   'dev-key-cartrita-ai-os'\n\n    this.client = axios.create({\n      baseURL: this.baseURL,\n      timeout: this.timeout,\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Client-Version': 'Cartrita-Client/2.0.0',\n        // Support both header formats for compatibility\n        'X-API-Key': apiKey,\n        'Authorization': `Bearer ${apiKey}`\n      }\n    })\n\n    this.setupInterceptors()\n  }\n\n  // Static method to create instance\n  static createInstance(config?: {\n    baseURL?: string\n    timeout?: number\n    retryCount?: number\n    apiKey?: string\n  }): CartritaApiClient {\n    return new CartritaApiClient(config)\n  }\n\n  // Set authentication token\n  setAuthToken(token: string): void {\n    this.client.defaults.headers.common['Authorization'] = `Bearer ${token}`\n    this.client.defaults.headers.common['X-API-Key'] = token\n  }\n\n  // Remove authentication token\n  removeAuthToken(): void {\n    delete this.client.defaults.headers.common['Authorization']\n    delete this.client.defaults.headers.common['X-API-Key']\n  }\n\n  private setupInterceptors() {\n    // Request interceptor\n    this.client.interceptors.request.use(\n      (config: InternalAxiosRequestConfig) => {\n        const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n        config.metadata = { requestId, startTime: Date.now() }\n\n        // Add to request queue for cancellation\n        const controller = new AbortController()\n        config.signal = controller.signal\n        this.requestQueue.set(requestId, controller)\n\n        return config\n      },\n      (error) => {\n        logError(error, { context: 'request_interceptor' })\n        return Promise.reject(error)\n      }\n    )\n\n    // Response interceptor\n    this.client.interceptors.response.use(\n      (response) => {\n        const requestId = response.config.metadata?.requestId\n        if (requestId) {\n          this.requestQueue.delete(requestId)\n        }\n\n        // Validate response structure\n        try {\n            // Attempt generic API response validation; tolerate health/status endpoints\n            ApiResponseSchema.parse(response.data)\n        } catch (validationError) {\n            // Special-case: /health endpoint often returns a plain object without success flag\n            if (response.config.url?.includes('/health')) {\n              try {\n                HealthStatusSchema.parse(response.data)\n              } catch (healthErr) {\n                logError(healthErr as Error, {\n                  context: 'health_response_validation',\n                  requestId,\n                  url: response.config.url\n                })\n              }\n            } else {\n              logError(validationError as Error, {\n                context: 'response_validation',\n                requestId,\n                url: response.config.url\n              })\n            }\n        }\n\n        return response\n      },\n      (error) => {\n        const requestId = error.config?.metadata?.requestId\n        if (requestId) {\n          this.requestQueue.delete(requestId)\n        }\n\n        if (error.code === 'ECONNABORTED' || error.code === 'ENOTFOUND') {\n          return Promise.reject(new NetworkError('Network connection failed', error))\n        }\n\n        if (error.response?.status === 422) {\n          const validationErrors = error.response.data?.errors\n          return Promise.reject(new ValidationError('Validation failed', validationErrors))\n        }\n\n        if (error.response) {\n          return Promise.reject(new ApiError(\n            error.response.status,\n            error.response.data?.error || error.message,\n            error.response.data,\n            requestId\n          ))\n        }\n\n        logError(error, { context: 'response_interceptor', requestId })\n        return Promise.reject(error)\n      }\n    )\n  }\n\n  // Generic request method with retry logic\n  private async request<T>(\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH',\n    endpoint: string,\n    data?: unknown,\n    config?: AxiosRequestConfig\n  ): Promise<ApiResponse<T>> {\n    const requestConfig: AxiosRequestConfig = {\n      method,\n      url: endpoint,\n      ...(data && { data }),\n      ...config\n    }\n\n    let lastError: unknown\n\n    for (let attempt = 1; attempt <= this.retryCount; attempt++) {\n      try {\n        const response: AxiosResponse<ApiResponse<T>> = await this.client.request(requestConfig)\n        return response.data\n      } catch (error) {\n        lastError = error\n\n        // Don't retry on client errors (4xx) except 429 (rate limit)\n        if (error instanceof ApiError && error.status >= 400 && error.status < 500 && error.status !== 429) {\n          break\n        }\n\n        // Don't retry on the last attempt\n        if (attempt === this.retryCount) {\n          break\n        }\n\n        // Exponential backoff\n        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000)\n        await new Promise(resolve => setTimeout(resolve, delay))\n      }\n    }\n\n    throw lastError\n  }\n\n  // Authentication methods\n  async login(email: string, password: string): Promise<ApiResponse<{ user: User; token: string }>> {\n    return this.request('POST', '/auth/login', { email, password })\n  }\n\n  async register(userData: {\n    email: string\n    password: string\n    name: string\n  }): Promise<ApiResponse<{ user: User; token: string }>> {\n    return this.request('POST', '/auth/register', userData)\n  }\n\n  async logout(): Promise<ApiResponse<void>> {\n    return this.request('POST', '/auth/logout')\n  }\n\n  async refreshToken(): Promise<ApiResponse<{ token: string }>> {\n    return this.request('POST', '/auth/refresh')\n  }\n\n  async getCurrentUser(): Promise<ApiResponse<User>> {\n    const response = await this.request<User>('GET', '/auth/me')\n    try {\n      UserSchema.parse(response.data)\n    } catch (error) {\n      throw new ValidationError('Invalid user data received')\n    }\n    return response\n  }\n\n  async updateUserPreferences(preferences: Partial<User['preferences']>): Promise<ApiResponse<User>> {\n    return this.request('PUT', '/auth/preferences', { preferences })\n  }\n\n  async updateThemeConfig(themeConfig: ThemeConfig): Promise<ApiResponse<User>> {\n    return this.request('PUT', '/auth/theme', { themeConfig })\n  }\n\n  async updateVoiceSettings(voiceSettings: VoiceSettings): Promise<ApiResponse<User>> {\n    return this.request('PUT', '/auth/voice', { voiceSettings })\n  }\n\n  // Conversation methods\n  async getConversations(filters?: SearchFilters): Promise<ApiResponse<Conversation[]>> {\n    const params = filters ? new URLSearchParams(filters as any).toString() : ''\n    const endpoint = `/conversations${params ? `?${params}` : ''}`\n    return this.request('GET', endpoint)\n  }\n\n  async getConversation(id: string): Promise<ApiResponse<Conversation>> {\n    const response = await this.request<Conversation>('GET', `/conversations/${id}`)\n    try {\n      ConversationSchema.parse(response.data)\n    } catch (error) {\n      throw new ValidationError('Invalid conversation data received')\n    }\n    return response\n  }\n\n  async createConversation(data: {\n    title?: string\n    agentId?: string\n    workspaceId?: string\n    initialMessage?: string\n  }): Promise<ApiResponse<Conversation>> {\n    return this.request('POST', '/conversations', data)\n  }\n\n  async updateConversation(\n    id: string,\n    data: Partial<Pick<Conversation, 'title' | 'isArchived' | 'tags'>>\n  ): Promise<ApiResponse<Conversation>> {\n    return this.request('PUT', `/conversations/${id}`, data)\n  }\n\n  async deleteConversation(id: string): Promise<ApiResponse<void>> {\n    return this.request('DELETE', `/conversations/${id}`)\n  }\n\n  async archiveConversation(id: string): Promise<ApiResponse<Conversation>> {\n    return this.request('PUT', `/conversations/${id}/archive`)\n  }\n\n  async pinConversation(id: string): Promise<ApiResponse<Conversation>> {\n    return this.request('PUT', `/conversations/${id}/pin`)\n  }\n\n  // Message methods\n  async getMessages(\n    conversationId: string,\n    params?: { limit?: number; offset?: number; before?: string; after?: string }\n  ): Promise<ApiResponse<Message[]>> {\n    const queryParams = params ? new URLSearchParams(params as any).toString() : ''\n    const endpoint = `/conversations/${conversationId}/messages${queryParams ? `?${queryParams}` : ''}`\n    const response = await this.request<Message[]>('GET', endpoint)\n\n    // Validate each message\n    if (Array.isArray(response.data)) {\n      response.data.forEach((message, index) => {\n        try {\n          MessageSchema.parse(message)\n        } catch (error) {\n          logError(error as Error, {\n            context: 'message_validation',\n            conversationId,\n            messageIndex: index\n          })\n        }\n      })\n    }\n\n    return response\n  }\n\n  async sendMessage(\n    conversationId: string,\n    message: ChatRequest\n  ): Promise<ApiResponse<ChatResponse>> {\n    return this.request('POST', `/conversations/${conversationId}/messages`, message)\n  }\n\n  // New chat method that matches backend\n  async postChat(request: ChatRequest): Promise<ApiResponse<ChatResponse>> {\n    const response = await this.request<ChatResponse>('POST', '/chat', request)\n    \n    // Normalize backend response to frontend Message shape\n    if (response.data) {\n      const normalizedMessage: Message = {\n        id: crypto.randomUUID(),\n        conversationId: response.data.conversation_id as string,\n        role: 'assistant',\n        content: response.data.response,\n        attachments: [],\n        metadata: response.data.metadata || {},\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        isEdited: false,\n        tokens: response.data.token_usage?.total_tokens,\n        processingTime: response.data.processing_time\n      }\n      \n      // Attach normalized message\n      response.data.message = normalizedMessage\n    }\n    \n    return response\n  }\n\n  async editMessage(\n    conversationId: string,\n    messageId: string,\n    content: string\n  ): Promise<ApiResponse<Message>> {\n    return this.request('PUT', `/conversations/${conversationId}/messages/${messageId}`, { content })\n  }\n\n  async deleteMessage(conversationId: string, messageId: string): Promise<ApiResponse<void>> {\n    return this.request('DELETE', `/conversations/${conversationId}/messages/${messageId}`)\n  }\n\n  // SSE Streaming chat method (primary)\n  async streamChatSSE(\n    request: ChatRequest,\n    callbacks: StreamingCallbacks\n  ): Promise<{ eventSource: EventSource; conversationId: string }> {\n    const endpoint = `${this.baseURL.replace('/api', '')}/api/chat/stream`\nconst apiKey = process.env.CONST APIKEY || \"\";\n    \n    // Create EventSource with POST data via URL params (EventSource limitation workaround)\n    const params = new URLSearchParams({\n      message: request.message,\n      ...(request.conversation_id && { conversation_id: request.conversation_id }),\n      ...(request.agent_override && { agent_override: request.agent_override }),\n      ...(request.context && { context: JSON.stringify(request.context) }),\n      api_key: apiKey\n    })\n    \n    const eventSource = new EventSource(`${endpoint}?${params}`)\n    let conversationId = request.conversation_id || ''\n    \n    eventSource.onmessage = (event) => {\n      try {\n        const parsed = JSON.parse(event.data)\n        if (!isSSEEvent(parsed)) return\n        const sseEvent = parsed\n        switch (sseEvent.event) {\n          case 'stream_start':\n            conversationId = sseEvent.data.conversation_id\n            break\n          case 'token':\n            callbacks.onToken?.(sseEvent.data.content, sseEvent.data.delta)\n            break\n          case 'function_call':\n            callbacks.onFunctionCall?.(sseEvent.data.function_name, sseEvent.data.arguments)\n            break\n          case 'tool_result':\n            callbacks.onToolResult?.(sseEvent.data.tool_name, sseEvent.data.result)\n            break\n          case 'agent_task_start':\n            callbacks.onAgentTaskStart?.(sseEvent.data.task_id, sseEvent.data.agent_type, sseEvent.data.description)\n            break\n          case 'agent_task_progress':\n            callbacks.onAgentTaskProgress?.(sseEvent.data.task_id, sseEvent.data.progress, sseEvent.data.status)\n            break\n          case 'agent_task_complete':\n            callbacks.onAgentTaskComplete?.(sseEvent.data.task_id, sseEvent.data.result, sseEvent.data.success)\n            break\n          case 'metrics':\n            callbacks.onMetrics?.(sseEvent.data)\n            break\n          case 'error':\n            callbacks.onError?.(sseEvent.data.error, sseEvent.data.code, sseEvent.data.recoverable ?? false)\n            break\n          case 'done':\n            callbacks.onDone?.(sseEvent.data.final_response, sseEvent.data)\n            eventSource.close()\n            break\n        }\n      } catch (error) {\n        logError(error as Error, {\n          context: 'sse_parse_error',\n          rawData: event.data\n        })\n      }\n    }\n    \n    eventSource.onerror = (error) => {\n      logError(new Error('SSE connection error'), {\n        context: 'sse_connection_error',\n        error\n      })\n      callbacks.onError?.('SSE connection failed', 'SSE_ERROR', true)\n    }\n    \n    return { eventSource, conversationId }\n  }\n\n  // WebSocket streaming chat method (fallback)\n  async streamChatWebSocket(\n    request: ChatRequest,\n    callbacks: StreamingCallbacks\n  ): Promise<{ websocket: WebSocket; conversationId: string }> {\n    const wsUrl = this.baseURL.replace('http', 'ws').replace('/api', '') + '/ws/chat'\n    const websocket = new WebSocket(wsUrl)\n    let conversationId = request.conversation_id || ''\n    \n    return new Promise((resolve, reject) => {\n      websocket.onopen = () => {\n        // Authenticate\n        const authMessage: WebSocketMessage = {\n          type: 'auth',\n          api_key: this.client.defaults.headers.common['X-API-Key'] as string\n        }\n        websocket.send(JSON.stringify(authMessage))\n        \n        // Send chat message\n        const chatMessage: WebSocketMessage = {\n          type: 'chat',\n          message: request.message,\n          context: request.context,\n          conversation_id: request.conversation_id\n        }\n        websocket.send(JSON.stringify(chatMessage))\n        \n        resolve({ websocket, conversationId })\n      }\n      \n      websocket.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data)\n          \n          if (data.error) {\n            callbacks.onError?.(data.error, 'WS_ERROR', false)\n            return\n          }\n          \n          // Handle current backend format (single response)\n          if (data.response && data.done) {\n            conversationId = data.conversation_id\n            callbacks.onDone?.(data.response, {\n              conversation_id: data.conversation_id,\n              agent_type: data.agent_type,\n              processing_time: data.processing_time\n            })\n          }\n        } catch (error) {\n          logError(error as Error, {\n            context: 'websocket_parse_error',\n            rawData: event.data\n          })\n        }\n      }\n      \n      websocket.onerror = (error) => {\n        logError(new Error('WebSocket connection error'), {\n          context: 'websocket_connection_error',\n          error\n        })\n        callbacks.onError?.('WebSocket connection failed', 'WS_ERROR', false)\n        reject(error)\n      }\n      \n      websocket.onclose = () => {\n        // Connection closed\n      }\n    })\n  }\n\n  // Unified streaming method with SSE primary, WebSocket fallback\n  async streamChat(\n    request: ChatRequest,\n    callbacks: StreamingCallbacks\n  ): Promise<{ close: () => void; conversationId: string }> {\n    try {\n      // Try SSE first\n      const { eventSource, conversationId } = await this.streamChatSSE(request, callbacks)\n      \n      return {\n        close: () => eventSource.close(),\n        conversationId\n      }\n    } catch (sseError) {\n      logError(sseError as Error, {\n        context: 'sse_fallback_to_websocket'\n      })\n      \n      // Fallback to WebSocket\n      try {\n        const { websocket, conversationId } = await this.streamChatWebSocket(request, callbacks)\n        \n        return {\n          close: () => websocket.close(),\n          conversationId\n        }\n      } catch (wsError) {\n        logError(wsError as Error, {\n          context: 'websocket_fallback_failed'\n        })\n        throw new Error('Both SSE and WebSocket streaming failed')\n      }\n    }\n  }\n\n  // Legacy streaming method for backward compatibility\n  async *streamChatLegacy(\n    conversationId: string,\n    message: ChatRequest\n  ): AsyncGenerator<StreamingChunk, void, unknown> {\n    let finalContent = ''\n    let isDone = false\n    \n    const { close } = await this.streamChat(message, {\n      onToken: (content, delta) => {\n        finalContent += delta || content\n      },\n      onDone: (finalResponse) => {\n        finalContent = finalResponse\n        isDone = true\n      },\n      onError: () => {\n        isDone = true\n      }\n    })\n    \n    // Simulate async generator behavior\n    while (!isDone) {\n      await new Promise(resolve => setTimeout(resolve, 100))\n      if (finalContent) {\n        yield createStreamingChunk(finalContent, isDone)\n      }\n    }\n    \n    close()\n  }\n\n  // Agent methods\n  async getAgents(): Promise<ApiResponse<Agent[]>> {\n    const response = await this.request<Agent[]>('GET', '/agents')\n    if (Array.isArray(response.data)) {\n      response.data.forEach((agent, index) => {\n        try {\n          AgentSchema.parse(agent)\n        } catch (error) {\n          logError(error as Error, {\n            context: 'agent_validation',\n            agentIndex: index\n          })\n        }\n      })\n    }\n    return response\n  }\n\n  async getAgent(id: string): Promise<ApiResponse<Agent>> {\n    const response = await this.request<Agent>('GET', `/agents/${id}`)\n    try {\n      AgentSchema.parse(response.data)\n    } catch (error) {\n      throw new ValidationError('Invalid agent data received')\n    }\n    return response\n  }\n\n  async createAgent(agentData: Omit<Agent, 'id' | 'createdAt' | 'updatedAt' | 'metrics'>): Promise<ApiResponse<Agent>> {\n    return this.request('POST', '/agents', agentData)\n  }\n\n  async updateAgent(id: string, updates: Partial<Agent>): Promise<ApiResponse<Agent>> {\n    return this.request('PUT', `/agents/${id}`, updates)\n  }\n\n  async deleteAgent(id: string): Promise<ApiResponse<void>> {\n    return this.request('DELETE', `/agents/${id}`)\n  }\n\n  // Workspace methods\n  async getWorkspaces(): Promise<ApiResponse<Workspace[]>> {\n    return this.request('GET', '/workspaces')\n  }\n\n  async getWorkspace(id: string): Promise<ApiResponse<Workspace>> {\n    return this.request('GET', `/workspaces/${id}`)\n  }\n\n  async createWorkspace(data: Omit<Workspace, 'id' | 'createdAt' | 'updatedAt'>): Promise<ApiResponse<Workspace>> {\n    return this.request('POST', '/workspaces', data)\n  }\n\n  async updateWorkspace(id: string, updates: Partial<Workspace>): Promise<ApiResponse<Workspace>> {\n    return this.request('PUT', `/workspaces/${id}`, updates)\n  }\n\n  async deleteWorkspace(id: string): Promise<ApiResponse<void>> {\n    return this.request('DELETE', `/workspaces/${id}`)\n  }\n\n  // Plugin methods\n  async getPlugins(): Promise<ApiResponse<Plugin[]>> {\n    return this.request('GET', '/plugins')\n  }\n\n  async installPlugin(pluginId: string): Promise<ApiResponse<Plugin>> {\n    return this.request('POST', `/plugins/${pluginId}/install`)\n  }\n\n  async uninstallPlugin(pluginId: string): Promise<ApiResponse<void>> {\n    return this.request('DELETE', `/plugins/${pluginId}`)\n  }\n\n  async updatePluginSettings(pluginId: string, settings: Record<string, unknown>): Promise<ApiResponse<Plugin>> {\n    return this.request('PUT', `/plugins/${pluginId}/settings`, { settings })\n  }\n\n  // Notifications methods\n  async getNotifications(): Promise<ApiResponse<Notification[]>> {\n    return this.request('GET', '/notifications')\n  }\n\n  async markNotificationAsRead(id: string): Promise<ApiResponse<void>> {\n    return this.request('PUT', `/notifications/${id}/read`)\n  }\n\n  async deleteNotification(id: string): Promise<ApiResponse<void>> {\n    return this.request('DELETE', `/notifications/${id}`)\n  }\n\n  // Health and Metrics methods\n  async getHealthStatus(): Promise<ApiResponse<HealthStatus>> {\n    const response = await this.request<HealthStatus>('GET', '/health')\n    // Normalize to ApiResponse shape if backend omitted success\n    if (response && typeof (response as any).success === 'undefined') {\n      return { success: true, data: response as unknown as HealthStatus }\n    }\n    return response\n  }\n\n  async getMetrics(): Promise<ApiResponse<MetricsData>> {\n    return this.request('GET', '/metrics')\n  }\n\n  // File upload methods\n  async uploadFile(file: File, conversationId?: string, onProgress?: (progress: number) => void): Promise<ApiResponse<FileUploadResult>> {\n    const formData = new FormData()\n    formData.append('file', file)\n    if (conversationId) {\n      formData.append('conversationId', conversationId)\n    }\n\n    const config: AxiosRequestConfig = {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    }\n\n    if (onProgress) {\n      config.onUploadProgress = (progressEvent) => {\n        if (progressEvent.total) {\n          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total)\n          onProgress(progress)\n        }\n      }\n    }\n\n    return this.request('POST', '/upload', formData, config)\n  }\n\n  async uploadMultipleFiles(files: File[], conversationId?: string, onProgress?: (progress: number) => void): Promise<ApiResponse<Array<{ url: string; metadata: unknown }>>> {\n    const formData = new FormData()\n    files.forEach((file, index) => {\n      formData.append(`files[${index}]`, file)\n    })\n    if (conversationId) {\n      formData.append('conversationId', conversationId)\n    }\n\n    const config: AxiosRequestConfig = {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    }\n\n    if (onProgress) {\n      config.onUploadProgress = (progressEvent) => {\n        if (progressEvent.total) {\n          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total)\n          onProgress(progress)\n        }\n      }\n    }\n\n    return this.request('POST', '/upload/multiple', formData, config)\n  }\n\n  // Voice methods\n  async transcribeAudio(audioFile: File): Promise<ApiResponse<{ text: string; confidence: number }>> {\n    const formData = new FormData()\n    formData.append('audio', audioFile)\n\n    return this.request('POST', '/voice/transcribe', formData, {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    })\n  }\n\n  async generateSpeech(text: string, voiceSettings?: VoiceSettings): Promise<ApiResponse<{ audioUrl: string }>> {\n    return this.request('POST', '/voice/speak', { text, voiceSettings })\n  }\n\n  // Search methods\n  async search(params: {\n    q: string\n    types?: string[]\n    dateRange?: string\n    sortBy?: string\n    limit?: number\n    offset?: number\n  }): Promise<unknown> {\n    const response = await this.client.get('/api/search', { params })\n    return response.data\n  }\n\n  async searchGlobal(query: string, filters?: SearchFilters): Promise<unknown> {\n    const params = { q: query, ...filters }\n    return this.search(params)\n  }\n\n  // Settings methods\n  async getSettings(): Promise<unknown> {\n    const response = await this.client.get('/api/settings')\n    return response.data\n  }\n\n  async updateSettings(settings: Partial<unknown>): Promise<unknown> {\n    const response = await this.client.put('/api/settings', settings)\n    return response.data\n  }\n\n  // File methods\n  async deleteFile(fileId: string): Promise<void> {\n    await this.client.delete(`/api/files/${fileId}`)\n  }\n\n  async getFiles(params?: { limit?: number; offset?: number }): Promise<unknown> {\n    const response = await this.client.get('/api/files', { params })\n    return response.data\n  }\n\n  // Generic HTTP methods for compatibility\n  async post(endpoint: string, data?: unknown, config?: AxiosRequestConfig): Promise<unknown> {\n    const response = await this.client.post(endpoint, data, config)\n    return response.data\n  }\n\n  async put(endpoint: string, data?: unknown, config?: AxiosRequestConfig): Promise<unknown> {\n    const response = await this.client.put(endpoint, data, config)\n    return response.data\n  }\n\n  async patch(endpoint: string, data?: unknown, config?: AxiosRequestConfig): Promise<unknown> {\n    const response = await this.client.patch(endpoint, data, config)\n    return response.data\n  }\n}\n\n// Export singleton instance\nexport const apiClient = CartritaApiClient.createInstance()\n\n// Export types\nexport type { ApiResponse, User, Conversation, Message, Agent, ChatRequest, ChatResponse }"
  },
  {
    "file_path": "frontend/src/hooks/useVoice.ts",
    "modifications": [
      {
        "line": 76,
        "original": "const apiKey = process.env.NEXT_PUBLIC_DEEPGRAM_API_KEY || process.env.DEEPGRAM_API_KEY || ''",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Cartrita AI OS - Voice Hook Integration\n// Real implementation with advanced voice capabilities\n\nimport { useState, useEffect, useCallback, useRef } from 'react'\nimport DeepgramVoiceService, { \n  VoiceState, \n  VoiceTranscription, \n  VoiceAnalytics, \n  ConversationMetrics,\n  DeepgramConfig \n} from '@/services/deepgram'\n\nexport interface UseVoiceOptions extends Partial<DeepgramConfig> {\n  autoStart?: boolean\n  enableAnalytics?: boolean\n  enableMetrics?: boolean\n  onTranscription?: (transcription: VoiceTranscription) => void\n  onResponse?: (response: string) => void\n  onError?: (error: unknown) => void\n}\n\nexport interface VoiceCapabilities {\n  // Core voice functions\n  startRecording: () => Promise<void>\n  stopRecording: () => Promise<void>\n  speak: (text: string) => Promise<void>\n  \n  // Voice Agent functions\n  startVoiceAgent: (systemPrompt?: string) => Promise<void>\n  stopVoiceAgent: () => void\n  sendVoiceMessage: (audioBlob: Blob) => Promise<void>\n  \n  // State management\n  voiceState: VoiceState\n  isRecording: boolean\n  isProcessing: boolean\n  isSpeaking: boolean\n  \n  // Transcription and analytics\n  currentTranscription: string\n  finalTranscription: string\n  analytics: VoiceAnalytics | null\n  metrics: ConversationMetrics | null\n  \n  // Voice quality metrics\n  audioLevel: number\n  signalQuality: 'excellent' | 'good' | 'fair' | 'poor'\n  \n  // Configuration\n  updateConfig: (config: Partial<DeepgramConfig>) => void\n  \n  // Utility functions\n  toggleRecording: () => Promise<void>\n  clearTranscriptions: () => void\n  getRecordingDuration: () => number\n}\n\nexport function useVoice(options: UseVoiceOptions = {}): VoiceCapabilities {\n  // State management\n  const [voiceState, setVoiceState] = useState<VoiceState>('idle')\n  const [currentTranscription, setCurrentTranscription] = useState('')\n  const [finalTranscription, setFinalTranscription] = useState('')\n  const [analytics, setAnalytics] = useState<VoiceAnalytics | null>(null)\n  const [metrics, setMetrics] = useState<ConversationMetrics | null>(null)\n  const [audioLevel, setAudioLevel] = useState(0)\n  const [signalQuality, setSignalQuality] = useState<'excellent' | 'good' | 'fair' | 'poor'>('good')\n\n  // Refs\n  const voiceServiceRef = useRef<DeepgramVoiceService | null>(null)\n  const voiceAgentWsRef = useRef<WebSocket | null>(null)\n  const recordingStartTimeRef = useRef<number | null>(null)\n  const audioAnalyzerRef = useRef<AnalyserNode | null>(null)\n  const animationFrameRef = useRef<number | null>(null)\n\n  // Get API key from environment\nconst apiKey = process.env.CONST APIKEY || \"\";\n\n  // Initialize voice service\n  useEffect(() => {\n    if (!apiKey) {\n      console.error('Deepgram API key is required')\n      return\n    }\n\n    const config: DeepgramConfig = {\n      apiKey,\n      model: options.model || 'nova-2',\n      language: options.language || 'en-US',\n      smartFormat: options.smartFormat ?? true,\n      punctuate: options.punctuate ?? true,\n      interim_results: options.interim_results ?? true,\n      endpointing: options.endpointing || 300\n    }\n\n    voiceServiceRef.current = new DeepgramVoiceService(config)\n\n    // Setup event listeners\n    voiceServiceRef.current.on('stateChange', ({ state }: { state: VoiceState }) => {\n      setVoiceState(state)\n    })\n\n    voiceServiceRef.current.on('transcription', (transcription: VoiceTranscription) => {\n      if (transcription.is_final) {\n        setFinalTranscription(prev => prev + ' ' + transcription.text)\n        setCurrentTranscription('')\n        options.onTranscription?.(transcription)\n      } else {\n        setCurrentTranscription(transcription.text)\n      }\n    })\n\n    voiceServiceRef.current.on('analytics', (analytics: VoiceAnalytics) => {\n      if (options.enableAnalytics) {\n        setAnalytics(analytics)\n      }\n    })\n\n    voiceServiceRef.current.on('metrics', (metrics: Partial<ConversationMetrics>) => {\n      if (options.enableMetrics) {\n        setMetrics(prev => ({ ...prev, ...metrics } as ConversationMetrics))\n      }\n    })\n\n    voiceServiceRef.current.on('response', (response: string) => {\n      options.onResponse?.(response)\n    })\n\n    voiceServiceRef.current.on('error', (error: unknown) => {\n      console.error('Voice service error:', error)\n      options.onError?.(error)\n    })\n\n    // Cleanup on unmount\n    return () => {\n      if (voiceServiceRef.current) {\n        voiceServiceRef.current.disconnect()\n      }\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current)\n      }\n    }\n  }, [apiKey, options])\n\n  // Audio level monitoring\n  const setupAudioLevelMonitoring = useCallback((stream: MediaStream) => {\n    const audioContext = new AudioContext()\n    const source = audioContext.createMediaStreamSource(stream)\n    const analyzer = audioContext.createAnalyser()\n    \n    analyzer.fftSize = 256\n    source.connect(analyzer)\n    audioAnalyzerRef.current = analyzer\n\n    const dataArray = new Uint8Array(analyzer.frequencyBinCount)\n\n    const updateAudioLevel = () => {\n      if (audioAnalyzerRef.current) {\n        audioAnalyzerRef.current.getByteFrequencyData(dataArray)\n        \n        // Calculate average audio level\n        const average = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length\n        setAudioLevel(average)\n\n        // Determine signal quality based on audio level and consistency\n        if (average > 80) {\n          setSignalQuality('excellent')\n        } else if (average > 50) {\n          setSignalQuality('good')\n        } else if (average > 20) {\n          setSignalQuality('fair')\n        } else {\n          setSignalQuality('poor')\n        }\n      }\n\n      if (voiceState === 'recording') {\n        animationFrameRef.current = requestAnimationFrame(updateAudioLevel)\n      }\n    }\n\n    updateAudioLevel()\n  }, [voiceState])\n\n  // Core voice functions\n  const startRecording = useCallback(async () => {\n    try {\n      if (!voiceServiceRef.current) {\n        throw new Error('Voice service not initialized')\n      }\n\n      recordingStartTimeRef.current = Date.now()\n      await voiceServiceRef.current.startVoiceRecording()\n\n      // Setup audio level monitoring\n      if (voiceServiceRef.current.isCurrentlyRecording()) {\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true })\n        setupAudioLevelMonitoring(stream)\n      }\n    } catch (error) {\n      console.error('Failed to start recording:', error)\n      throw error\n    }\n  }, [setupAudioLevelMonitoring])\n\n  const stopRecording = useCallback(async () => {\n    try {\n      if (voiceServiceRef.current) {\n        await voiceServiceRef.current.stopVoiceRecording()\n      }\n      \n      recordingStartTimeRef.current = null\n      \n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current)\n        animationFrameRef.current = null\n      }\n    } catch (error) {\n      console.error('Failed to stop recording:', error)\n      throw error\n    }\n  }, [])\n\n  const speak = useCallback(async (text: string) => {\n    try {\n      if (!voiceServiceRef.current) {\n        throw new Error('Voice service not initialized')\n      }\n\n      await voiceServiceRef.current.synthesizeSpeech(text)\n    } catch (error) {\n      console.error('Failed to speak:', error)\n      throw error\n    }\n  }, [])\n\n  // Voice Agent functions\n  const startVoiceAgent = useCallback(async (systemPrompt?: string) => {\n    try {\n      if (!voiceServiceRef.current) {\n        throw new Error('Voice service not initialized')\n      }\n\n      const voiceAgentWs = await voiceServiceRef.current.startVoiceAgent({\n        instructions: systemPrompt || 'You are a helpful AI assistant with natural conversation abilities.',\n        maxTokens: 2000,\n  voice: 'aura-asteria-en',\n        thinkModel: 'gpt-4o-mini',\n  listenModel: 'nova-3'\n      })\n\n      voiceAgentWsRef.current = voiceAgentWs\n      recordingStartTimeRef.current = Date.now()\n    } catch (error) {\n      console.error('Failed to start voice agent:', error)\n      throw error\n    }\n  }, [])\n\n  const stopVoiceAgent = useCallback(() => {\n    if (voiceAgentWsRef.current) {\n      voiceAgentWsRef.current.close()\n      voiceAgentWsRef.current = null\n    }\n    recordingStartTimeRef.current = null\n  }, [])\n\n  const sendVoiceMessage = useCallback(async (audioBlob: Blob) => {\n    try {\n      if (!voiceAgentWsRef.current) {\n        throw new Error('Voice agent not connected')\n      }\n\n      // Convert audio blob to base64 and send\n      const arrayBuffer = await audioBlob.arrayBuffer()\n      const base64Audio = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)))\n      \n      voiceAgentWsRef.current.send(JSON.stringify({\n        type: 'audio',\n        audio: base64Audio,\n        encoding: 'webm'\n      }))\n    } catch (error) {\n      console.error('Failed to send voice message:', error)\n      throw error\n    }\n  }, [])\n\n  // Utility functions\n  const toggleRecording = useCallback(async () => {\n    if (voiceState === 'recording') {\n      await stopRecording()\n    } else if (voiceState === 'idle') {\n      await startRecording()\n    }\n  }, [voiceState, startRecording, stopRecording])\n\n  const clearTranscriptions = useCallback(() => {\n    setCurrentTranscription('')\n    setFinalTranscription('')\n  }, [])\n\n  const getRecordingDuration = useCallback(() => {\n    if (recordingStartTimeRef.current) {\n      return Date.now() - recordingStartTimeRef.current\n    }\n    return 0\n  }, [])\n\n  const updateConfig = useCallback((config: Partial<DeepgramConfig>) => {\n    // This would reinitialize the service with new config\n    // For now, we'll just log the config change\n    console.log('Voice config updated:', config)\n  }, [])\n\n  // Computed values\n  const isRecording = voiceState === 'recording'\n  const isProcessing = voiceState === 'processing'\n  const isSpeaking = voiceState === 'speaking'\n\n  return {\n    // Core voice functions\n    startRecording,\n    stopRecording,\n    speak,\n    \n    // Voice Agent functions\n    startVoiceAgent,\n    stopVoiceAgent,\n    sendVoiceMessage,\n    \n    // State management\n    voiceState,\n    isRecording,\n    isProcessing,\n    isSpeaking,\n    \n    // Transcription and analytics\n    currentTranscription,\n    finalTranscription,\n    analytics,\n    metrics,\n    \n    // Voice quality metrics\n    audioLevel,\n    signalQuality,\n    \n    // Configuration\n    updateConfig,\n    \n    // Utility functions\n    toggleRecording,\n    clearTranscriptions,\n    getRecordingDuration\n  }\n}"
  },
  {
    "file_path": "frontend/src/pages/api/conversations.ts",
    "modifications": [
      {
        "line": 10,
        "original": "const apiKey = process.env.DEV_API_KEY || 'fallback-dev-api-key'",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Next.js API Route - Conversations API\n// Handles conversation management\n\nimport type { NextApiRequest, NextApiResponse } from 'next'\nimport type { ApiResponse, Conversation } from '@/types'\nimport { createApiResponse, handleApiError } from '@/utils'\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\nconst apiKey = process.env.CONST APIKEY || \"\";\n\n    if (req.method === 'GET') {\n      // Get conversations list\n      const conversations: Conversation[] = [\n        {\n          id: 'default-conversation',\n          title: 'New Chat',\n          messages: [],\n          agentId: 'supervisor',\n          workspaceId: undefined,\n          userId: 'default-user',\n          isArchived: false,\n          isPinned: false,\n          tags: [],\n          metadata: {\n          totalMessages: 0,\n          lastActivity: new Date().toISOString(),\n          agentUsed: 'supervisor',\n          tokensUsed: 0,\n          processingTime: 0\n        },\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          lastMessageAt: new Date().toISOString()\n        }\n      ]\n\n      const response: ApiResponse<Conversation[]> = createApiResponse(true, conversations, undefined, 'Conversations retrieved successfully')\n      res.status(200).json(response)\n    } else if (req.method === 'POST') {\n      // Create new conversation\n      const { title, agentId, workspaceId, initialMessage } = req.body\n\n      const newConversation: Conversation = {\n        id: `conversation-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n        title: title || 'New Chat',\n        messages: [],\n        agentId: agentId || 'supervisor',\n        workspaceId,\n        userId: 'default-user',\n        isArchived: false,\n        isPinned: false,\n        tags: [],\n        metadata: {\n          totalMessages: 0,\n          lastActivity: new Date().toISOString(),\n          agentUsed: agentId || 'supervisor',\n          tokensUsed: 0,\n          processingTime: 0\n        },\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        lastMessageAt: new Date().toISOString()\n      }\n\n      const response: ApiResponse<Conversation> = createApiResponse(true, newConversation, undefined, 'Conversation created successfully')\n      res.status(201).json(response)\n    } else {\n      res.setHeader('Allow', ['GET', 'POST'])\n      res.status(405).json(handleApiError(new Error('Method not allowed')))\n    }\n  } catch (error) {\n    console.error('Conversations API error:', error)\n    res.status(500).json(handleApiError(error as Error))\n  }\n}"
  },
  {
    "file_path": "frontend/src/pages/api/upload/multiple.ts",
    "modifications": [
      {
        "line": 11,
        "original": "const apiKey = process.env.BACKEND_API_KEY || process.env.AI_API_KEY || ''",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Next.js API Route - Multiple File Upload Proxy\n// Proxies POST /api/upload/multiple\n\nimport type { NextApiRequest, NextApiResponse } from 'next'\nimport httpProxy from 'http-proxy'\n\nconst proxy = httpProxy.createProxyServer()\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  return new Promise<void>((resolve, reject) => {\nconst apiKey = process.env.CONST APIKEY || \"\";\n    if (apiKey) {\n      req.headers['x-api-key'] = apiKey\n      req.headers['authorization'] = `Bearer ${apiKey}`\n    }\n\n    res.setHeader('Access-Control-Allow-Origin', '*')\n    res.setHeader('Access-Control-Allow-Methods', 'POST,OPTIONS')\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-API-Key, Authorization')\n\n    if (req.method === 'OPTIONS') {\n      res.status(200).end()\n      resolve()\n      return\n    }\n\n    if (req.method !== 'POST') {\n      res.status(405).json({ error: 'Method Not Allowed' })\n      resolve()\n      return\n    }\n\n    proxy.web(\n      req,\n      res,\n      {\n        target: process.env.BACKEND_BASE_URL || 'http://localhost:8000',\n        changeOrigin: true,\n        selfHandleResponse: false,\n        timeout: 70000,\n      },\n      (err: any) => {\n        console.error('Proxy error:', err)\n        if (err.code === 'ECONNREFUSED' || err.code === 'ENOTFOUND') {\n          res.status(503).json({ error: 'Backend unavailable', details: 'AI service is not running. Please start the backend services.', code: 'BACKEND_DOWN' })\n        } else {\n          res.status(500).json({ error: 'Proxy failed', details: err.message, code: err.code || 'PROXY_ERROR' })\n        }\n        reject(err)\n      }\n    )\n  })\n}\n\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true,\n  },\n}"
  },
  {
    "file_path": "frontend/src/pages/api/upload/index.ts",
    "modifications": [
      {
        "line": 11,
        "original": "const apiKey = process.env.BACKEND_API_KEY || process.env.AI_API_KEY || ''",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Next.js API Route - Single File Upload Proxy\n// Proxies POST /api/upload\n\nimport type { NextApiRequest, NextApiResponse } from 'next'\nimport httpProxy from 'http-proxy'\n\nconst proxy = httpProxy.createProxyServer()\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  return new Promise<void>((resolve, reject) => {\nconst apiKey = process.env.CONST APIKEY || \"\";\n    if (apiKey) {\n      req.headers['x-api-key'] = apiKey\n      req.headers['authorization'] = `Bearer ${apiKey}`\n    }\n\n    res.setHeader('Access-Control-Allow-Origin', '*')\n    res.setHeader('Access-Control-Allow-Methods', 'POST,OPTIONS')\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-API-Key, Authorization')\n\n    if (req.method === 'OPTIONS') {\n      res.status(200).end()\n      resolve()\n      return\n    }\n\n    if (req.method !== 'POST') {\n      res.status(405).json({ error: 'Method Not Allowed' })\n      resolve()\n      return\n    }\n\n    proxy.web(\n      req,\n      res,\n      {\n        target: process.env.BACKEND_BASE_URL || 'http://localhost:8000',\n        changeOrigin: true,\n        selfHandleResponse: false,\n        timeout: 35000,\n      },\n      (err: any) => {\n        console.error('Proxy error:', err)\n        if (err.code === 'ECONNREFUSED' || err.code === 'ENOTFOUND') {\n          res.status(503).json({ error: 'Backend unavailable', details: 'AI service is not running. Please start the backend services.', code: 'BACKEND_DOWN' })\n        } else {\n          res.status(500).json({ error: 'Proxy failed', details: err.message, code: err.code || 'PROXY_ERROR' })\n        }\n        reject(err)\n      }\n    )\n  })\n}\n\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true,\n  },\n}"
  },
  {
    "file_path": "frontend/src/pages/api/voice/speak.ts",
    "modifications": [
      {
        "line": 11,
        "original": "const apiKey = process.env.BACKEND_API_KEY || process.env.AI_API_KEY || ''",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Next.js API Route - Voice Synthesis Proxy\n// Proxies POST /api/voice/speak\n\nimport type { NextApiRequest, NextApiResponse } from 'next'\nimport httpProxy from 'http-proxy'\n\nconst proxy = httpProxy.createProxyServer()\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  return new Promise<void>((resolve, reject) => {\nconst apiKey = process.env.CONST APIKEY || \"\";\n    if (apiKey) {\n      req.headers['x-api-key'] = apiKey\n      req.headers['authorization'] = `Bearer ${apiKey}`\n    }\n\n    res.setHeader('Access-Control-Allow-Origin', '*')\n    res.setHeader('Access-Control-Allow-Methods', 'POST,OPTIONS')\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-API-Key, Authorization')\n\n    if (req.method === 'OPTIONS') {\n      res.status(200).end()\n      resolve()\n      return\n    }\n\n    if (req.method !== 'POST') {\n      res.status(405).json({ error: 'Method Not Allowed' })\n      resolve()\n      return\n    }\n\n    proxy.web(\n      req,\n      res,\n      {\n        target: process.env.BACKEND_BASE_URL || 'http://localhost:8000',\n        changeOrigin: true,\n        selfHandleResponse: false,\n        timeout: 35000,\n      },\n      (err: any) => {\n        console.error('Proxy error:', err)\n        if (err.code === 'ECONNREFUSED' || err.code === 'ENOTFOUND') {\n          res.status(503).json({ error: 'Backend unavailable', details: 'AI service is not running. Please start the backend services.', code: 'BACKEND_DOWN' })\n        } else {\n          res.status(500).json({ error: 'Proxy failed', details: err.message, code: err.code || 'PROXY_ERROR' })\n        }\n        reject(err)\n      }\n    )\n  })\n}\n\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true,\n  },\n}"
  },
  {
    "file_path": "frontend/src/pages/api/voice/transcribe.ts",
    "modifications": [
      {
        "line": 11,
        "original": "const apiKey = process.env.BACKEND_API_KEY || process.env.AI_API_KEY || ''",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Next.js API Route - Voice Transcription Proxy\n// Proxies POST /api/voice/transcribe\n\nimport type { NextApiRequest, NextApiResponse } from 'next'\nimport httpProxy from 'http-proxy'\n\nconst proxy = httpProxy.createProxyServer()\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  return new Promise<void>((resolve, reject) => {\nconst apiKey = process.env.CONST APIKEY || \"\";\n    if (apiKey) {\n      req.headers['x-api-key'] = apiKey\n      req.headers['authorization'] = `Bearer ${apiKey}`\n    }\n\n    res.setHeader('Access-Control-Allow-Origin', '*')\n    res.setHeader('Access-Control-Allow-Methods', 'POST,OPTIONS')\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-API-Key, Authorization')\n\n    if (req.method === 'OPTIONS') {\n      res.status(200).end()\n      resolve()\n      return\n    }\n\n    if (req.method !== 'POST') {\n      res.status(405).json({ error: 'Method Not Allowed' })\n      resolve()\n      return\n    }\n\n    proxy.web(\n      req,\n      res,\n      {\n        target: process.env.BACKEND_BASE_URL || 'http://localhost:8000',\n        changeOrigin: true,\n        selfHandleResponse: false,\n        timeout: 35000,\n      },\n      (err: any) => {\n        console.error('Proxy error:', err)\n        if (err.code === 'ECONNREFUSED' || err.code === 'ENOTFOUND') {\n          res.status(503).json({ error: 'Backend unavailable', details: 'AI service is not running. Please start the backend services.', code: 'BACKEND_DOWN' })\n        } else {\n          res.status(500).json({ error: 'Proxy failed', details: err.message, code: err.code || 'PROXY_ERROR' })\n        }\n        reject(err)\n      }\n    )\n  })\n}\n\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true,\n  },\n}"
  },
  {
    "file_path": "frontend/src/pages/api/chat/stream.ts",
    "modifications": [
      {
        "line": 13,
        "original": "const apiKey = process.env.BACKEND_API_KEY || process.env.AI_API_KEY || 'dev-api-key-2025'",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Next.js API Route - Chat Streaming Proxy\n// Handles authentication and proxies requests to backend\n\nimport type { NextApiRequest, NextApiResponse } from 'next'\nimport httpProxy from 'http-proxy'\n\n// Create the proxy server\nconst proxy = httpProxy.createProxyServer()\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  return new Promise<void>((resolve, reject) => {\n    // Add API key to request headers from environment (EventSource cannot send headers; proxy injects)\nconst apiKey = process.env.CONST APIKEY || \"\";\n    if (apiKey) {\n      req.headers['x-api-key'] = apiKey\n      req.headers['authorization'] = `Bearer ${apiKey}`\n    }\n    \n    // Set CORS headers\n    res.setHeader('Access-Control-Allow-Origin', '*')\n    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS')\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type')\n    \n    if (req.method === 'OPTIONS') {\n      res.status(200).end()\n      resolve()\n      return\n    }\n\n    proxy.web(req, res, {\n      target: process.env.BACKEND_BASE_URL || 'http://localhost:8000',\n      changeOrigin: true,\n      selfHandleResponse: false,\n      timeout: 35000\n    }, (err) => {\n      if (err) {\n        console.error('Proxy error:', err)\n        \n        // Check if it's a connection error (backend not running)\n        if ((err as any).code === 'ECONNREFUSED' || (err as any).code === 'ENOTFOUND') {\n          res.status(503).json({ \n            error: 'Backend unavailable', \n            details: 'AI service is not running. Please start the backend services.',\n            code: 'BACKEND_DOWN'\n          })\n        } else {\n          res.status(500).json({ \n            error: 'Proxy failed', \n            details: err.message,\n            code: (err as any).code || 'PROXY_ERROR'\n          })\n        }\n        reject(err)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\n\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true,\n  },\n}"
  },
  {
    "file_path": "frontend/src/pages/api/chat/index.ts",
    "modifications": [
      {
        "line": 12,
        "original": "const apiKey = process.env.BACKEND_API_KEY || process.env.AI_API_KEY || 'dev-api-key-2025'",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Next.js API Route - Chat POST Proxy\n// Proxies POST /api/chat to backend with auth headers and CORS\n\nimport type { NextApiRequest, NextApiResponse } from 'next'\nimport httpProxy from 'http-proxy'\n\nconst proxy = httpProxy.createProxyServer()\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  return new Promise<void>((resolve, reject) => {\n    // Inject API key headers from environment\nconst apiKey = process.env.CONST APIKEY || \"\";\n    if (apiKey) {\n      req.headers['x-api-key'] = apiKey\n      req.headers['authorization'] = `Bearer ${apiKey}`\n    }\n\n    // CORS\n    res.setHeader('Access-Control-Allow-Origin', '*')\n    res.setHeader('Access-Control-Allow-Methods', 'POST,OPTIONS')\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-API-Key, Authorization')\n\n    if (req.method === 'OPTIONS') {\n      res.status(200).end()\n      resolve()\n      return\n    }\n\n  proxy.web(\n      req,\n      res,\n      {\n    target: process.env.BACKEND_BASE_URL || 'http://localhost:8000',\n        changeOrigin: true,\n        selfHandleResponse: false,\n        timeout: 35000,\n      },\n      (err: any) => {\n        console.error('Proxy error:', err)\n        if (err.code === 'ECONNREFUSED' || err.code === 'ENOTFOUND') {\n          res.status(503).json({\n            error: 'Backend unavailable',\n            details: 'AI service is not running. Please start the backend services.',\n            code: 'BACKEND_DOWN',\n          })\n        } else {\n          res.status(500).json({ error: 'Proxy failed', details: err.message, code: err.code || 'PROXY_ERROR' })\n        }\n        reject(err)\n      }\n    )\n  })\n}\n\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true,\n  },\n}"
  },
  {
    "file_path": "frontend/src/pages/api/chat/voice/stream.ts",
    "modifications": [
      {
        "line": 11,
        "original": "const apiKey = process.env.BACKEND_API_KEY || process.env.AI_API_KEY || ''",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Next.js API Route - Voice Chat Streaming Proxy\n// Proxies GET /api/chat/voice/stream\n\nimport type { NextApiRequest, NextApiResponse } from 'next'\nimport httpProxy from 'http-proxy'\n\nconst proxy = httpProxy.createProxyServer()\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  return new Promise<void>((resolve, reject) => {\nconst apiKey = process.env.CONST APIKEY || \"\";\n    if (apiKey) {\n      req.headers['x-api-key'] = apiKey\n      req.headers['authorization'] = `Bearer ${apiKey}`\n    }\n\n    res.setHeader('Access-Control-Allow-Origin', '*')\n    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS')\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-API-Key, Authorization')\n\n    if (req.method === 'OPTIONS') {\n      res.status(200).end()\n      resolve()\n      return\n    }\n\n    proxy.web(\n      req,\n      res,\n      {\n        target: process.env.BACKEND_BASE_URL || 'http://localhost:8000',\n        changeOrigin: true,\n        selfHandleResponse: false,\n        timeout: 35000,\n      },\n      (err: any) => {\n        console.error('Proxy error:', err)\n        if (err.code === 'ECONNREFUSED' || err.code === 'ENOTFOUND') {\n          res.status(503).json({ error: 'Backend unavailable', details: 'AI service is not running. Please start the backend services.', code: 'BACKEND_DOWN' })\n        } else {\n          res.status(500).json({ error: 'Proxy failed', details: err.message, code: err.code || 'PROXY_ERROR' })\n        }\n        reject(err)\n      }\n    )\n  })\n}\n\nexport const config = {\n  api: {\n    bodyParser: false,\n    externalResolver: true,\n  },\n}"
  },
  {
    "file_path": "frontend/src/components/AppInitializer.tsx",
    "modifications": [
      {
        "line": 194,
        "original": "const devToken = process.env.NEXT_PUBLIC_CARTRITA_API_KEY || 'dev-api-key-2025'",
        "modified": "const devToken = process.env.CONST DEVTOKEN || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Cartrita AI OS - App Initializer\n// Handles initial state setup and data loading\n\nimport { useEffect } from 'react'\nimport { useSetAtom } from 'jotai'\nimport {\n  agentsAtom,\n  selectedAgentIdAtom,\n  conversationsAtom,\n  userAtom,\n  authTokenAtom\n} from '@/stores'\nimport { apiClient } from '@/services/api'\nimport type { Agent } from '@/types'\n\nconst defaultAgents: Agent[] = [\n  {\n    id: 'supervisor',\n    name: 'Cartrita Supervisor',\n    type: 'supervisor',\n    status: 'idle',\n    model: 'gpt-4',\n    description: 'Intelligent task orchestrator with multi-agent delegation capabilities',\n    capabilities: ['task_planning', 'agent_orchestration', 'decision_making', 'context_management'],\n    last_used_at: new Date().toISOString(),\n    usage_count: 0,\n    metadata: {\n      version: '2.0',\n      uptime: 0,\n      memory_usage: 0,\n      queue_size: 0,\n      totalRequests: 0,\n      successRate: 1.0,\n      avgLatency: 0,\n      lastActive: new Date().toISOString()\n    }\n  },\n  {\n    id: 'research',\n    name: 'Research Agent',\n    type: 'research',\n    status: 'idle',\n    model: 'gpt-4',\n    description: 'Advanced web search and information synthesis specialist',\n    capabilities: ['web_search', 'data_analysis', 'information_synthesis', 'fact_checking'],\n    last_used_at: new Date().toISOString(),\n    usage_count: 0,\n    metadata: {\n      version: '2.0',\n      uptime: 0,\n      memory_usage: 0,\n      queue_size: 0,\n      totalRequests: 0,\n      successRate: 1.0,\n      avgLatency: 0,\n      lastActive: new Date().toISOString()\n    }\n  },\n  {\n    id: 'code',\n    name: 'Code Agent',\n    type: 'code',\n    status: 'idle',\n    model: 'gpt-4',\n    description: 'Software development and programming expert',\n    capabilities: ['code_generation', 'debugging', 'code_review', 'architecture_design'],\n    last_used_at: new Date().toISOString(),\n    usage_count: 0,\n    metadata: {\n      version: '2.0',\n      uptime: 0,\n      memory_usage: 0,\n      queue_size: 0,\n      totalRequests: 0,\n      successRate: 1.0,\n      avgLatency: 0,\n      lastActive: new Date().toISOString()\n    }\n  },\n  {\n    id: 'computer_use',\n    name: 'Computer Use Agent',\n    type: 'computer_use',\n    status: 'idle',\n  model: 'gpt-4o-mini',\n    description: 'System interaction and automation specialist',\n    capabilities: ['computer_control', 'file_management', 'system_automation', 'tool_usage'],\n    last_used_at: new Date().toISOString(),\n    usage_count: 0,\n    metadata: {\n      version: '2.0',\n      uptime: 0,\n      memory_usage: 0,\n      queue_size: 0,\n      totalRequests: 0,\n      successRate: 1.0,\n      avgLatency: 0,\n      lastActive: new Date().toISOString()\n    }\n  },\n  {\n    id: 'knowledge',\n    name: 'Knowledge Agent',\n    type: 'knowledge',\n    status: 'idle',\n    model: 'gpt-4',\n    description: 'Document analysis and knowledge base specialist',\n    capabilities: ['document_analysis', 'knowledge_extraction', 'rag_search', 'content_generation'],\n    last_used_at: new Date().toISOString(),\n    usage_count: 0,\n    metadata: {\n      version: '2.0',\n      uptime: 0,\n      memory_usage: 0,\n      queue_size: 0,\n      totalRequests: 0,\n      successRate: 1.0,\n      avgLatency: 0,\n      lastActive: new Date().toISOString()\n    }\n  },\n  {\n    id: 'task',\n    name: 'Task Agent',\n    type: 'task',\n    status: 'idle',\n    model: 'gpt-4',\n    description: 'Project management and task coordination expert',\n    capabilities: ['project_planning', 'task_management', 'progress_tracking', 'coordination'],\n    last_used_at: new Date().toISOString(),\n    usage_count: 0,\n    metadata: {\n      version: '2.0',\n      uptime: 0,\n      memory_usage: 0,\n      queue_size: 0,\n      totalRequests: 0,\n      successRate: 1.0,\n      avgLatency: 0,\n      lastActive: new Date().toISOString()\n    }\n  }\n]\n\nexport default function AppInitializer() {\n  const setAgents = useSetAtom(agentsAtom)\n  const setSelectedAgentId = useSetAtom(selectedAgentIdAtom)\n  const setConversations = useSetAtom(conversationsAtom)\n  const setUser = useSetAtom(userAtom)\n  const setAuthToken = useSetAtom(authTokenAtom)\n\n  useEffect(() => {\n    // Initialize agents immediately\n    setAgents(defaultAgents)\n    setSelectedAgentId('supervisor') // Default to supervisor\n\n    // Set up a development user\n    const devUser = {\n      id: 'dev-user-1',\n      email: 'developer@cartrita.ai',\n      name: 'Developer',\n      preferences: {\n        theme: 'dark' as const,\n        language: 'en',\n        notifications: {\n          email: false,\n          push: false,\n          sound: true,\n          desktop: true\n        },\n        privacy: {\n          dataCollection: false,\n          saveHistory: true,\n          profileVisibility: false,\n          showActivity: false\n        },\n        accessibility: {\n          highContrast: false,\n          reducedMotion: false,\n          fontSize: 'medium' as const,\n          screenReader: false\n        }\n      },\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      isActive: true,\n      role: 'user' as const\n    }\n\n    // Set development user\n    setUser(devUser)\n    \n    // Set a development token from environment variable\nconst devToken = process.env.CONST DEVTOKEN || \"\";\n    setAuthToken(devToken)\n    apiClient.setAuthToken(devToken)\n\n    // Initialize empty conversations\n    setConversations([])\n\n    // Try to fetch real data from the API (if available)\n    const initializeRealData = async () => {\n      try {\n        // Test health endpoint first\n        const health = await apiClient.getHealthStatus()\n        if (health.success) {\n          console.log('API is healthy, loading real data...')\n\n          // Try to load real agents\n          try {\n            const agentsResponse = await apiClient.getAgents()\n            if (agentsResponse.success && agentsResponse.data) {\n              setAgents(agentsResponse.data)\n            }\n          } catch {\n            console.warn('Failed to load agents from API, using defaults')\n          }\n\n          // Try to load conversations\n          try {\n            const conversationsResponse = await apiClient.getConversations()\n            if (conversationsResponse.success && conversationsResponse.data) {\n              setConversations(conversationsResponse.data)\n            }\n          } catch {\n            console.warn('Failed to load conversations from API')\n          }\n        }\n      } catch (error) {\n        console.warn('API not available, using mock data:', error)\n        // Continue with mock data - this is expected in development\n      }\n    }\n\n    // Initialize real data after a brief delay\n    setTimeout(initializeRealData, 1000)\n\n  }, [setAgents, setSelectedAgentId, setConversations, setUser, setAuthToken])\n\n  // This component doesn't render anything\n  return null\n}"
  },
  {
    "file_path": "frontend/src/pages/about.tsx",
    "modifications": [
      {
        "line": 114,
        "original": "const apiKey = process.env.CARTRITA_API_KEY || 'dev-api-key-2025'",
        "modified": "const apiKey = process.env.CONST APIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "import Head from 'next/head'\nimport Link from 'next/link'\nimport type { GetServerSideProps } from 'next'\nimport { motion } from 'framer-motion'\nimport { cartritaBio } from '@/utils/cartritaBio'\nimport SeoHead from '@/components/SeoHead'\nimport type { CartritaBio } from '@/types/CartritaBio'\n\ntype Props = {\n  initialBio?: CartritaBio\n}\n\nexport default function AboutPage({ initialBio }: Props) {\n  const bio = initialBio ?? cartritaBio\n  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL\n  const pageUrl = siteUrl ? `${siteUrl.replace(/\\/$/, '')}/about` : undefined\n  const title = `About \u2022 ${bio.name}`\n  const description = `${bio.name} \u2014 ${bio.title} from ${bio.origin}. ${bio.mission}`\n  return (\n    <>\n      <SeoHead\n        title={title}\n        description={description}\n        url={pageUrl}\n        image=\"/og-about.svg\"\n        imageType=\"image/svg+xml\"\n      />\n      <main className=\"min-h-screen bg-gradient-to-b from-gray-950 via-gray-925 to-gray-900 text-gray-100\">\n        <section className=\"mx-auto max-w-5xl px-6 py-12\">\n          <motion.h1\n            initial={{ y: 12, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ duration: 0.4 }}\n            className=\"text-4xl md:text-5xl font-extrabold tracking-tight bg-gradient-to-r from-yellow-300 via-pink-400 to-purple-400 bg-clip-text text-transparent\"\n          >\n            {bio.name}: {bio.title}\n          </motion.h1>\n          <p className=\"mt-4 text-lg text-gray-300\">\n            {bio.origin} \u2022 {bio.heritage} \u2022 {bio.location}\n          </p>\n          <p className=\"mt-6 text-gray-300 leading-relaxed max-w-3xl\">\n            {bio.mission}\n          </p>\n\n          <div className=\"mt-10 grid grid-cols-1 md:grid-cols-3 gap-6\">\n            <div className=\"rounded-xl border border-white/10 bg-white/5 p-5\">\n              <h2 className=\"font-semibold text-yellow-300\">Values</h2>\n              <ul className=\"mt-3 space-y-2 list-disc list-inside text-gray-200\">\n                {bio.values.map(v => (\n                  <li key={v}>{v}</li>\n                ))}\n              </ul>\n            </div>\n            <div className=\"rounded-xl border border-white/10 bg-white/5 p-5\">\n              <h2 className=\"font-semibold text-pink-300\">Personality</h2>\n              <ul className=\"mt-3 space-y-2 list-disc list-inside text-gray-200\">\n                {bio.personality.map(v => (\n                  <li key={v}>{v}</li>\n                ))}\n              </ul>\n            </div>\n            <div className=\"rounded-xl border border-white/10 bg-white/5 p-5\">\n              <h2 className=\"font-semibold text-purple-300\">Capabilities</h2>\n              <ul className=\"mt-3 space-y-2 list-disc list-inside text-gray-200\">\n                {bio.capabilities.map(v => (\n                  <li key={v}>{v}</li>\n                ))}\n              </ul>\n            </div>\n          </div>\n\n          <div className=\"mt-10 rounded-xl border border-white/10 bg-white/5 p-5\">\n            <h2 className=\"font-semibold\">Agents</h2>\n            <div className=\"mt-4 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4\">\n              {bio.agents.map(a => (\n                <div key={a.id} className=\"rounded-lg bg-black/30 border border-white/10 p-4\">\n                  <div className=\"text-sm text-gray-400\">{a.id}</div>\n                  <div className=\"font-semibold\">{a.name}</div>\n                  <div className=\"text-sm text-gray-300\">{a.role}</div>\n                  <div className=\"text-xs text-gray-400 mt-1\">Model: {a.model}</div>\n                </div>\n              ))}\n            </div>\n          </div>\n\n          <div className=\"mt-10 space-y-8\">\n            {bio.story.map(s => (\n              <article key={s.id} className=\"rounded-xl border border-white/10 bg-white/5 p-6\">\n                <h3 className=\"text-xl md:text-2xl font-bold text-white/95\">{s.title}</h3>\n                <p className=\"mt-2 text-sm text-gray-400\">{s.summary}</p>\n                <p className=\"mt-4 text-gray-200 leading-relaxed\">{s.content}</p>\n              </article>\n            ))}\n          </div>\n\n          <figure className=\"mt-10\">\n            <blockquote className=\"text-lg italic text-gray-200\">{bio.quotes[0]}</blockquote>\n            <figcaption className=\"mt-2 text-sm text-gray-400\">\u2014 {bio.name}</figcaption>\n          </figure>\n\n          <div className=\"mt-12\">\n            <Link href=\"/\" className=\"inline-block rounded-lg bg-gradient-to-r from-yellow-400 to-pink-500 px-5 py-2.5 font-semibold text-black shadow hover:opacity-95 focus:outline-none focus:ring-2 focus:ring-yellow-300\">\n              Back to Home\n            </Link>\n          </div>\n        </section>\n      </main>\n    </>\n  )\n}\n\nexport const getServerSideProps: GetServerSideProps<Props> = async () => {\n  const base = (process.env.BACKEND_BASE_URL || process.env.NEXT_PUBLIC_BACKEND_BASE_URL || 'http://localhost:8000').replace(/\\/$/, '')\nconst apiKey = process.env.CONST APIKEY || \"\";\n\n  try {\n    const res = await fetch(`${base}/api/bio?api_key=${encodeURIComponent(apiKey)}`, {\n      method: 'GET',\n      headers: { Accept: 'application/json' },\n    })\n\n    if (res.ok) {\n      const json = await res.json()\n      const data = json?.data as CartritaBio | undefined\n      if (data && typeof data === 'object' && Array.isArray(data.values)) {\n        return { props: { initialBio: data } }\n      }\n    }\n  } catch {\n    // fall through to local fallback\n  }\n\n  return { props: { initialBio: cartritaBio } }\n}"
  },
  {
    "file_path": "frontend/src/__tests__/hooks/useDeepgramVoice.test.tsx",
    "modifications": [
      {
        "line": 45,
        "original": "const mockApiKey = 'test-deepgram-api-key'",
        "modified": "const mockApiKey = process.env.CONST MOCKAPIKEY || \"\";",
        "reason": "Replaced hardcoded secret with environment variable"
      }
    ],
    "patch_content": "// Cartrita AI OS - Enhanced Deepgram Voice Hook Tests\n// Comprehensive tests for production-ready WebSocket integration\n\n// Mock must be at the very top\nconst mockStartVoiceRecording = vi.fn()\nconst mockStopVoiceRecording = vi.fn()\nconst mockConnect = vi.fn()\n\nvi.mock('@/services/deepgram', () => {\n  class MockDeepgramVoiceService {\n    startVoiceRecording = mockStartVoiceRecording.mockImplementation(() => {\n      console.log('Mock startVoiceRecording called')\n      return Promise.resolve()\n    })\n    stopVoiceRecording = mockStopVoiceRecording.mockImplementation(() => {\n      console.log('Mock stopVoiceRecording called')\n      return Promise.resolve()\n    })\n    connect = mockConnect.mockImplementation(() => {\n      console.log('Mock connect called')\n      return Promise.resolve()\n    })\n    on = vi.fn()\n    emit = vi.fn()\n  }\n\n  return {\n    __esModule: true,\n    default: MockDeepgramVoiceService,\n    DeepgramVoiceService: MockDeepgramVoiceService,\n    VoiceState: {},\n    VoiceTranscription: {},\n    VoiceAnalytics: {},\n    DeepgramConfig: {}\n  }\n})\n\nimport { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'\nimport { renderHook, act, waitFor } from '@testing-library/react'\nimport React from 'react'\n\nimport { useDeepgramVoice } from '@/hooks/useDeepgramVoice'\n\n// Mock environment variables\nconst mockApiKey = process.env.CONST MOCKAPIKEY || \"\";\nvi.stubEnv('NEXT_PUBLIC_DEEPGRAM_API_KEY', mockApiKey)\n\n// Mock MediaDevices\nconst mockGetUserMedia = vi.fn()\nObject.defineProperty(navigator, 'mediaDevices', {\n  value: {\n    getUserMedia: mockGetUserMedia\n  },\n  writable: true\n})\n\n// Mock AudioContext\nglobal.AudioContext = vi.fn().mockImplementation(() => ({\n  createMediaStreamSource: vi.fn(),\n  createAnalyser: vi.fn(),\n  createGain: vi.fn(),\n  decodeAudioData: vi.fn().mockResolvedValue({}),\n  suspend: vi.fn(),\n  resume: vi.fn()\n}))\n\n// Mock MediaRecorder\nconst MockMediaRecorder = vi.fn().mockImplementation(() => ({\n  start: vi.fn(),\n  stop: vi.fn(),\n  pause: vi.fn(),\n  resume: vi.fn(),\n  addEventListener: vi.fn(),\n  removeEventListener: vi.fn(),\n  dispatchEvent: vi.fn(),\n  state: 'inactive',\n  mimeType: 'audio/webm',\n  ondataavailable: null,\n  onstop: null,\n  onerror: null\n}))\n\n// Add static method to MediaRecorder mock\nObject.defineProperty(MockMediaRecorder, 'isTypeSupported', { \n  value: vi.fn().mockReturnValue(true) \n})\nglobal.MediaRecorder = MockMediaRecorder as any\n\ndescribe('useDeepgramVoice', () => {\n  beforeEach(() => {\n    vi.clearAllMocks()\n    mockGetUserMedia.mockResolvedValue({\n      getTracks: () => [{ stop: vi.fn() }]\n    })\n    mockConnect.mockResolvedValue(undefined)\n    mockStartVoiceRecording.mockResolvedValue(undefined)\n    mockStopVoiceRecording.mockResolvedValue(undefined)\n  })\n\n  afterEach(() => {\n    vi.restoreAllMocks()\n  })\n\n  describe('Initialization', () => {\n    it('should initialize with default state', async () => {\n      const { result } = renderHook(() => useDeepgramVoice())\n\n      // Wait for initialization to complete\n      await waitFor(() => {\n        expect(result.current.connectionState).toBe('connected')\n      })\n\n      expect(result.current.isRecording).toBe(false)\n      expect(result.current.isConnected).toBe(true)\n      expect(result.current.voiceState).toBe('idle')\n      expect(result.current.transcript).toBe('')\n      expect(result.current.error).toBe(null)\n    })\n\n    it('should handle missing API key', async () => {\n      vi.stubEnv('NEXT_PUBLIC_DEEPGRAM_API_KEY', '')\n\n      const { result } = renderHook(() => useDeepgramVoice())\n\n      await waitFor(() => {\n        expect(result.current.error).toBe('Deepgram API key is required')\n        expect(result.current.connectionState).toBe('error')\n        expect(result.current.isConnected).toBe(false)\n      })\n\n      // Restore API key for other tests\n      vi.stubEnv('NEXT_PUBLIC_DEEPGRAM_API_KEY', mockApiKey)\n    })\n  })\n\n  describe('Recording Controls', () => {\n    it('should start recording successfully', async () => {\n      const { result } = renderHook(() => useDeepgramVoice())\n\n      await act(async () => {\n        await result.current.startRecording()\n      })\n\n      expect(mockStartVoiceRecording).toHaveBeenCalled()\n      expect(result.current.error).toBe(null)\n    })\n\n    it('should stop recording successfully', async () => {\n      const { result } = renderHook(() => useDeepgramVoice())\n\n      await act(async () => {\n        await result.current.stopRecording()\n      })\n\n      expect(mockStopVoiceRecording).toHaveBeenCalled()\n      expect(result.current.error).toBe(null)\n    })\n  })\n\n  describe('Mock Verification', () => {\n    it('should use mocked service', () => {\n      const { result } = renderHook(() => useDeepgramVoice())\n      \n      // Just check that the hook initializes without error\n      expect(result.current).toBeDefined()\n    })\n  })\n})"
  }
]

{
  "url": "https://python.langchain.com/api_reference/community/vectorstores/langchain_community.vectorstores.couchbase.CouchbaseVectorStore.html",
  "title": "CouchbaseVectorStore#",
  "sections": [
    {
      "type": "li",
      "content": "LangChain Python API Reference"
    },
    {
      "type": "li",
      "content": "langchain-community: 0.3.29"
    },
    {
      "type": "li",
      "content": "vectorstores"
    },
    {
      "type": "li",
      "content": "CouchbaseVectorStore"
    },
    {
      "type": "p",
      "content": "Deprecated since version 0.2.4:Use:class:`~langchain_couchbase.CouchbaseSearchVectorStore`instead. It will not be removed until langchain-community==1.0."
    },
    {
      "type": "p",
      "content": "Couchbase Vector Storevector store."
    },
    {
      "type": "p",
      "content": "To use it, you need\n- a recent installation of thecouchbaselibrary\n- a Couchbase database with a pre-defined Search index with support for"
    },
    {
      "type": "p",
      "content": "vector fields"
    },
    {
      "type": "p",
      "content": "Initialize the Couchbase Vector Store."
    },
    {
      "type": "li",
      "content": "cluster(Cluster) – couchbase cluster object with active connection."
    },
    {
      "type": "p",
      "content": "cluster(Cluster) – couchbase cluster object with active connection."
    },
    {
      "type": "li",
      "content": "bucket_name(str) – name of bucket to store documents in."
    },
    {
      "type": "p",
      "content": "bucket_name(str) – name of bucket to store documents in."
    },
    {
      "type": "li",
      "content": "scope_name(str) – name of scope in the bucket to store documents in."
    },
    {
      "type": "p",
      "content": "scope_name(str) – name of scope in the bucket to store documents in."
    },
    {
      "type": "li",
      "content": "collection_name(str) – name of collection in the scope to store documents in"
    },
    {
      "type": "p",
      "content": "collection_name(str) – name of collection in the scope to store documents in"
    },
    {
      "type": "li",
      "content": "embedding(Embeddings) – embedding function to use."
    },
    {
      "type": "p",
      "content": "embedding(Embeddings) – embedding function to use."
    },
    {
      "type": "li",
      "content": "index_name(str) – name of the Search index to use."
    },
    {
      "type": "p",
      "content": "index_name(str) – name of the Search index to use."
    },
    {
      "type": "li",
      "content": "text_key(optional[str]) – key in document to use as text.\nSet to text by default."
    },
    {
      "type": "p",
      "content": "text_key(optional[str]) – key in document to use as text.\nSet to text by default."
    },
    {
      "type": "li",
      "content": "embedding_key(optional[str]) – key in document to use for the embeddings.\nSet to embedding by default."
    },
    {
      "type": "p",
      "content": "embedding_key(optional[str]) – key in document to use for the embeddings.\nSet to embedding by default."
    },
    {
      "type": "li",
      "content": "scoped_index(optional[bool]) – specify whether the index is a scoped index.\nSet to True by default."
    },
    {
      "type": "p",
      "content": "scoped_index(optional[bool]) – specify whether the index is a scoped index.\nSet to True by default."
    },
    {
      "type": "p",
      "content": "DEFAULT_BATCH_SIZE"
    },
    {
      "type": "p",
      "content": "Return the query embedding object."
    },
    {
      "type": "p",
      "content": "__init__(cluster, bucket_name, scope_name, ...)"
    },
    {
      "type": "p",
      "content": "Initialize the Couchbase Vector Store."
    },
    {
      "type": "p",
      "content": "aadd_documents(documents, **kwargs)"
    },
    {
      "type": "p",
      "content": "Async run more documents through the embeddings and add to the vectorstore."
    },
    {
      "type": "p",
      "content": "aadd_texts(texts[, metadatas, ids])"
    },
    {
      "type": "p",
      "content": "Async run more texts through the embeddings and add to the vectorstore."
    },
    {
      "type": "p",
      "content": "add_documents(documents, **kwargs)"
    },
    {
      "type": "p",
      "content": "Add or update documents in the vectorstore."
    },
    {
      "type": "p",
      "content": "add_texts(texts[, metadatas, ids, batch_size])"
    },
    {
      "type": "p",
      "content": "Run texts through the embeddings and persist in vectorstore."
    },
    {
      "type": "p",
      "content": "adelete([ids])"
    },
    {
      "type": "p",
      "content": "Async delete by vector ID or other criteria."
    },
    {
      "type": "p",
      "content": "afrom_documents(documents, embedding, **kwargs)"
    },
    {
      "type": "p",
      "content": "Async return VectorStore initialized from documents and embeddings."
    },
    {
      "type": "p",
      "content": "afrom_texts(texts, embedding[, metadatas, ids])"
    },
    {
      "type": "p",
      "content": "Async return VectorStore initialized from texts and embeddings."
    },
    {
      "type": "p",
      "content": "aget_by_ids(ids, /)"
    },
    {
      "type": "p",
      "content": "Async get documents by their IDs."
    },
    {
      "type": "p",
      "content": "amax_marginal_relevance_search(query[, k, ...])"
    },
    {
      "type": "p",
      "content": "Async return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "amax_marginal_relevance_search_by_vector(...)"
    },
    {
      "type": "p",
      "content": "Async return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "as_retriever(**kwargs)"
    },
    {
      "type": "p",
      "content": "Return VectorStoreRetriever initialized from this VectorStore."
    },
    {
      "type": "p",
      "content": "asearch(query, search_type, **kwargs)"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to query using a specified search type."
    },
    {
      "type": "p",
      "content": "asimilarity_search(query[, k])"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to query."
    },
    {
      "type": "p",
      "content": "asimilarity_search_by_vector(embedding[, k])"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to embedding vector."
    },
    {
      "type": "p",
      "content": "asimilarity_search_with_relevance_scores(query)"
    },
    {
      "type": "p",
      "content": "Async return docs and relevance scores in the range [0, 1]."
    },
    {
      "type": "p",
      "content": "asimilarity_search_with_score(*args, **kwargs)"
    },
    {
      "type": "p",
      "content": "Async run similarity search with distance."
    },
    {
      "type": "p",
      "content": "delete([ids])"
    },
    {
      "type": "p",
      "content": "Delete documents from the vector store by ids."
    },
    {
      "type": "p",
      "content": "from_documents(documents, embedding, **kwargs)"
    },
    {
      "type": "p",
      "content": "Return VectorStore initialized from documents and embeddings."
    },
    {
      "type": "p",
      "content": "from_texts(texts, embedding[, metadatas])"
    },
    {
      "type": "p",
      "content": "Construct a Couchbase vector store from a list of texts."
    },
    {
      "type": "p",
      "content": "get_by_ids(ids, /)"
    },
    {
      "type": "p",
      "content": "Get documents by their IDs."
    },
    {
      "type": "p",
      "content": "max_marginal_relevance_search(query[, k, ...])"
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "max_marginal_relevance_search_by_vector(...)"
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "search(query, search_type, **kwargs)"
    },
    {
      "type": "p",
      "content": "Return docs most similar to query using a specified search type."
    },
    {
      "type": "p",
      "content": "similarity_search(query[, k, search_options])"
    },
    {
      "type": "p",
      "content": "Return documents most similar to embedding vector with their scores."
    },
    {
      "type": "p",
      "content": "similarity_search_by_vector(embedding[, k, ...])"
    },
    {
      "type": "p",
      "content": "Return documents that are most similar to the vector embedding."
    },
    {
      "type": "p",
      "content": "similarity_search_with_relevance_scores(query)"
    },
    {
      "type": "p",
      "content": "Return docs and relevance scores in the range [0, 1]."
    },
    {
      "type": "p",
      "content": "similarity_search_with_score(query[, k, ...])"
    },
    {
      "type": "p",
      "content": "Return documents that are most similar to the query with their scores."
    },
    {
      "type": "p",
      "content": "similarity_search_with_score_by_vector(embedding)"
    },
    {
      "type": "p",
      "content": "Return docs most similar to embedding vector with their scores."
    },
    {
      "type": "p",
      "content": "Initialize the Couchbase Vector Store."
    },
    {
      "type": "li",
      "content": "cluster(Cluster) – couchbase cluster object with active connection."
    },
    {
      "type": "p",
      "content": "cluster(Cluster) – couchbase cluster object with active connection."
    },
    {
      "type": "li",
      "content": "bucket_name(str) – name of bucket to store documents in."
    },
    {
      "type": "p",
      "content": "bucket_name(str) – name of bucket to store documents in."
    },
    {
      "type": "li",
      "content": "scope_name(str) – name of scope in the bucket to store documents in."
    },
    {
      "type": "p",
      "content": "scope_name(str) – name of scope in the bucket to store documents in."
    },
    {
      "type": "li",
      "content": "collection_name(str) – name of collection in the scope to store documents in"
    },
    {
      "type": "p",
      "content": "collection_name(str) – name of collection in the scope to store documents in"
    },
    {
      "type": "li",
      "content": "embedding(Embeddings) – embedding function to use."
    },
    {
      "type": "p",
      "content": "embedding(Embeddings) – embedding function to use."
    },
    {
      "type": "li",
      "content": "index_name(str) – name of the Search index to use."
    },
    {
      "type": "p",
      "content": "index_name(str) – name of the Search index to use."
    },
    {
      "type": "li",
      "content": "text_key(optional[str]) – key in document to use as text.\nSet to text by default."
    },
    {
      "type": "p",
      "content": "text_key(optional[str]) – key in document to use as text.\nSet to text by default."
    },
    {
      "type": "li",
      "content": "embedding_key(optional[str]) – key in document to use for the embeddings.\nSet to embedding by default."
    },
    {
      "type": "p",
      "content": "embedding_key(optional[str]) – key in document to use for the embeddings.\nSet to embedding by default."
    },
    {
      "type": "li",
      "content": "scoped_index(optional[bool]) – specify whether the index is a scoped index.\nSet to True by default."
    },
    {
      "type": "p",
      "content": "scoped_index(optional[bool]) – specify whether the index is a scoped index.\nSet to True by default."
    },
    {
      "type": "p",
      "content": "Async run more documents through the embeddings and add to the vectorstore."
    },
    {
      "type": "li",
      "content": "documents(list[Document]) – Documents to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "documents(list[Document]) – Documents to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "List of IDs of the added texts."
    },
    {
      "type": "p",
      "content": "Async run more texts through the embeddings and add to the vectorstore."
    },
    {
      "type": "li",
      "content": "texts(Iterable[str]) – Iterable of strings to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "texts(Iterable[str]) – Iterable of strings to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "metadatas(Optional[list[dict]]) – Optional list of metadatas associated with the texts.\nDefault is None."
    },
    {
      "type": "p",
      "content": "metadatas(Optional[list[dict]]) – Optional list of metadatas associated with the texts.\nDefault is None."
    },
    {
      "type": "li",
      "content": "ids(Optional[list[str]]) – Optional list"
    },
    {
      "type": "p",
      "content": "ids(Optional[list[str]]) – Optional list"
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – vectorstore specific parameters."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – vectorstore specific parameters."
    },
    {
      "type": "p",
      "content": "List of ids from adding the texts into the vectorstore."
    },
    {
      "type": "li",
      "content": "ValueError– If the number of metadatas does not match the number of texts."
    },
    {
      "type": "p",
      "content": "ValueError– If the number of metadatas does not match the number of texts."
    },
    {
      "type": "li",
      "content": "ValueError– If the number of ids does not match the number of texts."
    },
    {
      "type": "p",
      "content": "ValueError– If the number of ids does not match the number of texts."
    },
    {
      "type": "p",
      "content": "Add or update documents in the vectorstore."
    },
    {
      "type": "li",
      "content": "documents(list[Document]) – Documents to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "documents(list[Document]) – Documents to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments.\nif kwargs contains ids and documents contain ids,\nthe ids in the kwargs will receive precedence."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments.\nif kwargs contains ids and documents contain ids,\nthe ids in the kwargs will receive precedence."
    },
    {
      "type": "p",
      "content": "List of IDs of the added texts."
    },
    {
      "type": "p",
      "content": "Run texts through the embeddings and persist in vectorstore."
    },
    {
      "type": "p",
      "content": "If the document IDs are passed, the existing documents (if any) will be\noverwritten with the new ones."
    },
    {
      "type": "li",
      "content": "texts(Iterable[str]) – Iterable of strings to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "texts(Iterable[str]) – Iterable of strings to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "metadatas(Optional[List[Dict]]) – Optional list of metadatas associated\nwith the texts."
    },
    {
      "type": "p",
      "content": "metadatas(Optional[List[Dict]]) – Optional list of metadatas associated\nwith the texts."
    },
    {
      "type": "li",
      "content": "ids(Optional[List[str]]) – Optional list of ids associated with the texts.\nIDs have to be unique strings across the collection.\nIf it is not specified uuids are generated and used as ids."
    },
    {
      "type": "p",
      "content": "ids(Optional[List[str]]) – Optional list of ids associated with the texts.\nIDs have to be unique strings across the collection.\nIf it is not specified uuids are generated and used as ids."
    },
    {
      "type": "li",
      "content": "batch_size(Optional[int]) – Optional batch size for bulk insertions.\nDefault is 100."
    },
    {
      "type": "p",
      "content": "batch_size(Optional[int]) – Optional batch size for bulk insertions.\nDefault is 100."
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "List of ids from adding the texts into the vectorstore."
    },
    {
      "type": "p",
      "content": "Async delete by vector ID or other criteria."
    },
    {
      "type": "li",
      "content": "ids(list[str]|None) – List of ids to delete. If None, delete all. Default is None."
    },
    {
      "type": "p",
      "content": "ids(list[str]|None) – List of ids to delete. If None, delete all. Default is None."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Other keyword arguments that subclasses might use."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Other keyword arguments that subclasses might use."
    },
    {
      "type": "p",
      "content": "True if deletion is successful,\nFalse otherwise, None if not implemented."
    },
    {
      "type": "p",
      "content": "Optional[bool]"
    },
    {
      "type": "p",
      "content": "Async return VectorStore initialized from documents and embeddings."
    },
    {
      "type": "li",
      "content": "documents(list[Document]) – List of Documents to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "documents(list[Document]) – List of Documents to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "p",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "VectorStore initialized from documents and embeddings."
    },
    {
      "type": "p",
      "content": "VectorStore"
    },
    {
      "type": "p",
      "content": "Async return VectorStore initialized from texts and embeddings."
    },
    {
      "type": "li",
      "content": "texts(list[str]) – Texts to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "texts(list[str]) – Texts to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "p",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "li",
      "content": "metadatas(list[dict]|None) – Optional list of metadatas associated with the texts.\nDefault is None."
    },
    {
      "type": "p",
      "content": "metadatas(list[dict]|None) – Optional list of metadatas associated with the texts.\nDefault is None."
    },
    {
      "type": "li",
      "content": "ids(list[str]|None) – Optional list of IDs associated with the texts."
    },
    {
      "type": "p",
      "content": "ids(list[str]|None) – Optional list of IDs associated with the texts."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "VectorStore initialized from texts and embeddings."
    },
    {
      "type": "p",
      "content": "VectorStore"
    },
    {
      "type": "p",
      "content": "Async get documents by their IDs."
    },
    {
      "type": "p",
      "content": "The returned documents are expected to have the ID field set to the ID of the\ndocument in the vector store."
    },
    {
      "type": "p",
      "content": "Fewer documents may be returned than requested if some IDs are not found or\nif there are duplicated IDs."
    },
    {
      "type": "p",
      "content": "Users should not assume that the order of the returned documents matches\nthe order of the input IDs. Instead, users should rely on the ID field of the\nreturned documents."
    },
    {
      "type": "p",
      "content": "This method shouldNOTraise exceptions if no documents are found for\nsome IDs."
    },
    {
      "type": "p",
      "content": "ids(Sequence[str]) – List of ids to retrieve."
    },
    {
      "type": "p",
      "content": "List of Documents."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Added in version 0.2.11."
    },
    {
      "type": "p",
      "content": "Async return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "Maximal marginal relevance optimizes for similarity to query AND diversity\namong selected documents."
    },
    {
      "type": "li",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "p",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Async return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "Maximal marginal relevance optimizes for similarity to query AND diversity\namong selected documents."
    },
    {
      "type": "li",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Return VectorStoreRetriever initialized from this VectorStore."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) –Keyword arguments to pass to the search function.\nCan include:\nsearch_type (Optional[str]): Defines the type of search thatthe Retriever should perform.\nCan be “similarity” (default), “mmr”, or\n“similarity_score_threshold”.search_kwargs (Optional[Dict]): Keyword arguments to pass to thesearch function. Can include things like:k: Amount of documents to return (Default: 4)\nscore_threshold: Minimum relevance thresholdfor similarity_score_thresholdfetch_k: Amount of documents to pass to MMR algorithm(Default: 20)lambda_mult: Diversity of results returned by MMR;1 for minimum diversity and 0 for maximum. (Default: 0.5)filter: Filter by document metadata"
    },
    {
      "type": "p",
      "content": "Keyword arguments to pass to the search function.\nCan include:\nsearch_type (Optional[str]): Defines the type of search that"
    },
    {
      "type": "p",
      "content": "the Retriever should perform.\nCan be “similarity” (default), “mmr”, or\n“similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "k: Amount of documents to return (Default: 4)\nscore_threshold: Minimum relevance threshold"
    },
    {
      "type": "p",
      "content": "for similarity_score_threshold"
    },
    {
      "type": "p",
      "content": "(Default: 20)"
    },
    {
      "type": "p",
      "content": "1 for minimum diversity and 0 for maximum. (Default: 0.5)"
    },
    {
      "type": "p",
      "content": "filter: Filter by document metadata"
    },
    {
      "type": "p",
      "content": "Retriever class for VectorStore."
    },
    {
      "type": "p",
      "content": "VectorStoreRetriever"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to query using a specified search type."
    },
    {
      "type": "li",
      "content": "query(str) – Input text."
    },
    {
      "type": "p",
      "content": "query(str) – Input text."
    },
    {
      "type": "li",
      "content": "search_type(str) – Type of search to perform. Can be “similarity”,\n“mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "search_type(str) – Type of search to perform. Can be “similarity”,\n“mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query."
    },
    {
      "type": "p",
      "content": "ValueError– If search_type is not one of “similarity”,\n    “mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to query."
    },
    {
      "type": "li",
      "content": "query(str) – Input text."
    },
    {
      "type": "p",
      "content": "query(str) – Input text."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to embedding vector."
    },
    {
      "type": "li",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query vector."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Async return docs and relevance scores in the range [0, 1]."
    },
    {
      "type": "p",
      "content": "0 is dissimilar, 1 is most similar."
    },
    {
      "type": "li",
      "content": "query(str) – Input text."
    },
    {
      "type": "p",
      "content": "query(str) – Input text."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) –kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 tofilter the resulting set of retrieved docs"
    },
    {
      "type": "p",
      "content": "**kwargs(Any) –kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 tofilter the resulting set of retrieved docs"
    },
    {
      "type": "p",
      "content": "kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 to"
    },
    {
      "type": "p",
      "content": "filter the resulting set of retrieved docs"
    },
    {
      "type": "p",
      "content": "List of Tuples of (doc, similarity_score)"
    },
    {
      "type": "p",
      "content": "list[tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Async run similarity search with distance."
    },
    {
      "type": "li",
      "content": "*args(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "*args(Any) – Arguments to pass to the search method."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Tuples of (doc, similarity_score)."
    },
    {
      "type": "p",
      "content": "list[tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Delete documents from the vector store by ids."
    },
    {
      "type": "li",
      "content": "ids(List[str]) – List of IDs of the documents to delete."
    },
    {
      "type": "p",
      "content": "ids(List[str]) – List of IDs of the documents to delete."
    },
    {
      "type": "li",
      "content": "batch_size(Optional[int]) – Optional batch size for bulk deletions."
    },
    {
      "type": "p",
      "content": "batch_size(Optional[int]) – Optional batch size for bulk deletions."
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "True if all the documents were deleted successfully, False otherwise."
    },
    {
      "type": "p",
      "content": "Return VectorStore initialized from documents and embeddings."
    },
    {
      "type": "li",
      "content": "documents(list[Document]) – List of Documents to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "documents(list[Document]) – List of Documents to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "p",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "VectorStore initialized from documents and embeddings."
    },
    {
      "type": "p",
      "content": "VectorStore"
    },
    {
      "type": "p",
      "content": "Construct a Couchbase vector store from a list of texts."
    },
    {
      "type": "p",
      "content": "from langchain_community.vectorstores import CouchbaseVectorStore\nfrom langchain_openai import OpenAIEmbeddings"
    },
    {
      "type": "p",
      "content": "from couchbase.cluster import Cluster\nfrom couchbase.auth import PasswordAuthenticator\nfrom couchbase.options import ClusterOptions\nfrom datetime import timedelta"
    },
    {
      "type": "p",
      "content": "auth = PasswordAuthenticator(username, password)\noptions = ClusterOptions(auth)\nconnect_string = “couchbases://localhost”\ncluster = Cluster(connect_string, options)"
    },
    {
      "type": "p",
      "content": "# Wait until the cluster is ready for use.\ncluster.wait_until_ready(timedelta(seconds=5))"
    },
    {
      "type": "p",
      "content": "embeddings = OpenAIEmbeddings()"
    },
    {
      "type": "p",
      "content": "texts = [“hello”, “world”]"
    },
    {
      "type": "p",
      "content": "texts,\nembedding=embeddings,\ncluster=cluster,\nbucket_name=””,\nscope_name=””,\ncollection_name=””,\nindex_name=”vector-index”,"
    },
    {
      "type": "li",
      "content": "texts(List[str]) – list of texts to add to the vector store."
    },
    {
      "type": "p",
      "content": "texts(List[str]) – list of texts to add to the vector store."
    },
    {
      "type": "li",
      "content": "embedding(Embeddings) – embedding function to use."
    },
    {
      "type": "p",
      "content": "embedding(Embeddings) – embedding function to use."
    },
    {
      "type": "li",
      "content": "metadatas(optional[List[Dict]) – list of metadatas to add to documents."
    },
    {
      "type": "p",
      "content": "metadatas(optional[List[Dict]) – list of metadatas to add to documents."
    },
    {
      "type": "li",
      "content": "**kwargs– Keyword arguments used to initialize the vector store with and/or\npassed toadd_textsmethod. Check the constructor and/oradd_textsfor the list of accepted arguments."
    },
    {
      "type": "p",
      "content": "**kwargs– Keyword arguments used to initialize the vector store with and/or\npassed toadd_textsmethod. Check the constructor and/oradd_textsfor the list of accepted arguments."
    },
    {
      "type": "p",
      "content": "A Couchbase vector store."
    },
    {
      "type": "p",
      "content": "CouchbaseVectorStore"
    },
    {
      "type": "p",
      "content": "Get documents by their IDs."
    },
    {
      "type": "p",
      "content": "The returned documents are expected to have the ID field set to the ID of the\ndocument in the vector store."
    },
    {
      "type": "p",
      "content": "Fewer documents may be returned than requested if some IDs are not found or\nif there are duplicated IDs."
    },
    {
      "type": "p",
      "content": "Users should not assume that the order of the returned documents matches\nthe order of the input IDs. Instead, users should rely on the ID field of the\nreturned documents."
    },
    {
      "type": "p",
      "content": "This method shouldNOTraise exceptions if no documents are found for\nsome IDs."
    },
    {
      "type": "p",
      "content": "ids(Sequence[str]) – List of ids to retrieve."
    },
    {
      "type": "p",
      "content": "List of Documents."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Added in version 0.2.11."
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "Maximal marginal relevance optimizes for similarity to query AND diversity\namong selected documents."
    },
    {
      "type": "li",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "p",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "Maximal marginal relevance optimizes for similarity to query AND diversity\namong selected documents."
    },
    {
      "type": "li",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Return docs most similar to query using a specified search type."
    },
    {
      "type": "li",
      "content": "query(str) – Input text"
    },
    {
      "type": "p",
      "content": "query(str) – Input text"
    },
    {
      "type": "li",
      "content": "search_type(str) – Type of search to perform. Can be “similarity”,\n“mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "search_type(str) – Type of search to perform. Can be “similarity”,\n“mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query."
    },
    {
      "type": "p",
      "content": "ValueError– If search_type is not one of “similarity”,\n    “mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Return documents most similar to embedding vector with their scores."
    },
    {
      "type": "li",
      "content": "query(str) – Query to look up for similar documents"
    },
    {
      "type": "p",
      "content": "query(str) – Query to look up for similar documents"
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return.\nDefaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return.\nDefaults to 4."
    },
    {
      "type": "li",
      "content": "search_options(Optional[Dict[str,Any]]) – Optional search options that are\npassed to Couchbase search.\nDefaults to empty dictionary"
    },
    {
      "type": "p",
      "content": "search_options(Optional[Dict[str,Any]]) – Optional search options that are\npassed to Couchbase search.\nDefaults to empty dictionary"
    },
    {
      "type": "li",
      "content": "fields(Optional[List[str]]) – Optional list of fields to include in the\nmetadata of results. Note that these need to be stored in the index.\nIf nothing is specified, defaults to all the fields stored in the index."
    },
    {
      "type": "p",
      "content": "fields(Optional[List[str]]) – Optional list of fields to include in the\nmetadata of results. Note that these need to be stored in the index.\nIf nothing is specified, defaults to all the fields stored in the index."
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query."
    },
    {
      "type": "p",
      "content": "List[Document]"
    },
    {
      "type": "p",
      "content": "Return documents that are most similar to the vector embedding."
    },
    {
      "type": "li",
      "content": "embedding(List[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(List[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return.\nDefaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return.\nDefaults to 4."
    },
    {
      "type": "li",
      "content": "search_options(Optional[Dict[str,Any]]) – Optional search options that are\npassed to Couchbase search.\nDefaults to empty dictionary."
    },
    {
      "type": "p",
      "content": "search_options(Optional[Dict[str,Any]]) – Optional search options that are\npassed to Couchbase search.\nDefaults to empty dictionary."
    },
    {
      "type": "li",
      "content": "fields(Optional[List[str]]) – Optional list of fields to include in the\nmetadata of results. Note that these need to be stored in the index.\nIf nothing is specified, defaults to document text and metadata fields."
    },
    {
      "type": "p",
      "content": "fields(Optional[List[str]]) – Optional list of fields to include in the\nmetadata of results. Note that these need to be stored in the index.\nIf nothing is specified, defaults to document text and metadata fields."
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query."
    },
    {
      "type": "p",
      "content": "List[Document]"
    },
    {
      "type": "p",
      "content": "Return docs and relevance scores in the range [0, 1]."
    },
    {
      "type": "p",
      "content": "0 is dissimilar, 1 is most similar."
    },
    {
      "type": "li",
      "content": "query(str) – Input text."
    },
    {
      "type": "p",
      "content": "query(str) – Input text."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) –kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 tofilter the resulting set of retrieved docs."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) –kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 tofilter the resulting set of retrieved docs."
    },
    {
      "type": "p",
      "content": "kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 to"
    },
    {
      "type": "p",
      "content": "filter the resulting set of retrieved docs."
    },
    {
      "type": "p",
      "content": "List of Tuples of (doc, similarity_score)."
    },
    {
      "type": "p",
      "content": "list[tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Return documents that are most similar to the query with their scores."
    },
    {
      "type": "li",
      "content": "query(str) – Query to look up for similar documents"
    },
    {
      "type": "p",
      "content": "query(str) – Query to look up for similar documents"
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return.\nDefaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return.\nDefaults to 4."
    },
    {
      "type": "li",
      "content": "search_options(Optional[Dict[str,Any]]) – Optional search options that are\npassed to Couchbase search.\nDefaults to empty dictionary."
    },
    {
      "type": "p",
      "content": "search_options(Optional[Dict[str,Any]]) – Optional search options that are\npassed to Couchbase search.\nDefaults to empty dictionary."
    },
    {
      "type": "li",
      "content": "fields(Optional[List[str]]) – Optional list of fields to include in the\nmetadata of results. Note that these need to be stored in the index.\nIf nothing is specified, defaults to text and metadata fields."
    },
    {
      "type": "p",
      "content": "fields(Optional[List[str]]) – Optional list of fields to include in the\nmetadata of results. Note that these need to be stored in the index.\nIf nothing is specified, defaults to text and metadata fields."
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "List of (Document, score) that are most similar to the query."
    },
    {
      "type": "p",
      "content": "List[Tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Return docs most similar to embedding vector with their scores."
    },
    {
      "type": "li",
      "content": "embedding(List[float]) – Embedding vector to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(List[float]) – Embedding vector to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return.\nDefaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return.\nDefaults to 4."
    },
    {
      "type": "li",
      "content": "search_options(Optional[Dict[str,Any]]) – Optional search options that are\npassed to Couchbase search.\nDefaults to empty dictionary."
    },
    {
      "type": "p",
      "content": "search_options(Optional[Dict[str,Any]]) – Optional search options that are\npassed to Couchbase search.\nDefaults to empty dictionary."
    },
    {
      "type": "li",
      "content": "fields(Optional[List[str]]) – Optional list of fields to include in the\nmetadata of results. Note that these need to be stored in the index.\nIf nothing is specified, defaults to all the fields stored in the index."
    },
    {
      "type": "p",
      "content": "fields(Optional[List[str]]) – Optional list of fields to include in the\nmetadata of results. Note that these need to be stored in the index.\nIf nothing is specified, defaults to all the fields stored in the index."
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "List of (Document, score) that are the most similar to the query vector."
    },
    {
      "type": "p",
      "content": "List[Tuple[Document, float]]"
    },
    {
      "type": "li",
      "content": "CouchbaseVectorStore__init__()aadd_documents()aadd_texts()add_documents()add_texts()adelete()afrom_documents()afrom_texts()aget_by_ids()amax_marginal_relevance_search()amax_marginal_relevance_search_by_vector()as_retriever()asearch()asimilarity_search()asimilarity_search_by_vector()asimilarity_search_with_relevance_scores()asimilarity_search_with_score()delete()from_documents()from_texts()get_by_ids()max_marginal_relevance_search()max_marginal_relevance_search_by_vector()search()similarity_search()similarity_search_by_vector()similarity_search_with_relevance_scores()similarity_search_with_score()similarity_search_with_score_by_vector()"
    },
    {
      "type": "li",
      "content": "aadd_documents()"
    },
    {
      "type": "li",
      "content": "aadd_texts()"
    },
    {
      "type": "li",
      "content": "add_documents()"
    },
    {
      "type": "li",
      "content": "add_texts()"
    },
    {
      "type": "li",
      "content": "afrom_documents()"
    },
    {
      "type": "li",
      "content": "afrom_texts()"
    },
    {
      "type": "li",
      "content": "aget_by_ids()"
    },
    {
      "type": "li",
      "content": "amax_marginal_relevance_search()"
    },
    {
      "type": "li",
      "content": "amax_marginal_relevance_search_by_vector()"
    },
    {
      "type": "li",
      "content": "as_retriever()"
    },
    {
      "type": "li",
      "content": "asimilarity_search()"
    },
    {
      "type": "li",
      "content": "asimilarity_search_by_vector()"
    },
    {
      "type": "li",
      "content": "asimilarity_search_with_relevance_scores()"
    },
    {
      "type": "li",
      "content": "asimilarity_search_with_score()"
    },
    {
      "type": "li",
      "content": "from_documents()"
    },
    {
      "type": "li",
      "content": "from_texts()"
    },
    {
      "type": "li",
      "content": "get_by_ids()"
    },
    {
      "type": "li",
      "content": "max_marginal_relevance_search()"
    },
    {
      "type": "li",
      "content": "max_marginal_relevance_search_by_vector()"
    },
    {
      "type": "li",
      "content": "similarity_search()"
    },
    {
      "type": "li",
      "content": "similarity_search_by_vector()"
    },
    {
      "type": "li",
      "content": "similarity_search_with_relevance_scores()"
    },
    {
      "type": "li",
      "content": "similarity_search_with_score()"
    },
    {
      "type": "li",
      "content": "similarity_search_with_score_by_vector()"
    }
  ],
  "code_examples": [
    "vectorstores",
    ":class:`~langchain_couchbase.CouchbaseSearchVectorStore`",
    "fromlangchain_community.vectorstoresimportCouchbaseVectorStorefromlangchain_openaiimportOpenAIEmbeddingsfromcouchbase.clusterimportClusterfromcouchbase.authimportPasswordAuthenticatorfromcouchbase.optionsimportClusterOptionsfromdatetimeimporttimedeltaauth=PasswordAuthenticator(username,password)options=ClusterOptions(auth)connect_string=\"couchbases://localhost\"cluster=Cluster(connect_string,options)# Wait until the cluster is ready for use.cluster.wait_until_ready(timedelta(seconds=5))embeddings=OpenAIEmbeddings()vectorstore=CouchbaseVectorStore(cluster=cluster,bucket_name=\"\",scope_name=\"\",collection_name=\"\",embedding=embeddings,index_name=\"vector-index\",)vectorstore.add_texts([\"hello\",\"world\"])results=vectorstore.similarity_search(\"ola\",k=1)",
    "DEFAULT_BATCH_SIZE",
    "embeddings",
    "__init__",
    "aadd_documents",
    "aadd_texts",
    "add_documents",
    "add_texts",
    "adelete",
    "afrom_documents",
    "afrom_texts",
    "aget_by_ids",
    "amax_marginal_relevance_search",
    "amax_marginal_relevance_search_by_vector",
    "as_retriever",
    "asearch",
    "asimilarity_search",
    "asimilarity_search_by_vector",
    "asimilarity_search_with_relevance_scores",
    "asimilarity_search_with_score",
    "delete",
    "from_documents",
    "from_texts",
    "get_by_ids",
    "max_marginal_relevance_search",
    "max_marginal_relevance_search_by_vector",
    "search",
    "similarity_search",
    "similarity_search_by_vector",
    "similarity_search_with_relevance_scores",
    "similarity_search_with_score",
    "similarity_search_with_score_by_vector",
    "# Retrieve more documents with higher diversity# Useful if your dataset has many similar documentsdocsearch.as_retriever(search_type=\"mmr\",search_kwargs={\"k\":6,\"lambda_mult\":0.25})# Fetch more documents for the MMR algorithm to consider# But only return the top 5docsearch.as_retriever(search_type=\"mmr\",search_kwargs={\"k\":5,\"fetch_k\":50})# Only retrieve documents that have a relevance score# Above a certain thresholddocsearch.as_retriever(search_type=\"similarity_score_threshold\",search_kwargs={\"score_threshold\":0.8},)# Only get the single most similar document from the datasetdocsearch.as_retriever(search_kwargs={\"k\":1})# Use a filter to only retrieve documents from a specific paperdocsearch.as_retriever(search_kwargs={\"filter\":{\"paper_title\":\"GPT-4 Technical Report\"}})",
    "",
    "CouchbaseVectorStore",
    "__init__()",
    "aadd_documents()",
    "aadd_texts()",
    "add_documents()",
    "add_texts()",
    "adelete()",
    "afrom_documents()",
    "afrom_texts()",
    "aget_by_ids()",
    "amax_marginal_relevance_search()",
    "amax_marginal_relevance_search_by_vector()",
    "as_retriever()",
    "asearch()",
    "asimilarity_search()",
    "asimilarity_search_by_vector()",
    "asimilarity_search_with_relevance_scores()",
    "asimilarity_search_with_score()",
    "delete()",
    "from_documents()",
    "from_texts()",
    "get_by_ids()",
    "max_marginal_relevance_search()",
    "max_marginal_relevance_search_by_vector()",
    "search()",
    "similarity_search()",
    "similarity_search_by_vector()",
    "similarity_search_with_relevance_scores()",
    "similarity_search_with_score()",
    "similarity_search_with_score_by_vector()"
  ],
  "api_signatures": [
    "classlangchain_community.vectorstores.couchbase.CouchbaseVectorStore(cluster:Cluster,bucket_name:str,scope_name:str,collection_name:str,embedding:Embeddings,index_name:str,*,text_key:str|None='text',embedding_key:str|None='embedding',scoped_index:bool=True,)[source]#",
    "langchain_community.vectorstores.couchbase.",
    "CouchbaseVectorStore",
    "(",
    "cluster:Cluster",
    "bucket_name:str",
    "scope_name:str",
    "collection_name:str",
    "embedding:Embeddings",
    "index_name:str",
    "*",
    "text_key:str|None='text'",
    "embedding_key:str|None='embedding'",
    "scoped_index:bool=True",
    ")",
    "__init__(cluster:Cluster,bucket_name:str,scope_name:str,collection_name:str,embedding:Embeddings,index_name:str,*,text_key:str|None='text',embedding_key:str|None='embedding',scoped_index:bool=True,)→None[source]#",
    "__init__",
    "(",
    "cluster:Cluster",
    "bucket_name:str",
    "scope_name:str",
    "collection_name:str",
    "embedding:Embeddings",
    "index_name:str",
    "*",
    "text_key:str|None='text'",
    "embedding_key:str|None='embedding'",
    "scoped_index:bool=True",
    ")",
    "→None",
    "→",
    "None",
    "asyncaadd_documents(documents:list[Document],**kwargs:Any,)→list[str]#",
    "aadd_documents",
    "(",
    "documents:list[Document]",
    "**kwargs:Any",
    ")",
    "→list[str]",
    "→",
    "list[str]",
    "asyncaadd_texts(texts:Iterable[str],metadatas:list[dict]|None=None,*,ids:list[str]|None=None,**kwargs:Any,)→list[str]#",
    "aadd_texts",
    "(",
    "texts:Iterable[str]",
    "metadatas:list[dict]|None=None",
    "*",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    ")",
    "→list[str]",
    "→",
    "list[str]",
    "add_documents(documents:list[Document],**kwargs:Any,)→list[str]#",
    "add_documents",
    "(",
    "documents:list[Document]",
    "**kwargs:Any",
    ")",
    "→list[str]",
    "→",
    "list[str]",
    "add_texts(texts:Iterable[str],metadatas:List[Dict[str,Any]]|None=None,ids:List[str]|None=None,batch_size:int|None=None,**kwargs:Any,)→List[str][source]#",
    "add_texts",
    "(",
    "texts:Iterable[str]",
    "metadatas:List[Dict[str,Any]]|None=None",
    "ids:List[str]|None=None",
    "batch_size:int|None=None",
    "**kwargs:Any",
    ")",
    "→List[str]",
    "→",
    "List[str]",
    "asyncadelete(ids:list[str]|None=None,**kwargs:Any,)→bool|None#",
    "adelete",
    "(",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    ")",
    "→bool|None",
    "→",
    "bool|None",
    "asyncclassmethodafrom_documents(documents:list[Document],embedding:Embeddings,**kwargs:Any,)→Self#",
    "afrom_documents",
    "(",
    "documents:list[Document]",
    "embedding:Embeddings",
    "**kwargs:Any",
    ")",
    "→Self",
    "→",
    "Self",
    "asyncclassmethodafrom_texts(texts:list[str],embedding:Embeddings,metadatas:list[dict]|None=None,*,ids:list[str]|None=None,**kwargs:Any,)→Self#",
    "afrom_texts",
    "(",
    "texts:list[str]",
    "embedding:Embeddings",
    "metadatas:list[dict]|None=None",
    "*",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    ")",
    "→Self",
    "→",
    "Self",
    "asyncaget_by_ids(ids:Sequence[str],/,)→list[Document]#",
    "aget_by_ids",
    "(",
    "ids:Sequence[str]",
    "/",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncamax_marginal_relevance_search(query:str,k:int=4,fetch_k:int=20,lambda_mult:float=0.5,**kwargs:Any,)→list[Document]#",
    "amax_marginal_relevance_search",
    "(",
    "query:str",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncamax_marginal_relevance_search_by_vector(embedding:list[float],k:int=4,fetch_k:int=20,lambda_mult:float=0.5,**kwargs:Any,)→list[Document]#",
    "amax_marginal_relevance_search_by_vector",
    "(",
    "embedding:list[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "as_retriever(**kwargs:Any,)→VectorStoreRetriever#",
    "as_retriever",
    "(",
    "**kwargs:Any",
    ")",
    "→VectorStoreRetriever",
    "→",
    "VectorStoreRetriever",
    "asyncasearch(query:str,search_type:str,**kwargs:Any,)→list[Document]#",
    "asearch",
    "(",
    "query:str",
    "search_type:str",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncasimilarity_search(query:str,k:int=4,**kwargs:Any,)→list[Document]#",
    "asimilarity_search",
    "(",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncasimilarity_search_by_vector(embedding:list[float],k:int=4,**kwargs:Any,)→list[Document]#",
    "asimilarity_search_by_vector",
    "(",
    "embedding:list[float]",
    "k:int=4",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncasimilarity_search_with_relevance_scores(query:str,k:int=4,**kwargs:Any,)→list[tuple[Document,float]]#",
    "asimilarity_search_with_relevance_scores",
    "(",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    ")",
    "→list[tuple[Document,float]]",
    "→",
    "list[tuple[Document,float]]",
    "asyncasimilarity_search_with_score(*args:Any,**kwargs:Any,)→list[tuple[Document,float]]#",
    "asimilarity_search_with_score",
    "(",
    "*args:Any",
    "**kwargs:Any",
    ")",
    "→list[tuple[Document,float]]",
    "→",
    "list[tuple[Document,float]]",
    "delete(ids:List[str]|None=None,**kwargs:Any,)→bool|None[source]#",
    "delete",
    "(",
    "ids:List[str]|None=None",
    "**kwargs:Any",
    ")",
    "→bool|None",
    "→",
    "bool|None",
    "classmethodfrom_documents(documents:list[Document],embedding:Embeddings,**kwargs:Any,)→Self#",
    "from_documents",
    "(",
    "documents:list[Document]",
    "embedding:Embeddings",
    "**kwargs:Any",
    ")",
    "→Self",
    "→",
    "Self",
    "classmethodfrom_texts(texts:List[str],embedding:Embeddings,metadatas:List[Dict[Any,Any]]|None=None,**kwargs:Any,)→CouchbaseVectorStore[source]#",
    "from_texts",
    "(",
    "texts:List[str]",
    "embedding:Embeddings",
    "metadatas:List[Dict[Any,Any]]|None=None",
    "**kwargs:Any",
    ")",
    "→CouchbaseVectorStore",
    "→",
    "CouchbaseVectorStore",
    "get_by_ids(ids:Sequence[str],/,)→list[Document]#",
    "get_by_ids",
    "(",
    "ids:Sequence[str]",
    "/",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "max_marginal_relevance_search(query:str,k:int=4,fetch_k:int=20,lambda_mult:float=0.5,**kwargs:Any,)→list[Document]#",
    "max_marginal_relevance_search",
    "(",
    "query:str",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "max_marginal_relevance_search_by_vector(embedding:list[float],k:int=4,fetch_k:int=20,lambda_mult:float=0.5,**kwargs:Any,)→list[Document]#",
    "max_marginal_relevance_search_by_vector",
    "(",
    "embedding:list[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "search(query:str,search_type:str,**kwargs:Any,)→list[Document]#",
    "search",
    "(",
    "query:str",
    "search_type:str",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "similarity_search(query:str,k:int=4,search_options:Dict[str,Any]|None={},**kwargs:Any,)→List[Document][source]#",
    "similarity_search",
    "(",
    "query:str",
    "k:int=4",
    "search_options:Dict[str,Any]|None={}",
    "**kwargs:Any",
    ")",
    "→List[Document]",
    "→",
    "List[Document]",
    "similarity_search_by_vector(embedding:List[float],k:int=4,search_options:Dict[str,Any]|None={},**kwargs:Any,)→List[Document][source]#",
    "similarity_search_by_vector",
    "(",
    "embedding:List[float]",
    "k:int=4",
    "search_options:Dict[str,Any]|None={}",
    "**kwargs:Any",
    ")",
    "→List[Document]",
    "→",
    "List[Document]",
    "similarity_search_with_relevance_scores(query:str,k:int=4,**kwargs:Any,)→list[tuple[Document,float]]#",
    "similarity_search_with_relevance_scores",
    "(",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    ")",
    "→list[tuple[Document,float]]",
    "→",
    "list[tuple[Document,float]]",
    "similarity_search_with_score(query:str,k:int=4,search_options:Dict[str,Any]|None={},**kwargs:Any,)→List[Tuple[Document,float]][source]#",
    "similarity_search_with_score",
    "(",
    "query:str",
    "k:int=4",
    "search_options:Dict[str,Any]|None={}",
    "**kwargs:Any",
    ")",
    "→List[Tuple[Document,float]]",
    "→",
    "List[Tuple[Document,float]]",
    "similarity_search_with_score_by_vector(embedding:List[float],k:int=4,search_options:Dict[str,Any]|None={},**kwargs:Any,)→List[Tuple[Document,float]][source]#",
    "similarity_search_with_score_by_vector",
    "(",
    "embedding:List[float]",
    "k:int=4",
    "search_options:Dict[str,Any]|None={}",
    "**kwargs:Any",
    ")",
    "→List[Tuple[Document,float]]",
    "→",
    "List[Tuple[Document,float]]"
  ],
  "parameters": [
    "cluster:Cluster",
    "bucket_name:str",
    "scope_name:str",
    "collection_name:str",
    "embedding:Embeddings",
    "index_name:str",
    "*",
    "text_key:str|None='text'",
    "embedding_key:str|None='embedding'",
    "scoped_index:bool=True",
    "cluster:Cluster",
    "bucket_name:str",
    "scope_name:str",
    "collection_name:str",
    "embedding:Embeddings",
    "index_name:str",
    "*",
    "text_key:str|None='text'",
    "embedding_key:str|None='embedding'",
    "scoped_index:bool=True",
    "documents:list[Document]",
    "**kwargs:Any",
    "texts:Iterable[str]",
    "metadatas:list[dict]|None=None",
    "*",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    "documents:list[Document]",
    "**kwargs:Any",
    "texts:Iterable[str]",
    "metadatas:List[Dict[str,Any]]|None=None",
    "ids:List[str]|None=None",
    "batch_size:int|None=None",
    "**kwargs:Any",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    "documents:list[Document]",
    "embedding:Embeddings",
    "**kwargs:Any",
    "texts:list[str]",
    "embedding:Embeddings",
    "metadatas:list[dict]|None=None",
    "*",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    "ids:Sequence[str]",
    "/",
    "query:str",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    "embedding:list[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    "**kwargs:Any",
    "query:str",
    "search_type:str",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    "embedding:list[float]",
    "k:int=4",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    "*args:Any",
    "**kwargs:Any",
    "ids:List[str]|None=None",
    "**kwargs:Any",
    "documents:list[Document]",
    "embedding:Embeddings",
    "**kwargs:Any",
    "texts:List[str]",
    "embedding:Embeddings",
    "metadatas:List[Dict[Any,Any]]|None=None",
    "**kwargs:Any",
    "ids:Sequence[str]",
    "/",
    "query:str",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    "embedding:list[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    "query:str",
    "search_type:str",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "search_options:Dict[str,Any]|None={}",
    "**kwargs:Any",
    "embedding:List[float]",
    "k:int=4",
    "search_options:Dict[str,Any]|None={}",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "search_options:Dict[str,Any]|None={}",
    "**kwargs:Any",
    "embedding:List[float]",
    "k:int=4",
    "search_options:Dict[str,Any]|None={}",
    "**kwargs:Any"
  ]
}

{
  "url": "https://python.langchain.com/api_reference/community/vectorstores/langchain_community.vectorstores.lantern.Lantern.html#langchain_community.vectorstores.lantern.Lantern",
  "title": "Lantern#",
  "sections": [
    {
      "type": "li",
      "content": "LangChain Python API Reference"
    },
    {
      "type": "li",
      "content": "langchain-community: 0.3.29"
    },
    {
      "type": "li",
      "content": "vectorstores"
    },
    {
      "type": "p",
      "content": "Postgreswith thelanternextension as a vector store."
    },
    {
      "type": "p",
      "content": "lantern uses sequential scan by default. but you can create a HNSW index\nusing the create_hnsw_index method.\n-connection_stringis a postgres connection string.\n-embedding_functionany embedding function implementing"
    },
    {
      "type": "p",
      "content": "langchain.embeddings.base.Embeddingsinterface."
    },
    {
      "type": "li",
      "content": "collection_nameis the name of the collection to use. (default: langchain)NOTE: This is the name of the table in which embedding data will be storedThe table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "li",
      "content": "NOTE: This is the name of the table in which embedding data will be storedThe table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "p",
      "content": "The table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "li",
      "content": "distance_strategyis the distance strategy to use. (default: EUCLIDEAN)EUCLIDEANis the euclidean distance.COSINEis the cosine distance.HAMMINGis the hamming distance."
    },
    {
      "type": "li",
      "content": "EUCLIDEANis the euclidean distance."
    },
    {
      "type": "p",
      "content": "EUCLIDEANis the euclidean distance."
    },
    {
      "type": "li",
      "content": "COSINEis the cosine distance."
    },
    {
      "type": "p",
      "content": "COSINEis the cosine distance."
    },
    {
      "type": "li",
      "content": "HAMMINGis the hamming distance."
    },
    {
      "type": "p",
      "content": "HAMMINGis the hamming distance."
    },
    {
      "type": "li",
      "content": "pre_delete_collectionif True, will delete the collection if it exists.(default: False)\n- Useful for testing."
    },
    {
      "type": "p",
      "content": "(default: False)\n- Useful for testing."
    },
    {
      "type": "p",
      "content": "distance_function"
    },
    {
      "type": "p",
      "content": "distance_strategy"
    },
    {
      "type": "p",
      "content": "Access the query embedding object if available."
    },
    {
      "type": "p",
      "content": "__init__(connection_string, embedding_function)"
    },
    {
      "type": "p",
      "content": "aadd_documents(documents, **kwargs)"
    },
    {
      "type": "p",
      "content": "Async run more documents through the embeddings and add to the vectorstore."
    },
    {
      "type": "p",
      "content": "aadd_texts(texts[, metadatas, ids])"
    },
    {
      "type": "p",
      "content": "Async run more texts through the embeddings and add to the vectorstore."
    },
    {
      "type": "p",
      "content": "add_documents(documents, **kwargs)"
    },
    {
      "type": "p",
      "content": "Add or update documents in the vectorstore."
    },
    {
      "type": "p",
      "content": "add_embeddings(texts, embeddings, metadatas, ...)"
    },
    {
      "type": "p",
      "content": "add_texts(texts[, metadatas, ids])"
    },
    {
      "type": "p",
      "content": "Run more texts through the embeddings and add to the vectorstore."
    },
    {
      "type": "p",
      "content": "adelete([ids])"
    },
    {
      "type": "p",
      "content": "Async delete by vector ID or other criteria."
    },
    {
      "type": "p",
      "content": "afrom_documents(documents, embedding, **kwargs)"
    },
    {
      "type": "p",
      "content": "Async return VectorStore initialized from documents and embeddings."
    },
    {
      "type": "p",
      "content": "afrom_texts(texts, embedding[, metadatas, ids])"
    },
    {
      "type": "p",
      "content": "Async return VectorStore initialized from texts and embeddings."
    },
    {
      "type": "p",
      "content": "aget_by_ids(ids, /)"
    },
    {
      "type": "p",
      "content": "Async get documents by their IDs."
    },
    {
      "type": "p",
      "content": "amax_marginal_relevance_search(query[, k, ...])"
    },
    {
      "type": "p",
      "content": "Async return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "amax_marginal_relevance_search_by_vector(...)"
    },
    {
      "type": "p",
      "content": "Async return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "as_retriever(**kwargs)"
    },
    {
      "type": "p",
      "content": "Return VectorStoreRetriever initialized from this VectorStore."
    },
    {
      "type": "p",
      "content": "asearch(query, search_type, **kwargs)"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to query using a specified search type."
    },
    {
      "type": "p",
      "content": "asimilarity_search(query[, k])"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to query."
    },
    {
      "type": "p",
      "content": "asimilarity_search_by_vector(embedding[, k])"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to embedding vector."
    },
    {
      "type": "p",
      "content": "asimilarity_search_with_relevance_scores(query)"
    },
    {
      "type": "p",
      "content": "Async return docs and relevance scores in the range [0, 1]."
    },
    {
      "type": "p",
      "content": "asimilarity_search_with_score(*args, **kwargs)"
    },
    {
      "type": "p",
      "content": "Async run similarity search with distance."
    },
    {
      "type": "p",
      "content": "connection_string_from_db_params(driver, ...)"
    },
    {
      "type": "p",
      "content": "Return connection string from database parameters."
    },
    {
      "type": "p",
      "content": "create_collection()"
    },
    {
      "type": "p",
      "content": "create_hnsw_extension()"
    },
    {
      "type": "p",
      "content": "create_hnsw_index([dims, m, ...])"
    },
    {
      "type": "p",
      "content": "Create HNSW index on collection."
    },
    {
      "type": "p",
      "content": "create_tables_if_not_exists()"
    },
    {
      "type": "p",
      "content": "delete([ids])"
    },
    {
      "type": "p",
      "content": "Delete vectors by ids or uuids."
    },
    {
      "type": "p",
      "content": "delete_collection()"
    },
    {
      "type": "p",
      "content": "drop_index()"
    },
    {
      "type": "p",
      "content": "drop_table()"
    },
    {
      "type": "p",
      "content": "drop_tables()"
    },
    {
      "type": "p",
      "content": "from_documents(documents, embedding[, ...])"
    },
    {
      "type": "p",
      "content": "Initialize a vector store with a set of documents."
    },
    {
      "type": "p",
      "content": "from_embeddings(text_embeddings, embedding)"
    },
    {
      "type": "p",
      "content": "Construct Lantern wrapper from raw documents and pre- generated embeddings."
    },
    {
      "type": "p",
      "content": "from_existing_index(embedding[, ...])"
    },
    {
      "type": "p",
      "content": "Get instance of an existing Lantern store.This method will return the instance of the store without inserting any new embeddings"
    },
    {
      "type": "p",
      "content": "from_texts(texts, embedding[, metadatas, ...])"
    },
    {
      "type": "p",
      "content": "Initialize Lantern vectorstore from list of texts."
    },
    {
      "type": "p",
      "content": "get_by_ids(ids, /)"
    },
    {
      "type": "p",
      "content": "Get documents by their IDs."
    },
    {
      "type": "p",
      "content": "max_marginal_relevance_search(query[, k, ...])"
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "max_marginal_relevance_search_by_vector(...)"
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance"
    },
    {
      "type": "p",
      "content": "max_marginal_relevance_search_with_score(query)"
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance with score."
    },
    {
      "type": "p",
      "content": "max_marginal_relevance_search_with_score_by_vector(...)"
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance with score"
    },
    {
      "type": "p",
      "content": "search(query, search_type, **kwargs)"
    },
    {
      "type": "p",
      "content": "Return docs most similar to query using a specified search type."
    },
    {
      "type": "p",
      "content": "similarity_search(query[, k, filter])"
    },
    {
      "type": "p",
      "content": "Return docs most similar to query."
    },
    {
      "type": "p",
      "content": "similarity_search_by_vector(embedding[, k, ...])"
    },
    {
      "type": "p",
      "content": "Return docs most similar to embedding vector."
    },
    {
      "type": "p",
      "content": "similarity_search_with_relevance_scores(query)"
    },
    {
      "type": "p",
      "content": "Return docs and relevance scores in the range [0, 1]."
    },
    {
      "type": "p",
      "content": "similarity_search_with_score(query[, k, filter])"
    },
    {
      "type": "p",
      "content": "Run similarity search with distance."
    },
    {
      "type": "p",
      "content": "similarity_search_with_score_by_vector(embedding)"
    },
    {
      "type": "li",
      "content": "connection_string(str)"
    },
    {
      "type": "p",
      "content": "connection_string(str)"
    },
    {
      "type": "li",
      "content": "embedding_function(Embeddings)"
    },
    {
      "type": "p",
      "content": "embedding_function(Embeddings)"
    },
    {
      "type": "li",
      "content": "distance_strategy(DistanceStrategy)"
    },
    {
      "type": "p",
      "content": "distance_strategy(DistanceStrategy)"
    },
    {
      "type": "li",
      "content": "collection_name(str)"
    },
    {
      "type": "p",
      "content": "collection_name(str)"
    },
    {
      "type": "li",
      "content": "collection_metadata(Optional[dict])"
    },
    {
      "type": "p",
      "content": "collection_metadata(Optional[dict])"
    },
    {
      "type": "li",
      "content": "pre_delete_collection(bool)"
    },
    {
      "type": "p",
      "content": "pre_delete_collection(bool)"
    },
    {
      "type": "li",
      "content": "logger(Optional[logging.Logger])"
    },
    {
      "type": "p",
      "content": "logger(Optional[logging.Logger])"
    },
    {
      "type": "li",
      "content": "relevance_score_fn(Optional[Callable[[float],float]])"
    },
    {
      "type": "p",
      "content": "relevance_score_fn(Optional[Callable[[float],float]])"
    },
    {
      "type": "li",
      "content": "connection_string(str)"
    },
    {
      "type": "p",
      "content": "connection_string(str)"
    },
    {
      "type": "li",
      "content": "embedding_function(Embeddings)"
    },
    {
      "type": "p",
      "content": "embedding_function(Embeddings)"
    },
    {
      "type": "li",
      "content": "distance_strategy(DistanceStrategy)"
    },
    {
      "type": "p",
      "content": "distance_strategy(DistanceStrategy)"
    },
    {
      "type": "li",
      "content": "collection_name(str)"
    },
    {
      "type": "p",
      "content": "collection_name(str)"
    },
    {
      "type": "li",
      "content": "collection_metadata(dict|None)"
    },
    {
      "type": "p",
      "content": "collection_metadata(dict|None)"
    },
    {
      "type": "li",
      "content": "pre_delete_collection(bool)"
    },
    {
      "type": "p",
      "content": "pre_delete_collection(bool)"
    },
    {
      "type": "li",
      "content": "logger(Logger|None)"
    },
    {
      "type": "p",
      "content": "logger(Logger|None)"
    },
    {
      "type": "li",
      "content": "relevance_score_fn(Callable[[float],float]|None)"
    },
    {
      "type": "p",
      "content": "relevance_score_fn(Callable[[float],float]|None)"
    },
    {
      "type": "p",
      "content": "Async run more documents through the embeddings and add to the vectorstore."
    },
    {
      "type": "li",
      "content": "documents(list[Document]) – Documents to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "documents(list[Document]) – Documents to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "List of IDs of the added texts."
    },
    {
      "type": "p",
      "content": "Async run more texts through the embeddings and add to the vectorstore."
    },
    {
      "type": "li",
      "content": "texts(Iterable[str]) – Iterable of strings to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "texts(Iterable[str]) – Iterable of strings to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "metadatas(Optional[list[dict]]) – Optional list of metadatas associated with the texts.\nDefault is None."
    },
    {
      "type": "p",
      "content": "metadatas(Optional[list[dict]]) – Optional list of metadatas associated with the texts.\nDefault is None."
    },
    {
      "type": "li",
      "content": "ids(Optional[list[str]]) – Optional list"
    },
    {
      "type": "p",
      "content": "ids(Optional[list[str]]) – Optional list"
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – vectorstore specific parameters."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – vectorstore specific parameters."
    },
    {
      "type": "p",
      "content": "List of ids from adding the texts into the vectorstore."
    },
    {
      "type": "li",
      "content": "ValueError– If the number of metadatas does not match the number of texts."
    },
    {
      "type": "p",
      "content": "ValueError– If the number of metadatas does not match the number of texts."
    },
    {
      "type": "li",
      "content": "ValueError– If the number of ids does not match the number of texts."
    },
    {
      "type": "p",
      "content": "ValueError– If the number of ids does not match the number of texts."
    },
    {
      "type": "p",
      "content": "Add or update documents in the vectorstore."
    },
    {
      "type": "li",
      "content": "documents(list[Document]) – Documents to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "documents(list[Document]) – Documents to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments.\nif kwargs contains ids and documents contain ids,\nthe ids in the kwargs will receive precedence."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments.\nif kwargs contains ids and documents contain ids,\nthe ids in the kwargs will receive precedence."
    },
    {
      "type": "p",
      "content": "List of IDs of the added texts."
    },
    {
      "type": "li",
      "content": "texts(List[str])"
    },
    {
      "type": "p",
      "content": "texts(List[str])"
    },
    {
      "type": "li",
      "content": "embeddings(List[List[float]])"
    },
    {
      "type": "p",
      "content": "embeddings(List[List[float]])"
    },
    {
      "type": "li",
      "content": "metadatas(List[dict])"
    },
    {
      "type": "p",
      "content": "metadatas(List[dict])"
    },
    {
      "type": "li",
      "content": "ids(List[str])"
    },
    {
      "type": "p",
      "content": "ids(List[str])"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "Run more texts through the embeddings and add to the vectorstore."
    },
    {
      "type": "li",
      "content": "texts(Iterable[str]) – Iterable of strings to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "texts(Iterable[str]) – Iterable of strings to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "metadatas(List[dict]|None) – Optional list of metadatas associated with the texts."
    },
    {
      "type": "p",
      "content": "metadatas(List[dict]|None) – Optional list of metadatas associated with the texts."
    },
    {
      "type": "li",
      "content": "ids(List[str]|None) – Optional list of IDs associated with the texts."
    },
    {
      "type": "p",
      "content": "ids(List[str]|None) – Optional list of IDs associated with the texts."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – vectorstore specific parameters.\nOne of the kwargs should beidswhich is a list of ids\nassociated with the texts."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – vectorstore specific parameters.\nOne of the kwargs should beidswhich is a list of ids\nassociated with the texts."
    },
    {
      "type": "p",
      "content": "List of ids from adding the texts into the vectorstore."
    },
    {
      "type": "li",
      "content": "ValueError– If the number of metadatas does not match the number of texts."
    },
    {
      "type": "p",
      "content": "ValueError– If the number of metadatas does not match the number of texts."
    },
    {
      "type": "li",
      "content": "ValueError– If the number of ids does not match the number of texts."
    },
    {
      "type": "p",
      "content": "ValueError– If the number of ids does not match the number of texts."
    },
    {
      "type": "p",
      "content": "Async delete by vector ID or other criteria."
    },
    {
      "type": "li",
      "content": "ids(list[str]|None) – List of ids to delete. If None, delete all. Default is None."
    },
    {
      "type": "p",
      "content": "ids(list[str]|None) – List of ids to delete. If None, delete all. Default is None."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Other keyword arguments that subclasses might use."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Other keyword arguments that subclasses might use."
    },
    {
      "type": "p",
      "content": "True if deletion is successful,\nFalse otherwise, None if not implemented."
    },
    {
      "type": "p",
      "content": "Optional[bool]"
    },
    {
      "type": "p",
      "content": "Async return VectorStore initialized from documents and embeddings."
    },
    {
      "type": "li",
      "content": "documents(list[Document]) – List of Documents to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "documents(list[Document]) – List of Documents to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "p",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "VectorStore initialized from documents and embeddings."
    },
    {
      "type": "p",
      "content": "VectorStore"
    },
    {
      "type": "p",
      "content": "Async return VectorStore initialized from texts and embeddings."
    },
    {
      "type": "li",
      "content": "texts(list[str]) – Texts to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "texts(list[str]) – Texts to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "p",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "li",
      "content": "metadatas(list[dict]|None) – Optional list of metadatas associated with the texts.\nDefault is None."
    },
    {
      "type": "p",
      "content": "metadatas(list[dict]|None) – Optional list of metadatas associated with the texts.\nDefault is None."
    },
    {
      "type": "li",
      "content": "ids(list[str]|None) – Optional list of IDs associated with the texts."
    },
    {
      "type": "p",
      "content": "ids(list[str]|None) – Optional list of IDs associated with the texts."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "VectorStore initialized from texts and embeddings."
    },
    {
      "type": "p",
      "content": "VectorStore"
    },
    {
      "type": "p",
      "content": "Async get documents by their IDs."
    },
    {
      "type": "p",
      "content": "The returned documents are expected to have the ID field set to the ID of the\ndocument in the vector store."
    },
    {
      "type": "p",
      "content": "Fewer documents may be returned than requested if some IDs are not found or\nif there are duplicated IDs."
    },
    {
      "type": "p",
      "content": "Users should not assume that the order of the returned documents matches\nthe order of the input IDs. Instead, users should rely on the ID field of the\nreturned documents."
    },
    {
      "type": "p",
      "content": "This method shouldNOTraise exceptions if no documents are found for\nsome IDs."
    },
    {
      "type": "p",
      "content": "ids(Sequence[str]) – List of ids to retrieve."
    },
    {
      "type": "p",
      "content": "List of Documents."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Added in version 0.2.11."
    },
    {
      "type": "p",
      "content": "Async return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "Maximal marginal relevance optimizes for similarity to query AND diversity\namong selected documents."
    },
    {
      "type": "li",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "p",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Async return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "Maximal marginal relevance optimizes for similarity to query AND diversity\namong selected documents."
    },
    {
      "type": "li",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Return VectorStoreRetriever initialized from this VectorStore."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) –Keyword arguments to pass to the search function.\nCan include:\nsearch_type (Optional[str]): Defines the type of search thatthe Retriever should perform.\nCan be “similarity” (default), “mmr”, or\n“similarity_score_threshold”.search_kwargs (Optional[Dict]): Keyword arguments to pass to thesearch function. Can include things like:k: Amount of documents to return (Default: 4)\nscore_threshold: Minimum relevance thresholdfor similarity_score_thresholdfetch_k: Amount of documents to pass to MMR algorithm(Default: 20)lambda_mult: Diversity of results returned by MMR;1 for minimum diversity and 0 for maximum. (Default: 0.5)filter: Filter by document metadata"
    },
    {
      "type": "p",
      "content": "Keyword arguments to pass to the search function.\nCan include:\nsearch_type (Optional[str]): Defines the type of search that"
    },
    {
      "type": "p",
      "content": "the Retriever should perform.\nCan be “similarity” (default), “mmr”, or\n“similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "k: Amount of documents to return (Default: 4)\nscore_threshold: Minimum relevance threshold"
    },
    {
      "type": "p",
      "content": "for similarity_score_threshold"
    },
    {
      "type": "p",
      "content": "(Default: 20)"
    },
    {
      "type": "p",
      "content": "1 for minimum diversity and 0 for maximum. (Default: 0.5)"
    },
    {
      "type": "p",
      "content": "filter: Filter by document metadata"
    },
    {
      "type": "p",
      "content": "Retriever class for VectorStore."
    },
    {
      "type": "p",
      "content": "VectorStoreRetriever"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to query using a specified search type."
    },
    {
      "type": "li",
      "content": "query(str) – Input text."
    },
    {
      "type": "p",
      "content": "query(str) – Input text."
    },
    {
      "type": "li",
      "content": "search_type(str) – Type of search to perform. Can be “similarity”,\n“mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "search_type(str) – Type of search to perform. Can be “similarity”,\n“mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query."
    },
    {
      "type": "p",
      "content": "ValueError– If search_type is not one of “similarity”,\n    “mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to query."
    },
    {
      "type": "li",
      "content": "query(str) – Input text."
    },
    {
      "type": "p",
      "content": "query(str) – Input text."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to embedding vector."
    },
    {
      "type": "li",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query vector."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Async return docs and relevance scores in the range [0, 1]."
    },
    {
      "type": "p",
      "content": "0 is dissimilar, 1 is most similar."
    },
    {
      "type": "li",
      "content": "query(str) – Input text."
    },
    {
      "type": "p",
      "content": "query(str) – Input text."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) –kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 tofilter the resulting set of retrieved docs"
    },
    {
      "type": "p",
      "content": "**kwargs(Any) –kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 tofilter the resulting set of retrieved docs"
    },
    {
      "type": "p",
      "content": "kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 to"
    },
    {
      "type": "p",
      "content": "filter the resulting set of retrieved docs"
    },
    {
      "type": "p",
      "content": "List of Tuples of (doc, similarity_score)"
    },
    {
      "type": "p",
      "content": "list[tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Async run similarity search with distance."
    },
    {
      "type": "li",
      "content": "*args(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "*args(Any) – Arguments to pass to the search method."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Tuples of (doc, similarity_score)."
    },
    {
      "type": "p",
      "content": "list[tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Return connection string from database parameters."
    },
    {
      "type": "li",
      "content": "driver(str)"
    },
    {
      "type": "p",
      "content": "driver(str)"
    },
    {
      "type": "li",
      "content": "database(str)"
    },
    {
      "type": "p",
      "content": "database(str)"
    },
    {
      "type": "li",
      "content": "password(str)"
    },
    {
      "type": "p",
      "content": "password(str)"
    },
    {
      "type": "p",
      "content": "Create HNSW index on collection."
    },
    {
      "type": "p",
      "content": "engine: “nmslib”, “faiss”, “lucene”; default: “nmslib”"
    },
    {
      "type": "p",
      "content": "ef: Size of the dynamic list used during k-NN searches. Higher values\nlead to more accurate but slower searches; default: 64"
    },
    {
      "type": "p",
      "content": "ef_construction: Size of the dynamic list used during k-NN graph creation.\nHigher values lead to more accurate graph but slower indexing speed;\ndefault: 64"
    },
    {
      "type": "p",
      "content": "m: Number of bidirectional links created for each new element. Large impact\non memory consumption. Between 2 and 100; default: 16"
    },
    {
      "type": "p",
      "content": "dims: Dimensions of the vectors in collection. default: 1536"
    },
    {
      "type": "li",
      "content": "ef_construction(int)"
    },
    {
      "type": "p",
      "content": "ef_construction(int)"
    },
    {
      "type": "li",
      "content": "ef_search(int)"
    },
    {
      "type": "p",
      "content": "ef_search(int)"
    },
    {
      "type": "li",
      "content": "_kwargs(Any)"
    },
    {
      "type": "p",
      "content": "_kwargs(Any)"
    },
    {
      "type": "p",
      "content": "Delete vectors by ids or uuids."
    },
    {
      "type": "li",
      "content": "ids(List[str]|None) – List of ids to delete."
    },
    {
      "type": "p",
      "content": "ids(List[str]|None) – List of ids to delete."
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "Initialize a vector store with a set of documents."
    },
    {
      "type": "p",
      "content": "Postgres connection string is required\n“Either pass it asconnection_stringparameter\nor set the LANTERN_CONNECTION_STRING environment variable."
    },
    {
      "type": "li",
      "content": "connection_stringis a postgres connection string."
    },
    {
      "type": "p",
      "content": "connection_stringis a postgres connection string."
    },
    {
      "type": "li",
      "content": "documentsis list ofDocumentto initialize the vector store with"
    },
    {
      "type": "p",
      "content": "documentsis list ofDocumentto initialize the vector store with"
    },
    {
      "type": "li",
      "content": "embeddingisEmbeddingsthat will be used forembedding the text sent. If none is sent, then the\nmultilingual Tensorflow Universal Sentence Encoder will be used."
    },
    {
      "type": "p",
      "content": "embedding the text sent. If none is sent, then the\nmultilingual Tensorflow Universal Sentence Encoder will be used."
    },
    {
      "type": "li",
      "content": "collection_nameis the name of the collection to use. (default: langchain)NOTE: This is the name of the table in which embedding data will be storedThe table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "li",
      "content": "NOTE: This is the name of the table in which embedding data will be storedThe table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "p",
      "content": "The table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "li",
      "content": "distance_strategyis the distance strategy to use. (default: EUCLIDEAN)EUCLIDEANis the euclidean distance.COSINEis the cosine distance.HAMMINGis the hamming distance."
    },
    {
      "type": "li",
      "content": "EUCLIDEANis the euclidean distance."
    },
    {
      "type": "p",
      "content": "EUCLIDEANis the euclidean distance."
    },
    {
      "type": "li",
      "content": "COSINEis the cosine distance."
    },
    {
      "type": "p",
      "content": "COSINEis the cosine distance."
    },
    {
      "type": "li",
      "content": "HAMMINGis the hamming distance."
    },
    {
      "type": "p",
      "content": "HAMMINGis the hamming distance."
    },
    {
      "type": "li",
      "content": "idsrow ids to insert into collection."
    },
    {
      "type": "p",
      "content": "idsrow ids to insert into collection."
    },
    {
      "type": "li",
      "content": "pre_delete_collectionif True, will delete the collection if it exists.(default: False)\n- Useful for testing."
    },
    {
      "type": "p",
      "content": "(default: False)\n- Useful for testing."
    },
    {
      "type": "li",
      "content": "documents(List[Document])"
    },
    {
      "type": "p",
      "content": "documents(List[Document])"
    },
    {
      "type": "li",
      "content": "embedding(Embeddings)"
    },
    {
      "type": "p",
      "content": "embedding(Embeddings)"
    },
    {
      "type": "li",
      "content": "collection_name(str)"
    },
    {
      "type": "p",
      "content": "collection_name(str)"
    },
    {
      "type": "li",
      "content": "distance_strategy(DistanceStrategy)"
    },
    {
      "type": "p",
      "content": "distance_strategy(DistanceStrategy)"
    },
    {
      "type": "li",
      "content": "ids(List[str]|None)"
    },
    {
      "type": "p",
      "content": "ids(List[str]|None)"
    },
    {
      "type": "li",
      "content": "pre_delete_collection(bool)"
    },
    {
      "type": "p",
      "content": "pre_delete_collection(bool)"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "Construct Lantern wrapper from raw documents and pre-\ngenerated embeddings."
    },
    {
      "type": "p",
      "content": "Postgres connection string is required\n“Either pass it asconnection_stringparameter\nor set the LANTERN_CONNECTION_STRING environment variable."
    },
    {
      "type": "p",
      "content": "Order of elements for listsids,text_embeddings,metadatasshould match,\nso each row will be associated with correct values."
    },
    {
      "type": "li",
      "content": "connection_stringis fully populated connection string for postgres database"
    },
    {
      "type": "p",
      "content": "connection_stringis fully populated connection string for postgres database"
    },
    {
      "type": "li",
      "content": "text_embeddingsis array with tuples (text, embedding)to insert into collection."
    },
    {
      "type": "p",
      "content": "to insert into collection."
    },
    {
      "type": "li",
      "content": "embeddingisEmbeddingsthat will be used forembedding the text sent. If none is sent, then the\nmultilingual Tensorflow Universal Sentence Encoder will be used."
    },
    {
      "type": "p",
      "content": "embedding the text sent. If none is sent, then the\nmultilingual Tensorflow Universal Sentence Encoder will be used."
    },
    {
      "type": "li",
      "content": "metadatasrow metadata to insert into collection."
    },
    {
      "type": "p",
      "content": "metadatasrow metadata to insert into collection."
    },
    {
      "type": "li",
      "content": "collection_nameis the name of the collection to use. (default: langchain)NOTE: This is the name of the table in which embedding data will be storedThe table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "li",
      "content": "NOTE: This is the name of the table in which embedding data will be storedThe table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "p",
      "content": "The table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "li",
      "content": "idsrow ids to insert into collection."
    },
    {
      "type": "p",
      "content": "idsrow ids to insert into collection."
    },
    {
      "type": "li",
      "content": "pre_delete_collectionif True, will delete the collection if it exists.(default: False)\n- Useful for testing."
    },
    {
      "type": "p",
      "content": "(default: False)\n- Useful for testing."
    },
    {
      "type": "li",
      "content": "distance_strategyis the distance strategy to use. (default: EUCLIDEAN)EUCLIDEANis the euclidean distance.COSINEis the cosine distance.HAMMINGis the hamming distance."
    },
    {
      "type": "li",
      "content": "EUCLIDEANis the euclidean distance."
    },
    {
      "type": "p",
      "content": "EUCLIDEANis the euclidean distance."
    },
    {
      "type": "li",
      "content": "COSINEis the cosine distance."
    },
    {
      "type": "p",
      "content": "COSINEis the cosine distance."
    },
    {
      "type": "li",
      "content": "HAMMINGis the hamming distance."
    },
    {
      "type": "p",
      "content": "HAMMINGis the hamming distance."
    },
    {
      "type": "li",
      "content": "text_embeddings(List[Tuple[str,List[float]]])"
    },
    {
      "type": "p",
      "content": "text_embeddings(List[Tuple[str,List[float]]])"
    },
    {
      "type": "li",
      "content": "embedding(Embeddings)"
    },
    {
      "type": "p",
      "content": "embedding(Embeddings)"
    },
    {
      "type": "li",
      "content": "metadatas(List[dict]|None)"
    },
    {
      "type": "p",
      "content": "metadatas(List[dict]|None)"
    },
    {
      "type": "li",
      "content": "collection_name(str)"
    },
    {
      "type": "p",
      "content": "collection_name(str)"
    },
    {
      "type": "li",
      "content": "ids(List[str]|None)"
    },
    {
      "type": "p",
      "content": "ids(List[str]|None)"
    },
    {
      "type": "li",
      "content": "pre_delete_collection(bool)"
    },
    {
      "type": "p",
      "content": "pre_delete_collection(bool)"
    },
    {
      "type": "li",
      "content": "distance_strategy(DistanceStrategy)"
    },
    {
      "type": "p",
      "content": "distance_strategy(DistanceStrategy)"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "Get instance of an existing Lantern store.This method will\nreturn the instance of the store without inserting any new\nembeddings"
    },
    {
      "type": "p",
      "content": "Postgres connection string is required\n“Either pass it asconnection_stringparameter\nor set the LANTERN_CONNECTION_STRING environment variable."
    },
    {
      "type": "li",
      "content": "connection_stringis a postgres connection string."
    },
    {
      "type": "p",
      "content": "connection_stringis a postgres connection string."
    },
    {
      "type": "li",
      "content": "embeddingisEmbeddingsthat will be used forembedding the text sent. If none is sent, then the\nmultilingual Tensorflow Universal Sentence Encoder will be used."
    },
    {
      "type": "p",
      "content": "embedding the text sent. If none is sent, then the\nmultilingual Tensorflow Universal Sentence Encoder will be used."
    },
    {
      "type": "li",
      "content": "collection_nameis the name of the collection to use. (default: langchain)NOTE: This is the name of the table in which embedding data will be storedThe table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "li",
      "content": "NOTE: This is the name of the table in which embedding data will be storedThe table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "p",
      "content": "The table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "li",
      "content": "idsrow ids to insert into collection."
    },
    {
      "type": "p",
      "content": "idsrow ids to insert into collection."
    },
    {
      "type": "li",
      "content": "pre_delete_collectionif True, will delete the collection if it exists.(default: False)\n- Useful for testing."
    },
    {
      "type": "p",
      "content": "(default: False)\n- Useful for testing."
    },
    {
      "type": "li",
      "content": "distance_strategyis the distance strategy to use. (default: EUCLIDEAN)EUCLIDEANis the euclidean distance.COSINEis the cosine distance.HAMMINGis the hamming distance."
    },
    {
      "type": "li",
      "content": "EUCLIDEANis the euclidean distance."
    },
    {
      "type": "p",
      "content": "EUCLIDEANis the euclidean distance."
    },
    {
      "type": "li",
      "content": "COSINEis the cosine distance."
    },
    {
      "type": "p",
      "content": "COSINEis the cosine distance."
    },
    {
      "type": "li",
      "content": "HAMMINGis the hamming distance."
    },
    {
      "type": "p",
      "content": "HAMMINGis the hamming distance."
    },
    {
      "type": "li",
      "content": "embedding(Embeddings)"
    },
    {
      "type": "p",
      "content": "embedding(Embeddings)"
    },
    {
      "type": "li",
      "content": "collection_name(str)"
    },
    {
      "type": "p",
      "content": "collection_name(str)"
    },
    {
      "type": "li",
      "content": "pre_delete_collection(bool)"
    },
    {
      "type": "p",
      "content": "pre_delete_collection(bool)"
    },
    {
      "type": "li",
      "content": "distance_strategy(DistanceStrategy)"
    },
    {
      "type": "p",
      "content": "distance_strategy(DistanceStrategy)"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "Initialize Lantern vectorstore from list of texts.\nThe embeddings will be generated usingembeddingclass provided."
    },
    {
      "type": "p",
      "content": "Order of elements for listsids,texts,metadatasshould match,\nso each row will be associated with correct values."
    },
    {
      "type": "p",
      "content": "Postgres connection string is required\n“Either pass it asconnection_stringparameter\nor set the LANTERN_CONNECTION_STRING environment variable."
    },
    {
      "type": "li",
      "content": "connection_stringis fully populated connection string for postgres database"
    },
    {
      "type": "p",
      "content": "connection_stringis fully populated connection string for postgres database"
    },
    {
      "type": "li",
      "content": "textstexts to insert into collection."
    },
    {
      "type": "p",
      "content": "textstexts to insert into collection."
    },
    {
      "type": "li",
      "content": "embeddingisEmbeddingsthat will be used forembedding the text sent. If none is sent, then the\nmultilingual Tensorflow Universal Sentence Encoder will be used."
    },
    {
      "type": "p",
      "content": "embedding the text sent. If none is sent, then the\nmultilingual Tensorflow Universal Sentence Encoder will be used."
    },
    {
      "type": "li",
      "content": "metadatasrow metadata to insert into collection."
    },
    {
      "type": "p",
      "content": "metadatasrow metadata to insert into collection."
    },
    {
      "type": "li",
      "content": "collection_nameis the name of the collection to use. (default: langchain)NOTE: This is the name of the table in which embedding data will be storedThe table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "li",
      "content": "NOTE: This is the name of the table in which embedding data will be storedThe table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "p",
      "content": "The table will be created when initializing the store (if not exists)\nSo, make sure the user has the right permissions to create tables."
    },
    {
      "type": "li",
      "content": "distance_strategyis the distance strategy to use. (default: EUCLIDEAN)EUCLIDEANis the euclidean distance.COSINEis the cosine distance.HAMMINGis the hamming distance."
    },
    {
      "type": "li",
      "content": "EUCLIDEANis the euclidean distance."
    },
    {
      "type": "p",
      "content": "EUCLIDEANis the euclidean distance."
    },
    {
      "type": "li",
      "content": "COSINEis the cosine distance."
    },
    {
      "type": "p",
      "content": "COSINEis the cosine distance."
    },
    {
      "type": "li",
      "content": "HAMMINGis the hamming distance."
    },
    {
      "type": "p",
      "content": "HAMMINGis the hamming distance."
    },
    {
      "type": "li",
      "content": "idsrow ids to insert into collection."
    },
    {
      "type": "p",
      "content": "idsrow ids to insert into collection."
    },
    {
      "type": "li",
      "content": "pre_delete_collectionif True, will delete the collection if it exists.(default: False)\n- Useful for testing."
    },
    {
      "type": "p",
      "content": "(default: False)\n- Useful for testing."
    },
    {
      "type": "li",
      "content": "texts(List[str])"
    },
    {
      "type": "p",
      "content": "texts(List[str])"
    },
    {
      "type": "li",
      "content": "embedding(Embeddings)"
    },
    {
      "type": "p",
      "content": "embedding(Embeddings)"
    },
    {
      "type": "li",
      "content": "metadatas(List[dict]|None)"
    },
    {
      "type": "p",
      "content": "metadatas(List[dict]|None)"
    },
    {
      "type": "li",
      "content": "collection_name(str)"
    },
    {
      "type": "p",
      "content": "collection_name(str)"
    },
    {
      "type": "li",
      "content": "distance_strategy(DistanceStrategy)"
    },
    {
      "type": "p",
      "content": "distance_strategy(DistanceStrategy)"
    },
    {
      "type": "li",
      "content": "ids(List[str]|None)"
    },
    {
      "type": "p",
      "content": "ids(List[str]|None)"
    },
    {
      "type": "li",
      "content": "pre_delete_collection(bool)"
    },
    {
      "type": "p",
      "content": "pre_delete_collection(bool)"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "Get documents by their IDs."
    },
    {
      "type": "p",
      "content": "The returned documents are expected to have the ID field set to the ID of the\ndocument in the vector store."
    },
    {
      "type": "p",
      "content": "Fewer documents may be returned than requested if some IDs are not found or\nif there are duplicated IDs."
    },
    {
      "type": "p",
      "content": "Users should not assume that the order of the returned documents matches\nthe order of the input IDs. Instead, users should rely on the ID field of the\nreturned documents."
    },
    {
      "type": "p",
      "content": "This method shouldNOTraise exceptions if no documents are found for\nsome IDs."
    },
    {
      "type": "p",
      "content": "ids(Sequence[str]) – List of ids to retrieve."
    },
    {
      "type": "p",
      "content": "List of Documents."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Added in version 0.2.11."
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "among selected documents."
    },
    {
      "type": "li",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "p",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefaults to 20."
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefaults to 20."
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "filter(Optional[Dict[str,str]]) – Filter by metadata. Defaults to None."
    },
    {
      "type": "p",
      "content": "filter(Optional[Dict[str,str]]) – Filter by metadata. Defaults to None."
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "List[Document]"
    },
    {
      "type": "p",
      "content": "to embedding vector."
    },
    {
      "type": "p",
      "content": "among selected documents."
    },
    {
      "type": "li",
      "content": "embedding(str) – Text to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(str) – Text to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefaults to 20."
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefaults to 20."
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "filter(Optional[Dict[str,str]]) – Filter by metadata. Defaults to None."
    },
    {
      "type": "p",
      "content": "filter(Optional[Dict[str,str]]) – Filter by metadata. Defaults to None."
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "List[Document]"
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance with score."
    },
    {
      "type": "p",
      "content": "among selected documents."
    },
    {
      "type": "li",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "p",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefaults to 20."
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefaults to 20."
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "filter(Optional[Dict[str,str]]) – Filter by metadata. Defaults to None."
    },
    {
      "type": "p",
      "content": "filter(Optional[Dict[str,str]]) – Filter by metadata. Defaults to None."
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginalrelevance to the query and score for each."
    },
    {
      "type": "p",
      "content": "relevance to the query and score for each."
    },
    {
      "type": "p",
      "content": "List[Tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "to embedding vector."
    },
    {
      "type": "p",
      "content": "among selected documents."
    },
    {
      "type": "li",
      "content": "embedding(List[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(List[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefaults to 20."
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefaults to 20."
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "filter(Optional[Dict[str,str]]) – Filter by metadata. Defaults to None."
    },
    {
      "type": "p",
      "content": "filter(Optional[Dict[str,str]]) – Filter by metadata. Defaults to None."
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginalrelevance to the query and score for each."
    },
    {
      "type": "p",
      "content": "relevance to the query and score for each."
    },
    {
      "type": "p",
      "content": "List[Tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Return docs most similar to query using a specified search type."
    },
    {
      "type": "li",
      "content": "query(str) – Input text"
    },
    {
      "type": "p",
      "content": "query(str) – Input text"
    },
    {
      "type": "li",
      "content": "search_type(str) – Type of search to perform. Can be “similarity”,\n“mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "search_type(str) – Type of search to perform. Can be “similarity”,\n“mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query."
    },
    {
      "type": "p",
      "content": "ValueError– If search_type is not one of “similarity”,\n    “mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Return docs most similar to query."
    },
    {
      "type": "li",
      "content": "query(str) – Input text."
    },
    {
      "type": "p",
      "content": "query(str) – Input text."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "li",
      "content": "filter(dict|None)"
    },
    {
      "type": "p",
      "content": "filter(dict|None)"
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query."
    },
    {
      "type": "p",
      "content": "List[Document]"
    },
    {
      "type": "p",
      "content": "Return docs most similar to embedding vector."
    },
    {
      "type": "li",
      "content": "embedding(List[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(List[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "li",
      "content": "filter(dict|None)"
    },
    {
      "type": "p",
      "content": "filter(dict|None)"
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query vector."
    },
    {
      "type": "p",
      "content": "List[Document]"
    },
    {
      "type": "p",
      "content": "Return docs and relevance scores in the range [0, 1]."
    },
    {
      "type": "p",
      "content": "0 is dissimilar, 1 is most similar."
    },
    {
      "type": "li",
      "content": "query(str) – Input text."
    },
    {
      "type": "p",
      "content": "query(str) – Input text."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) –kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 tofilter the resulting set of retrieved docs."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) –kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 tofilter the resulting set of retrieved docs."
    },
    {
      "type": "p",
      "content": "kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 to"
    },
    {
      "type": "p",
      "content": "filter the resulting set of retrieved docs."
    },
    {
      "type": "p",
      "content": "List of Tuples of (doc, similarity_score)."
    },
    {
      "type": "p",
      "content": "list[tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Run similarity search with distance."
    },
    {
      "type": "li",
      "content": "*args– Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "*args– Arguments to pass to the search method."
    },
    {
      "type": "li",
      "content": "**kwargs– Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs– Arguments to pass to the search method."
    },
    {
      "type": "li",
      "content": "filter(dict|None)"
    },
    {
      "type": "p",
      "content": "filter(dict|None)"
    },
    {
      "type": "p",
      "content": "List of Tuples of (doc, similarity_score)."
    },
    {
      "type": "p",
      "content": "List[Tuple[Document, float]]"
    },
    {
      "type": "li",
      "content": "embedding(List[float])"
    },
    {
      "type": "p",
      "content": "embedding(List[float])"
    },
    {
      "type": "li",
      "content": "filter(dict|None)"
    },
    {
      "type": "p",
      "content": "filter(dict|None)"
    },
    {
      "type": "p",
      "content": "List[Tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Examples using Lantern"
    },
    {
      "type": "li",
      "content": "Lantern__init__()aadd_documents()aadd_texts()add_documents()add_embeddings()add_texts()adelete()afrom_documents()afrom_texts()aget_by_ids()amax_marginal_relevance_search()amax_marginal_relevance_search_by_vector()as_retriever()asearch()asimilarity_search()asimilarity_search_by_vector()asimilarity_search_with_relevance_scores()asimilarity_search_with_score()connect()connection_string_from_db_params()create_collection()create_hnsw_extension()create_hnsw_index()create_tables_if_not_exists()delete()delete_collection()drop_index()drop_table()drop_tables()from_documents()from_embeddings()from_existing_index()from_texts()get_by_ids()max_marginal_relevance_search()max_marginal_relevance_search_by_vector()max_marginal_relevance_search_with_score()max_marginal_relevance_search_with_score_by_vector()search()similarity_search()similarity_search_by_vector()similarity_search_with_relevance_scores()similarity_search_with_score()similarity_search_with_score_by_vector()"
    },
    {
      "type": "li",
      "content": "aadd_documents()"
    },
    {
      "type": "li",
      "content": "aadd_texts()"
    },
    {
      "type": "li",
      "content": "add_documents()"
    },
    {
      "type": "li",
      "content": "add_embeddings()"
    },
    {
      "type": "li",
      "content": "add_texts()"
    },
    {
      "type": "li",
      "content": "afrom_documents()"
    },
    {
      "type": "li",
      "content": "afrom_texts()"
    },
    {
      "type": "li",
      "content": "aget_by_ids()"
    },
    {
      "type": "li",
      "content": "amax_marginal_relevance_search()"
    },
    {
      "type": "li",
      "content": "amax_marginal_relevance_search_by_vector()"
    },
    {
      "type": "li",
      "content": "as_retriever()"
    },
    {
      "type": "li",
      "content": "asimilarity_search()"
    },
    {
      "type": "li",
      "content": "asimilarity_search_by_vector()"
    },
    {
      "type": "li",
      "content": "asimilarity_search_with_relevance_scores()"
    },
    {
      "type": "li",
      "content": "asimilarity_search_with_score()"
    },
    {
      "type": "li",
      "content": "connection_string_from_db_params()"
    },
    {
      "type": "li",
      "content": "create_collection()"
    },
    {
      "type": "li",
      "content": "create_hnsw_extension()"
    },
    {
      "type": "li",
      "content": "create_hnsw_index()"
    },
    {
      "type": "li",
      "content": "create_tables_if_not_exists()"
    },
    {
      "type": "li",
      "content": "delete_collection()"
    },
    {
      "type": "li",
      "content": "drop_index()"
    },
    {
      "type": "li",
      "content": "drop_table()"
    },
    {
      "type": "li",
      "content": "drop_tables()"
    },
    {
      "type": "li",
      "content": "from_documents()"
    },
    {
      "type": "li",
      "content": "from_embeddings()"
    },
    {
      "type": "li",
      "content": "from_existing_index()"
    },
    {
      "type": "li",
      "content": "from_texts()"
    },
    {
      "type": "li",
      "content": "get_by_ids()"
    },
    {
      "type": "li",
      "content": "max_marginal_relevance_search()"
    },
    {
      "type": "li",
      "content": "max_marginal_relevance_search_by_vector()"
    },
    {
      "type": "li",
      "content": "max_marginal_relevance_search_with_score()"
    },
    {
      "type": "li",
      "content": "max_marginal_relevance_search_with_score_by_vector()"
    },
    {
      "type": "li",
      "content": "similarity_search()"
    },
    {
      "type": "li",
      "content": "similarity_search_by_vector()"
    },
    {
      "type": "li",
      "content": "similarity_search_with_relevance_scores()"
    },
    {
      "type": "li",
      "content": "similarity_search_with_score()"
    },
    {
      "type": "li",
      "content": "similarity_search_with_score_by_vector()"
    }
  ],
  "code_examples": [
    "vectorstores",
    "distance_function",
    "distance_strategy",
    "embeddings",
    "__init__",
    "aadd_documents",
    "aadd_texts",
    "add_documents",
    "add_embeddings",
    "add_texts",
    "adelete",
    "afrom_documents",
    "afrom_texts",
    "aget_by_ids",
    "amax_marginal_relevance_search",
    "amax_marginal_relevance_search_by_vector",
    "as_retriever",
    "asearch",
    "asimilarity_search",
    "asimilarity_search_by_vector",
    "asimilarity_search_with_relevance_scores",
    "asimilarity_search_with_score",
    "connect",
    "connection_string_from_db_params",
    "create_collection",
    "create_hnsw_extension",
    "create_hnsw_index",
    "create_tables_if_not_exists",
    "delete",
    "delete_collection",
    "drop_index",
    "drop_table",
    "drop_tables",
    "from_documents",
    "from_embeddings",
    "from_existing_index",
    "from_texts",
    "get_by_ids",
    "max_marginal_relevance_search",
    "max_marginal_relevance_search_by_vector",
    "max_marginal_relevance_search_with_score",
    "max_marginal_relevance_search_with_score_by_vector",
    "search",
    "similarity_search",
    "similarity_search_by_vector",
    "similarity_search_with_relevance_scores",
    "similarity_search_with_score",
    "similarity_search_with_score_by_vector",
    "# Retrieve more documents with higher diversity# Useful if your dataset has many similar documentsdocsearch.as_retriever(search_type=\"mmr\",search_kwargs={\"k\":6,\"lambda_mult\":0.25})# Fetch more documents for the MMR algorithm to consider# But only return the top 5docsearch.as_retriever(search_type=\"mmr\",search_kwargs={\"k\":5,\"fetch_k\":50})# Only retrieve documents that have a relevance score# Above a certain thresholddocsearch.as_retriever(search_type=\"similarity_score_threshold\",search_kwargs={\"score_threshold\":0.8},)# Only get the single most similar document from the datasetdocsearch.as_retriever(search_kwargs={\"k\":1})# Use a filter to only retrieve documents from a specific paperdocsearch.as_retriever(search_kwargs={\"filter\":{\"paper_title\":\"GPT-4 Technical Report\"}})",
    "Document",
    "Embeddings",
    "Embeddings",
    "Embeddings",
    "Embeddings",
    "Lantern",
    "__init__()",
    "aadd_documents()",
    "aadd_texts()",
    "add_documents()",
    "add_embeddings()",
    "add_texts()",
    "adelete()",
    "afrom_documents()",
    "afrom_texts()",
    "aget_by_ids()",
    "amax_marginal_relevance_search()",
    "amax_marginal_relevance_search_by_vector()",
    "as_retriever()",
    "asearch()",
    "asimilarity_search()",
    "asimilarity_search_by_vector()",
    "asimilarity_search_with_relevance_scores()",
    "asimilarity_search_with_score()",
    "connect()",
    "connection_string_from_db_params()",
    "create_collection()",
    "create_hnsw_extension()",
    "create_hnsw_index()",
    "create_tables_if_not_exists()",
    "delete()",
    "delete_collection()",
    "drop_index()",
    "drop_table()",
    "drop_tables()",
    "from_documents()",
    "from_embeddings()",
    "from_existing_index()",
    "from_texts()",
    "get_by_ids()",
    "max_marginal_relevance_search()",
    "max_marginal_relevance_search_by_vector()",
    "max_marginal_relevance_search_with_score()",
    "max_marginal_relevance_search_with_score_by_vector()",
    "search()",
    "similarity_search()",
    "similarity_search_by_vector()",
    "similarity_search_with_relevance_scores()",
    "similarity_search_with_score()",
    "similarity_search_with_score_by_vector()"
  ],
  "api_signatures": [
    "classlangchain_community.vectorstores.lantern.Lantern(connection_string:str,embedding_function:Embeddings,distance_strategy:DistanceStrategy=DistanceStrategy.COSINE,collection_name:str='langchain',collection_metadata:dict|None=None,pre_delete_collection:bool=False,logger:Logger|None=None,relevance_score_fn:Callable[[float],float]|None=None,)[source]#",
    "langchain_community.vectorstores.lantern.",
    "Lantern",
    "(",
    "connection_string:str",
    "embedding_function:Embeddings",
    "distance_strategy:DistanceStrategy=DistanceStrategy.COSINE",
    "collection_name:str='langchain'",
    "collection_metadata:dict|None=None",
    "pre_delete_collection:bool=False",
    "logger:Logger|None=None",
    "relevance_score_fn:Callable[[float],float]|None=None",
    ")",
    "__init__(connection_string:str,embedding_function:Embeddings,distance_strategy:DistanceStrategy=DistanceStrategy.COSINE,collection_name:str='langchain',collection_metadata:dict|None=None,pre_delete_collection:bool=False,logger:Logger|None=None,relevance_score_fn:Callable[[float],float]|None=None,)→None[source]#",
    "__init__",
    "(",
    "connection_string:str",
    "embedding_function:Embeddings",
    "distance_strategy:DistanceStrategy=DistanceStrategy.COSINE",
    "collection_name:str='langchain'",
    "collection_metadata:dict|None=None",
    "pre_delete_collection:bool=False",
    "logger:Logger|None=None",
    "relevance_score_fn:Callable[[float],float]|None=None",
    ")",
    "→None",
    "→",
    "None",
    "asyncaadd_documents(documents:list[Document],**kwargs:Any,)→list[str]#",
    "aadd_documents",
    "(",
    "documents:list[Document]",
    "**kwargs:Any",
    ")",
    "→list[str]",
    "→",
    "list[str]",
    "asyncaadd_texts(texts:Iterable[str],metadatas:list[dict]|None=None,*,ids:list[str]|None=None,**kwargs:Any,)→list[str]#",
    "aadd_texts",
    "(",
    "texts:Iterable[str]",
    "metadatas:list[dict]|None=None",
    "*",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    ")",
    "→list[str]",
    "→",
    "list[str]",
    "add_documents(documents:list[Document],**kwargs:Any,)→list[str]#",
    "add_documents",
    "(",
    "documents:list[Document]",
    "**kwargs:Any",
    ")",
    "→list[str]",
    "→",
    "list[str]",
    "add_embeddings(texts:List[str],embeddings:List[List[float]],metadatas:List[dict],ids:List[str],**kwargs:Any,)→None[source]#",
    "add_embeddings",
    "(",
    "texts:List[str]",
    "embeddings:List[List[float]]",
    "metadatas:List[dict]",
    "ids:List[str]",
    "**kwargs:Any",
    ")",
    "→None",
    "→",
    "None",
    "add_texts(texts:Iterable[str],metadatas:List[dict]|None=None,ids:List[str]|None=None,**kwargs:Any,)→List[str][source]#",
    "add_texts",
    "(",
    "texts:Iterable[str]",
    "metadatas:List[dict]|None=None",
    "ids:List[str]|None=None",
    "**kwargs:Any",
    ")",
    "→List[str]",
    "→",
    "List[str]",
    "asyncadelete(ids:list[str]|None=None,**kwargs:Any,)→bool|None#",
    "adelete",
    "(",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    ")",
    "→bool|None",
    "→",
    "bool|None",
    "asyncclassmethodafrom_documents(documents:list[Document],embedding:Embeddings,**kwargs:Any,)→Self#",
    "afrom_documents",
    "(",
    "documents:list[Document]",
    "embedding:Embeddings",
    "**kwargs:Any",
    ")",
    "→Self",
    "→",
    "Self",
    "asyncclassmethodafrom_texts(texts:list[str],embedding:Embeddings,metadatas:list[dict]|None=None,*,ids:list[str]|None=None,**kwargs:Any,)→Self#",
    "afrom_texts",
    "(",
    "texts:list[str]",
    "embedding:Embeddings",
    "metadatas:list[dict]|None=None",
    "*",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    ")",
    "→Self",
    "→",
    "Self",
    "asyncaget_by_ids(ids:Sequence[str],/)→list[Document]#",
    "aget_by_ids",
    "(",
    "ids:Sequence[str]",
    "/",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncamax_marginal_relevance_search(query:str,k:int=4,fetch_k:int=20,lambda_mult:float=0.5,**kwargs:Any,)→list[Document]#",
    "amax_marginal_relevance_search",
    "(",
    "query:str",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncamax_marginal_relevance_search_by_vector(embedding:list[float],k:int=4,fetch_k:int=20,lambda_mult:float=0.5,**kwargs:Any,)→list[Document]#",
    "amax_marginal_relevance_search_by_vector",
    "(",
    "embedding:list[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "as_retriever(**kwargs:Any,)→VectorStoreRetriever#",
    "as_retriever",
    "(",
    "**kwargs:Any",
    ")",
    "→VectorStoreRetriever",
    "→",
    "VectorStoreRetriever",
    "asyncasearch(query:str,search_type:str,**kwargs:Any,)→list[Document]#",
    "asearch",
    "(",
    "query:str",
    "search_type:str",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncasimilarity_search(query:str,k:int=4,**kwargs:Any,)→list[Document]#",
    "asimilarity_search",
    "(",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncasimilarity_search_by_vector(embedding:list[float],k:int=4,**kwargs:Any,)→list[Document]#",
    "asimilarity_search_by_vector",
    "(",
    "embedding:list[float]",
    "k:int=4",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncasimilarity_search_with_relevance_scores(query:str,k:int=4,**kwargs:Any,)→list[tuple[Document,float]]#",
    "asimilarity_search_with_relevance_scores",
    "(",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    ")",
    "→list[tuple[Document,float]]",
    "→",
    "list[tuple[Document,float]]",
    "asyncasimilarity_search_with_score(*args:Any,**kwargs:Any,)→list[tuple[Document,float]]#",
    "asimilarity_search_with_score",
    "(",
    "*args:Any",
    "**kwargs:Any",
    ")",
    "→list[tuple[Document,float]]",
    "→",
    "list[tuple[Document,float]]",
    "connect()→Connection[source]#",
    "connect",
    "(",
    ")",
    "→Connection",
    "→",
    "Connection",
    "classmethodconnection_string_from_db_params(driver:str,host:str,port:int,database:str,user:str,password:str,)→str[source]#",
    "connection_string_from_db_params",
    "(",
    "driver:str",
    "host:str",
    "port:int",
    "database:str",
    "user:str",
    "password:str",
    ")",
    "→str",
    "→",
    "str",
    "create_collection()→None[source]#",
    "create_collection",
    "(",
    ")",
    "→None",
    "→",
    "None",
    "create_hnsw_extension()→None[source]#",
    "create_hnsw_extension",
    "(",
    ")",
    "→None",
    "→",
    "None",
    "create_hnsw_index(dims:int=1536,m:int=16,ef_construction:int=64,ef_search:int=64,**_kwargs:Any,)→None[source]#",
    "create_hnsw_index",
    "(",
    "dims:int=1536",
    "m:int=16",
    "ef_construction:int=64",
    "ef_search:int=64",
    "**_kwargs:Any",
    ")",
    "→None",
    "→",
    "None",
    "create_tables_if_not_exists()→None[source]#",
    "create_tables_if_not_exists",
    "(",
    ")",
    "→None",
    "→",
    "None",
    "delete(ids:List[str]|None=None,**kwargs:Any,)→None[source]#",
    "delete",
    "(",
    "ids:List[str]|None=None",
    "**kwargs:Any",
    ")",
    "→None",
    "→",
    "None",
    "delete_collection()→None[source]#",
    "delete_collection",
    "(",
    ")",
    "→None",
    "→",
    "None",
    "drop_index()→None[source]#",
    "drop_index",
    "(",
    ")",
    "→None",
    "→",
    "None",
    "drop_table()→None[source]#",
    "drop_table",
    "(",
    ")",
    "→None",
    "→",
    "None",
    "drop_tables()→None[source]#",
    "drop_tables",
    "(",
    ")",
    "→None",
    "→",
    "None",
    "classmethodfrom_documents(documents:List[Document],embedding:Embeddings,collection_name:str='langchain',distance_strategy:DistanceStrategy=DistanceStrategy.COSINE,ids:List[str]|None=None,pre_delete_collection:bool=False,**kwargs:Any,)→Lantern[source]#",
    "from_documents",
    "(",
    "documents:List[Document]",
    "embedding:Embeddings",
    "collection_name:str='langchain'",
    "distance_strategy:DistanceStrategy=DistanceStrategy.COSINE",
    "ids:List[str]|None=None",
    "pre_delete_collection:bool=False",
    "**kwargs:Any",
    ")",
    "→Lantern",
    "→",
    "Lantern",
    "classmethodfrom_embeddings(text_embeddings:List[Tuple[str,List[float]]],embedding:Embeddings,metadatas:List[dict]|None=None,collection_name:str='langchain',ids:List[str]|None=None,pre_delete_collection:bool=False,distance_strategy:DistanceStrategy=DistanceStrategy.COSINE,**kwargs:Any,)→Lantern[source]#",
    "from_embeddings",
    "(",
    "text_embeddings:List[Tuple[str,List[float]]]",
    "embedding:Embeddings",
    "metadatas:List[dict]|None=None",
    "collection_name:str='langchain'",
    "ids:List[str]|None=None",
    "pre_delete_collection:bool=False",
    "distance_strategy:DistanceStrategy=DistanceStrategy.COSINE",
    "**kwargs:Any",
    ")",
    "→Lantern",
    "→",
    "Lantern",
    "classmethodfrom_existing_index(embedding:Embeddings,collection_name:str='langchain',pre_delete_collection:bool=False,distance_strategy:DistanceStrategy=DistanceStrategy.COSINE,**kwargs:Any,)→Lantern[source]#",
    "from_existing_index",
    "(",
    "embedding:Embeddings",
    "collection_name:str='langchain'",
    "pre_delete_collection:bool=False",
    "distance_strategy:DistanceStrategy=DistanceStrategy.COSINE",
    "**kwargs:Any",
    ")",
    "→Lantern",
    "→",
    "Lantern",
    "classmethodfrom_texts(texts:List[str],embedding:Embeddings,metadatas:List[dict]|None=None,collection_name:str='langchain',distance_strategy:DistanceStrategy=DistanceStrategy.COSINE,ids:List[str]|None=None,pre_delete_collection:bool=False,**kwargs:Any,)→Lantern[source]#",
    "from_texts",
    "(",
    "texts:List[str]",
    "embedding:Embeddings",
    "metadatas:List[dict]|None=None",
    "collection_name:str='langchain'",
    "distance_strategy:DistanceStrategy=DistanceStrategy.COSINE",
    "ids:List[str]|None=None",
    "pre_delete_collection:bool=False",
    "**kwargs:Any",
    ")",
    "→Lantern",
    "→",
    "Lantern",
    "get_by_ids(ids:Sequence[str],/)→list[Document]#",
    "get_by_ids",
    "(",
    "ids:Sequence[str]",
    "/",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "max_marginal_relevance_search(query:str,k:int=4,fetch_k:int=20,lambda_mult:float=0.5,filter:Dict[str,str]|None=None,**kwargs:Any,)→List[Document][source]#",
    "max_marginal_relevance_search",
    "(",
    "query:str",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "filter:Dict[str,str]|None=None",
    "**kwargs:Any",
    ")",
    "→List[Document]",
    "→",
    "List[Document]",
    "max_marginal_relevance_search_by_vector(embedding:List[float],k:int=4,fetch_k:int=20,lambda_mult:float=0.5,filter:Dict[str,str]|None=None,**kwargs:Any,)→List[Document][source]#",
    "max_marginal_relevance_search_by_vector",
    "(",
    "embedding:List[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "filter:Dict[str,str]|None=None",
    "**kwargs:Any",
    ")",
    "→List[Document]",
    "→",
    "List[Document]",
    "max_marginal_relevance_search_with_score(query:str,k:int=4,fetch_k:int=20,lambda_mult:float=0.5,filter:dict|None=None,**kwargs:Any,)→List[Tuple[Document,float]][source]#",
    "max_marginal_relevance_search_with_score",
    "(",
    "query:str",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "filter:dict|None=None",
    "**kwargs:Any",
    ")",
    "→List[Tuple[Document,float]]",
    "→",
    "List[Tuple[Document,float]]",
    "max_marginal_relevance_search_with_score_by_vector(embedding:List[float],k:int=4,fetch_k:int=20,lambda_mult:float=0.5,filter:Dict[str,str]|None=None,**kwargs:Any,)→List[Tuple[Document,float]][source]#",
    "max_marginal_relevance_search_with_score_by_vector",
    "(",
    "embedding:List[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "filter:Dict[str,str]|None=None",
    "**kwargs:Any",
    ")",
    "→List[Tuple[Document,float]]",
    "→",
    "List[Tuple[Document,float]]",
    "search(query:str,search_type:str,**kwargs:Any,)→list[Document]#",
    "search",
    "(",
    "query:str",
    "search_type:str",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "similarity_search(query:str,k:int=4,filter:dict|None=None,**kwargs:Any,)→List[Document][source]#",
    "similarity_search",
    "(",
    "query:str",
    "k:int=4",
    "filter:dict|None=None",
    "**kwargs:Any",
    ")",
    "→List[Document]",
    "→",
    "List[Document]",
    "similarity_search_by_vector(embedding:List[float],k:int=4,filter:dict|None=None,**kwargs:Any,)→List[Document][source]#",
    "similarity_search_by_vector",
    "(",
    "embedding:List[float]",
    "k:int=4",
    "filter:dict|None=None",
    "**kwargs:Any",
    ")",
    "→List[Document]",
    "→",
    "List[Document]",
    "similarity_search_with_relevance_scores(query:str,k:int=4,**kwargs:Any,)→list[tuple[Document,float]]#",
    "similarity_search_with_relevance_scores",
    "(",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    ")",
    "→list[tuple[Document,float]]",
    "→",
    "list[tuple[Document,float]]",
    "similarity_search_with_score(query:str,k:int=4,filter:dict|None=None,)→List[Tuple[Document,float]][source]#",
    "similarity_search_with_score",
    "(",
    "query:str",
    "k:int=4",
    "filter:dict|None=None",
    ")",
    "→List[Tuple[Document,float]]",
    "→",
    "List[Tuple[Document,float]]",
    "similarity_search_with_score_by_vector(embedding:List[float],k:int=4,filter:dict|None=None,)→List[Tuple[Document,float]][source]#",
    "similarity_search_with_score_by_vector",
    "(",
    "embedding:List[float]",
    "k:int=4",
    "filter:dict|None=None",
    ")",
    "→List[Tuple[Document,float]]",
    "→",
    "List[Tuple[Document,float]]"
  ],
  "parameters": [
    "connection_string:str",
    "embedding_function:Embeddings",
    "distance_strategy:DistanceStrategy=DistanceStrategy.COSINE",
    "collection_name:str='langchain'",
    "collection_metadata:dict|None=None",
    "pre_delete_collection:bool=False",
    "logger:Logger|None=None",
    "relevance_score_fn:Callable[[float],float]|None=None",
    "connection_string:str",
    "embedding_function:Embeddings",
    "distance_strategy:DistanceStrategy=DistanceStrategy.COSINE",
    "collection_name:str='langchain'",
    "collection_metadata:dict|None=None",
    "pre_delete_collection:bool=False",
    "logger:Logger|None=None",
    "relevance_score_fn:Callable[[float],float]|None=None",
    "documents:list[Document]",
    "**kwargs:Any",
    "texts:Iterable[str]",
    "metadatas:list[dict]|None=None",
    "*",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    "documents:list[Document]",
    "**kwargs:Any",
    "texts:List[str]",
    "embeddings:List[List[float]]",
    "metadatas:List[dict]",
    "ids:List[str]",
    "**kwargs:Any",
    "texts:Iterable[str]",
    "metadatas:List[dict]|None=None",
    "ids:List[str]|None=None",
    "**kwargs:Any",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    "documents:list[Document]",
    "embedding:Embeddings",
    "**kwargs:Any",
    "texts:list[str]",
    "embedding:Embeddings",
    "metadatas:list[dict]|None=None",
    "*",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    "ids:Sequence[str]",
    "/",
    "query:str",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    "embedding:list[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    "**kwargs:Any",
    "query:str",
    "search_type:str",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    "embedding:list[float]",
    "k:int=4",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    "*args:Any",
    "**kwargs:Any",
    "driver:str",
    "host:str",
    "port:int",
    "database:str",
    "user:str",
    "password:str",
    "dims:int=1536",
    "m:int=16",
    "ef_construction:int=64",
    "ef_search:int=64",
    "**_kwargs:Any",
    "ids:List[str]|None=None",
    "**kwargs:Any",
    "documents:List[Document]",
    "embedding:Embeddings",
    "collection_name:str='langchain'",
    "distance_strategy:DistanceStrategy=DistanceStrategy.COSINE",
    "ids:List[str]|None=None",
    "pre_delete_collection:bool=False",
    "**kwargs:Any",
    "text_embeddings:List[Tuple[str,List[float]]]",
    "embedding:Embeddings",
    "metadatas:List[dict]|None=None",
    "collection_name:str='langchain'",
    "ids:List[str]|None=None",
    "pre_delete_collection:bool=False",
    "distance_strategy:DistanceStrategy=DistanceStrategy.COSINE",
    "**kwargs:Any",
    "embedding:Embeddings",
    "collection_name:str='langchain'",
    "pre_delete_collection:bool=False",
    "distance_strategy:DistanceStrategy=DistanceStrategy.COSINE",
    "**kwargs:Any",
    "texts:List[str]",
    "embedding:Embeddings",
    "metadatas:List[dict]|None=None",
    "collection_name:str='langchain'",
    "distance_strategy:DistanceStrategy=DistanceStrategy.COSINE",
    "ids:List[str]|None=None",
    "pre_delete_collection:bool=False",
    "**kwargs:Any",
    "ids:Sequence[str]",
    "/",
    "query:str",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "filter:Dict[str,str]|None=None",
    "**kwargs:Any",
    "embedding:List[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "filter:Dict[str,str]|None=None",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "filter:dict|None=None",
    "**kwargs:Any",
    "embedding:List[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "filter:Dict[str,str]|None=None",
    "**kwargs:Any",
    "query:str",
    "search_type:str",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "filter:dict|None=None",
    "**kwargs:Any",
    "embedding:List[float]",
    "k:int=4",
    "filter:dict|None=None",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "filter:dict|None=None",
    "embedding:List[float]",
    "k:int=4",
    "filter:dict|None=None"
  ]
}
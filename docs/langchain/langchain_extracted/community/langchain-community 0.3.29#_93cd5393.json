{
  "url": "https://python.langchain.com/api_reference/community/index.html#langchain-community-embeddings",
  "title": "langchain-community: 0.3.29#",
  "sections": [
    {
      "type": "li",
      "content": "LangChain Python API Reference"
    },
    {
      "type": "li",
      "content": "langchain-community: 0.3.29"
    },
    {
      "type": "p",
      "content": "Main entrypoint into package."
    },
    {
      "type": "p",
      "content": "adapters.openai.Chat()"
    },
    {
      "type": "p",
      "content": "adapters.openai.ChatCompletion()"
    },
    {
      "type": "p",
      "content": "Chat completion."
    },
    {
      "type": "p",
      "content": "adapters.openai.ChatCompletionChunk"
    },
    {
      "type": "p",
      "content": "Chat completion chunk."
    },
    {
      "type": "p",
      "content": "adapters.openai.ChatCompletions"
    },
    {
      "type": "p",
      "content": "Chat completions."
    },
    {
      "type": "p",
      "content": "adapters.openai.Choice"
    },
    {
      "type": "p",
      "content": "adapters.openai.ChoiceChunk"
    },
    {
      "type": "p",
      "content": "Choice chunk."
    },
    {
      "type": "p",
      "content": "adapters.openai.Completions()"
    },
    {
      "type": "p",
      "content": "Completions."
    },
    {
      "type": "p",
      "content": "adapters.openai.IndexableBaseModel"
    },
    {
      "type": "p",
      "content": "Allows a BaseModel to return its fields by string variable indexing."
    },
    {
      "type": "p",
      "content": "adapters.openai.aenumerate(iterable[, start])"
    },
    {
      "type": "p",
      "content": "Async version of enumerate function."
    },
    {
      "type": "p",
      "content": "adapters.openai.convert_dict_to_message(_dict)"
    },
    {
      "type": "p",
      "content": "Convert a dictionary to a LangChain message."
    },
    {
      "type": "p",
      "content": "adapters.openai.convert_message_to_dict(message)"
    },
    {
      "type": "p",
      "content": "Convert a LangChain message to a dictionary."
    },
    {
      "type": "p",
      "content": "adapters.openai.convert_messages_for_finetuning(...)"
    },
    {
      "type": "p",
      "content": "Convert messages to a list of lists of dictionaries for fine-tuning."
    },
    {
      "type": "p",
      "content": "adapters.openai.convert_openai_messages(messages)"
    },
    {
      "type": "p",
      "content": "Convert dictionaries representing OpenAI messages to LangChain format."
    },
    {
      "type": "h2",
      "content": "agent_toolkits#"
    },
    {
      "type": "p",
      "content": "agent_toolkits.ainetwork.toolkit.AINetworkToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for interacting with AINetwork Blockchain."
    },
    {
      "type": "p",
      "content": "agent_toolkits.amadeus.toolkit.AmadeusToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for interacting with Amadeus which offers APIs for travel."
    },
    {
      "type": "p",
      "content": "agent_toolkits.azure_ai_services.AzureAiServicesToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for Azure AI Services."
    },
    {
      "type": "p",
      "content": "agent_toolkits.azure_cognitive_services.AzureCognitiveServicesToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for Azure Cognitive Services."
    },
    {
      "type": "p",
      "content": "agent_toolkits.cassandra_database.toolkit.CassandraDatabaseToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for interacting with an Apache Cassandra database."
    },
    {
      "type": "p",
      "content": "agent_toolkits.clickup.toolkit.ClickupToolkit"
    },
    {
      "type": "p",
      "content": "Clickup Toolkit."
    },
    {
      "type": "p",
      "content": "agent_toolkits.cogniswitch.toolkit.CogniswitchToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for CogniSwitch."
    },
    {
      "type": "p",
      "content": "agent_toolkits.connery.toolkit.ConneryToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit with a list of Connery Actions as tools."
    },
    {
      "type": "p",
      "content": "agent_toolkits.file_management.toolkit.FileManagementToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for interacting with local files."
    },
    {
      "type": "p",
      "content": "agent_toolkits.financial_datasets.toolkit.FinancialDatasetsToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for interacting with financialdatasets.ai."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.BranchName"
    },
    {
      "type": "p",
      "content": "Schema for operations that require a branch name as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.CommentOnIssue"
    },
    {
      "type": "p",
      "content": "Schema for operations that require a comment as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.CreateFile"
    },
    {
      "type": "p",
      "content": "Schema for operations that require a file path and content as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.CreatePR"
    },
    {
      "type": "p",
      "content": "Schema for operations that require a PR title and body as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.CreateReviewRequest"
    },
    {
      "type": "p",
      "content": "Schema for operations that require a username as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.DeleteFile"
    },
    {
      "type": "p",
      "content": "Schema for operations that require a file path as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.DirectoryPath"
    },
    {
      "type": "p",
      "content": "Schema for operations that require a directory path as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.GetIssue"
    },
    {
      "type": "p",
      "content": "Schema for operations that require an issue number as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.GetPR"
    },
    {
      "type": "p",
      "content": "Schema for operations that require a PR number as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.GitHubToolkit"
    },
    {
      "type": "p",
      "content": "GitHub Toolkit."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.NoInput"
    },
    {
      "type": "p",
      "content": "Schema for operations that do not require any input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.ReadFile"
    },
    {
      "type": "p",
      "content": "Schema for operations that require a file path as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.SearchCode"
    },
    {
      "type": "p",
      "content": "Schema for operations that require a search query as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.SearchIssuesAndPRs"
    },
    {
      "type": "p",
      "content": "Schema for operations that require a search query as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.TagName"
    },
    {
      "type": "p",
      "content": "Schema for operations that require a tag name as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.github.toolkit.UpdateFile"
    },
    {
      "type": "p",
      "content": "Schema for operations that require a file path and content as input."
    },
    {
      "type": "p",
      "content": "agent_toolkits.gitlab.toolkit.GitLabToolkit"
    },
    {
      "type": "p",
      "content": "GitLab Toolkit."
    },
    {
      "type": "p",
      "content": "agent_toolkits.gmail.toolkit.GmailToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for interacting with Gmail."
    },
    {
      "type": "p",
      "content": "agent_toolkits.jira.toolkit.JiraToolkit"
    },
    {
      "type": "p",
      "content": "Jira Toolkit."
    },
    {
      "type": "p",
      "content": "agent_toolkits.json.toolkit.JsonToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for interacting with a JSON spec."
    },
    {
      "type": "p",
      "content": "agent_toolkits.multion.toolkit.MultionToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for interacting with the Browser Agent."
    },
    {
      "type": "p",
      "content": "agent_toolkits.nasa.toolkit.NasaToolkit"
    },
    {
      "type": "p",
      "content": "Nasa Toolkit."
    },
    {
      "type": "p",
      "content": "agent_toolkits.nla.tool.NLATool"
    },
    {
      "type": "p",
      "content": "Natural Language API Tool."
    },
    {
      "type": "p",
      "content": "agent_toolkits.nla.toolkit.NLAToolkit"
    },
    {
      "type": "p",
      "content": "Natural Language API Toolkit."
    },
    {
      "type": "p",
      "content": "agent_toolkits.office365.toolkit.O365Toolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for interacting with Office 365."
    },
    {
      "type": "p",
      "content": "agent_toolkits.openapi.planner.RequestsDeleteToolWithParsing"
    },
    {
      "type": "p",
      "content": "Tool that sends a DELETE request and parses the response."
    },
    {
      "type": "p",
      "content": "agent_toolkits.openapi.planner.RequestsGetToolWithParsing"
    },
    {
      "type": "p",
      "content": "Requests GET tool with LLM-instructed extraction of truncated responses."
    },
    {
      "type": "p",
      "content": "agent_toolkits.openapi.planner.RequestsPatchToolWithParsing"
    },
    {
      "type": "p",
      "content": "Requests PATCH tool with LLM-instructed extraction of truncated responses."
    },
    {
      "type": "p",
      "content": "agent_toolkits.openapi.planner.RequestsPostToolWithParsing"
    },
    {
      "type": "p",
      "content": "Requests POST tool with LLM-instructed extraction of truncated responses."
    },
    {
      "type": "p",
      "content": "agent_toolkits.openapi.planner.RequestsPutToolWithParsing"
    },
    {
      "type": "p",
      "content": "Requests PUT tool with LLM-instructed extraction of truncated responses."
    },
    {
      "type": "p",
      "content": "agent_toolkits.openapi.spec.ReducedOpenAPISpec(...)"
    },
    {
      "type": "p",
      "content": "A reduced OpenAPI spec."
    },
    {
      "type": "p",
      "content": "agent_toolkits.openapi.toolkit.OpenAPIToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for interacting with an OpenAPI API."
    },
    {
      "type": "p",
      "content": "agent_toolkits.openapi.toolkit.RequestsToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for making REST requests."
    },
    {
      "type": "p",
      "content": "agent_toolkits.playwright.toolkit.PlayWrightBrowserToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for PlayWright browser tools."
    },
    {
      "type": "p",
      "content": "agent_toolkits.polygon.toolkit.PolygonToolkit"
    },
    {
      "type": "p",
      "content": "Polygon Toolkit."
    },
    {
      "type": "p",
      "content": "agent_toolkits.powerbi.toolkit.PowerBIToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for interacting with Power BI dataset."
    },
    {
      "type": "p",
      "content": "agent_toolkits.slack.toolkit.SlackToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for interacting with Slack."
    },
    {
      "type": "p",
      "content": "agent_toolkits.spark_sql.toolkit.SparkSQLToolkit"
    },
    {
      "type": "p",
      "content": "Toolkit for interacting with Spark SQL."
    },
    {
      "type": "p",
      "content": "agent_toolkits.sql.toolkit.SQLDatabaseToolkit"
    },
    {
      "type": "p",
      "content": "SQLDatabaseToolkit for interacting with SQL databases."
    },
    {
      "type": "p",
      "content": "agent_toolkits.steam.toolkit.SteamToolkit"
    },
    {
      "type": "p",
      "content": "Steam Toolkit."
    },
    {
      "type": "p",
      "content": "agent_toolkits.zapier.toolkit.ZapierToolkit"
    },
    {
      "type": "p",
      "content": "Zapier Toolkit."
    },
    {
      "type": "p",
      "content": "agent_toolkits.json.base.create_json_agent(...)"
    },
    {
      "type": "p",
      "content": "Construct a json agent from an LLM and tools."
    },
    {
      "type": "p",
      "content": "agent_toolkits.load_tools.get_all_tool_names()"
    },
    {
      "type": "p",
      "content": "Get a list of all possible tool names."
    },
    {
      "type": "p",
      "content": "agent_toolkits.load_tools.load_huggingface_tool(...)"
    },
    {
      "type": "p",
      "content": "Loads a tool from the HuggingFace Hub."
    },
    {
      "type": "p",
      "content": "agent_toolkits.load_tools.load_tools(tool_names)"
    },
    {
      "type": "p",
      "content": "Load tools based on their name."
    },
    {
      "type": "p",
      "content": "agent_toolkits.load_tools.raise_dangerous_tools_exception(name)"
    },
    {
      "type": "p",
      "content": "agent_toolkits.openapi.base.create_openapi_agent(...)"
    },
    {
      "type": "p",
      "content": "Construct an OpenAPI agent from an LLM and tools."
    },
    {
      "type": "p",
      "content": "agent_toolkits.openapi.planner.create_openapi_agent(...)"
    },
    {
      "type": "p",
      "content": "Construct an OpenAI API planner and controller for a given spec."
    },
    {
      "type": "p",
      "content": "agent_toolkits.openapi.spec.reduce_openapi_spec(spec)"
    },
    {
      "type": "p",
      "content": "Simplify/distill/minify a spec somehow."
    },
    {
      "type": "p",
      "content": "agent_toolkits.powerbi.base.create_pbi_agent(llm)"
    },
    {
      "type": "p",
      "content": "Construct a Power BI agent from an LLM and tools."
    },
    {
      "type": "p",
      "content": "agent_toolkits.powerbi.chat_base.create_pbi_chat_agent(llm)"
    },
    {
      "type": "p",
      "content": "Construct a Power BI agent from a Chat LLM and tools."
    },
    {
      "type": "p",
      "content": "agent_toolkits.spark_sql.base.create_spark_sql_agent(...)"
    },
    {
      "type": "p",
      "content": "Construct a Spark SQL agent from an LLM and tools."
    },
    {
      "type": "p",
      "content": "agent_toolkits.sql.base.create_sql_agent(llm)"
    },
    {
      "type": "p",
      "content": "Construct a SQL agent from an LLM and toolkit or database."
    },
    {
      "type": "p",
      "content": "agents.openai_assistant.base.OpenAIAssistantV2Runnable"
    },
    {
      "type": "p",
      "content": "cache.AsyncRedisCache(redis_, *[, ttl])"
    },
    {
      "type": "p",
      "content": "Cache that uses Redis as a backend."
    },
    {
      "type": "p",
      "content": "cache.AzureCosmosDBNoSqlSemanticCache(...[, ...])"
    },
    {
      "type": "p",
      "content": "Cache that uses Cosmos DB NoSQL backend"
    },
    {
      "type": "p",
      "content": "cache.AzureCosmosDBSemanticCache(...[, ...])"
    },
    {
      "type": "p",
      "content": "Cache that uses Cosmos DB Mongo vCore vector-store backend"
    },
    {
      "type": "p",
      "content": "cache.CassandraCache([session, keyspace, ...])"
    },
    {
      "type": "p",
      "content": "Cache that uses Cassandra / Astra DB as a backend."
    },
    {
      "type": "p",
      "content": "cache.CassandraSemanticCache([session, ...])"
    },
    {
      "type": "p",
      "content": "Cache that uses Cassandra as a vector-store backend for semantic (i.e. similarity-based) lookup."
    },
    {
      "type": "p",
      "content": "cache.FullLLMCache(**kwargs)"
    },
    {
      "type": "p",
      "content": "SQLite table for full LLM Cache (all generations)."
    },
    {
      "type": "p",
      "content": "cache.FullMd5LLMCache(**kwargs)"
    },
    {
      "type": "p",
      "content": "SQLite table for full LLM Cache (all generations)."
    },
    {
      "type": "p",
      "content": "cache.GPTCache([init_func])"
    },
    {
      "type": "p",
      "content": "Cache that uses GPTCache as a backend."
    },
    {
      "type": "p",
      "content": "cache.InMemoryCache()"
    },
    {
      "type": "p",
      "content": "Cache that stores things in memory."
    },
    {
      "type": "p",
      "content": "cache.MemcachedCache(client_)"
    },
    {
      "type": "p",
      "content": "Cache that uses Memcached backend through pymemcache client lib"
    },
    {
      "type": "p",
      "content": "cache.MomentoCache(cache_client, cache_name, *)"
    },
    {
      "type": "p",
      "content": "Cache that uses Momento as a backend."
    },
    {
      "type": "p",
      "content": "cache.OpenSearchSemanticCache(...[, ...])"
    },
    {
      "type": "p",
      "content": "Cache that uses OpenSearch vector store backend"
    },
    {
      "type": "p",
      "content": "cache.RedisCache(redis_, *[, ttl])"
    },
    {
      "type": "p",
      "content": "Cache that uses Redis as a backend."
    },
    {
      "type": "p",
      "content": "cache.RedisSemanticCache(redis_url, embedding)"
    },
    {
      "type": "p",
      "content": "Cache that uses Redis as a vector-store backend."
    },
    {
      "type": "p",
      "content": "cache.SQLAlchemyCache(engine, cache_schema)"
    },
    {
      "type": "p",
      "content": "Cache that uses SQAlchemy as a backend."
    },
    {
      "type": "p",
      "content": "cache.SQLAlchemyMd5Cache(engine, cache_schema)"
    },
    {
      "type": "p",
      "content": "Cache that uses SQAlchemy as a backend."
    },
    {
      "type": "p",
      "content": "cache.SQLiteCache([database_path])"
    },
    {
      "type": "p",
      "content": "Cache that uses SQLite as a backend."
    },
    {
      "type": "p",
      "content": "cache.UpstashRedisCache(redis_, *[, ttl])"
    },
    {
      "type": "p",
      "content": "Cache that uses Upstash Redis as a backend."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "cache.AstraDBCache(*[, collection_name, ...])"
    },
    {
      "type": "p",
      "content": "cache.AstraDBSemanticCache(*[, ...])"
    },
    {
      "type": "p",
      "content": "cache.SingleStoreDBSemanticCache(embedding, *)"
    },
    {
      "type": "p",
      "content": "callbacks.aim_callback.AimCallbackHandler([...])"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs to Aim."
    },
    {
      "type": "p",
      "content": "callbacks.aim_callback.BaseMetadataCallbackHandler()"
    },
    {
      "type": "p",
      "content": "Callback handler for the metadata and associated function states for callbacks."
    },
    {
      "type": "p",
      "content": "callbacks.argilla_callback.ArgillaCallbackHandler(...)"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs into Argilla."
    },
    {
      "type": "p",
      "content": "callbacks.arize_callback.ArizeCallbackHandler([...])"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs to Arize."
    },
    {
      "type": "p",
      "content": "callbacks.arthur_callback.ArthurCallbackHandler(...)"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs to Arthur platform."
    },
    {
      "type": "p",
      "content": "callbacks.bedrock_anthropic_callback.BedrockAnthropicTokenUsageCallbackHandler()"
    },
    {
      "type": "p",
      "content": "Callback Handler that tracks bedrock anthropic info."
    },
    {
      "type": "p",
      "content": "callbacks.clearml_callback.ClearMLCallbackHandler([...])"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs to ClearML."
    },
    {
      "type": "p",
      "content": "callbacks.comet_ml_callback.CometCallbackHandler([...])"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs to Comet."
    },
    {
      "type": "p",
      "content": "callbacks.confident_callback.DeepEvalCallbackHandler(metrics)"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs into deepeval."
    },
    {
      "type": "p",
      "content": "callbacks.context_callback.ContextCallbackHandler([...])"
    },
    {
      "type": "p",
      "content": "Callback Handler that records transcripts to the Context service."
    },
    {
      "type": "p",
      "content": "callbacks.fiddler_callback.FiddlerCallbackHandler(...)"
    },
    {
      "type": "p",
      "content": "Initialize Fiddler callback handler."
    },
    {
      "type": "p",
      "content": "callbacks.flyte_callback.FlyteCallbackHandler()"
    },
    {
      "type": "p",
      "content": "Callback handler that is used within a Flyte task."
    },
    {
      "type": "p",
      "content": "callbacks.human.AsyncHumanApprovalCallbackHandler(...)"
    },
    {
      "type": "p",
      "content": "Asynchronous callback for manually validating values."
    },
    {
      "type": "p",
      "content": "callbacks.human.HumanApprovalCallbackHandler(...)"
    },
    {
      "type": "p",
      "content": "Callback for manually validating values."
    },
    {
      "type": "p",
      "content": "callbacks.human.HumanRejectedException"
    },
    {
      "type": "p",
      "content": "Exception to raise when a person manually review and rejects a value."
    },
    {
      "type": "p",
      "content": "callbacks.infino_callback.InfinoCallbackHandler([...])"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs to Infino."
    },
    {
      "type": "p",
      "content": "callbacks.labelstudio_callback.LabelStudioCallbackHandler([...])"
    },
    {
      "type": "p",
      "content": "Label Studio callback handler."
    },
    {
      "type": "p",
      "content": "callbacks.labelstudio_callback.LabelStudioMode(value)"
    },
    {
      "type": "p",
      "content": "Label Studio mode enumerator."
    },
    {
      "type": "p",
      "content": "callbacks.llmonitor_callback.LLMonitorCallbackHandler([...])"
    },
    {
      "type": "p",
      "content": "Callback Handler for LLMonitor`."
    },
    {
      "type": "p",
      "content": "callbacks.llmonitor_callback.UserContextManager(user_id)"
    },
    {
      "type": "p",
      "content": "Context manager for LLMonitor user context."
    },
    {
      "type": "p",
      "content": "callbacks.mlflow_callback.MlflowCallbackHandler([...])"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs metrics and artifacts to mlflow server."
    },
    {
      "type": "p",
      "content": "callbacks.mlflow_callback.MlflowLogger(**kwargs)"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs metrics and artifacts to mlflow server."
    },
    {
      "type": "p",
      "content": "callbacks.openai_info.OpenAICallbackHandler()"
    },
    {
      "type": "p",
      "content": "Callback Handler that tracks OpenAI info."
    },
    {
      "type": "p",
      "content": "callbacks.openai_info.TokenType(value)"
    },
    {
      "type": "p",
      "content": "Token type enum."
    },
    {
      "type": "p",
      "content": "callbacks.promptlayer_callback.PromptLayerCallbackHandler([...])"
    },
    {
      "type": "p",
      "content": "Callback handler for promptlayer."
    },
    {
      "type": "p",
      "content": "callbacks.sagemaker_callback.SageMakerCallbackHandler(run)"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs prompt artifacts and metrics to SageMaker Experiments."
    },
    {
      "type": "p",
      "content": "callbacks.streamlit.mutable_expander.ChildRecord(...)"
    },
    {
      "type": "p",
      "content": "Child record as a NamedTuple."
    },
    {
      "type": "p",
      "content": "callbacks.streamlit.mutable_expander.ChildType(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of the child type."
    },
    {
      "type": "p",
      "content": "callbacks.streamlit.mutable_expander.MutableExpander(...)"
    },
    {
      "type": "p",
      "content": "Streamlit expander that can be renamed and dynamically expanded/collapsed."
    },
    {
      "type": "p",
      "content": "callbacks.streamlit.streamlit_callback_handler.LLMThought(...)"
    },
    {
      "type": "p",
      "content": "A thought in the LLM's thought stream."
    },
    {
      "type": "p",
      "content": "callbacks.streamlit.streamlit_callback_handler.LLMThoughtLabeler()"
    },
    {
      "type": "p",
      "content": "Generates markdown labels for LLMThought containers."
    },
    {
      "type": "p",
      "content": "callbacks.streamlit.streamlit_callback_handler.LLMThoughtState(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of the LLMThought state."
    },
    {
      "type": "p",
      "content": "callbacks.streamlit.streamlit_callback_handler.StreamlitCallbackHandler(...)"
    },
    {
      "type": "p",
      "content": "Callback handler that writes to a Streamlit app."
    },
    {
      "type": "p",
      "content": "callbacks.streamlit.streamlit_callback_handler.ToolRecord(...)"
    },
    {
      "type": "p",
      "content": "Tool record as a NamedTuple."
    },
    {
      "type": "p",
      "content": "callbacks.tracers.comet.CometTracer(**kwargs)"
    },
    {
      "type": "p",
      "content": "Comet Tracer."
    },
    {
      "type": "p",
      "content": "callbacks.tracers.wandb.WandbRunArgs"
    },
    {
      "type": "p",
      "content": "Arguments for the WandbTracer."
    },
    {
      "type": "p",
      "content": "callbacks.tracers.wandb.WandbTracer(...)"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs to Weights and Biases."
    },
    {
      "type": "p",
      "content": "callbacks.trubrics_callback.TrubricsCallbackHandler([...])"
    },
    {
      "type": "p",
      "content": "Callback handler for Trubrics."
    },
    {
      "type": "p",
      "content": "callbacks.upstash_ratelimit_callback.UpstashRatelimitError(...)"
    },
    {
      "type": "p",
      "content": "Upstash Ratelimit Error"
    },
    {
      "type": "p",
      "content": "callbacks.upstash_ratelimit_callback.UpstashRatelimitHandler(...)"
    },
    {
      "type": "p",
      "content": "Callback to handle rate limiting based on the number of requests or the number of tokens in the input."
    },
    {
      "type": "p",
      "content": "callbacks.uptrain_callback.UpTrainCallbackHandler(*)"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs evaluation results to uptrain and the console."
    },
    {
      "type": "p",
      "content": "callbacks.uptrain_callback.UpTrainDataSchema(...)"
    },
    {
      "type": "p",
      "content": "The UpTrain data schema for tracking evaluation results."
    },
    {
      "type": "p",
      "content": "callbacks.utils.BaseMetadataCallbackHandler()"
    },
    {
      "type": "p",
      "content": "Handle the metadata and associated function states for callbacks."
    },
    {
      "type": "p",
      "content": "callbacks.wandb_callback.WandbCallbackHandler([...])"
    },
    {
      "type": "p",
      "content": "Callback Handler that logs to Weights and Biases."
    },
    {
      "type": "p",
      "content": "callbacks.whylabs_callback.WhyLabsCallbackHandler(...)"
    },
    {
      "type": "p",
      "content": "Callback Handler for logging to WhyLabs."
    },
    {
      "type": "p",
      "content": "callbacks.aim_callback.import_aim()"
    },
    {
      "type": "p",
      "content": "Import the aim python package and raise an error if it is not installed."
    },
    {
      "type": "p",
      "content": "callbacks.clearml_callback.import_clearml()"
    },
    {
      "type": "p",
      "content": "Import the clearml python package and raise an error if it is not installed."
    },
    {
      "type": "p",
      "content": "callbacks.comet_ml_callback.import_comet_ml()"
    },
    {
      "type": "p",
      "content": "Import comet_ml and raise an error if it is not installed."
    },
    {
      "type": "p",
      "content": "callbacks.context_callback.import_context()"
    },
    {
      "type": "p",
      "content": "Import thegetcontextpackage."
    },
    {
      "type": "p",
      "content": "callbacks.fiddler_callback.import_fiddler()"
    },
    {
      "type": "p",
      "content": "Import the fiddler python package and raise an error if it is not installed."
    },
    {
      "type": "p",
      "content": "callbacks.flyte_callback.analyze_text(text)"
    },
    {
      "type": "p",
      "content": "Analyze text using textstat and spacy."
    },
    {
      "type": "p",
      "content": "callbacks.flyte_callback.import_flytekit()"
    },
    {
      "type": "p",
      "content": "Import flytekit and flytekitplugins-deck-standard."
    },
    {
      "type": "p",
      "content": "callbacks.infino_callback.get_num_tokens(...)"
    },
    {
      "type": "p",
      "content": "Calculate num tokens for OpenAI with tiktoken package."
    },
    {
      "type": "p",
      "content": "callbacks.infino_callback.import_infino()"
    },
    {
      "type": "p",
      "content": "Import the infino client."
    },
    {
      "type": "p",
      "content": "callbacks.infino_callback.import_tiktoken()"
    },
    {
      "type": "p",
      "content": "Import tiktoken for counting tokens for OpenAI models."
    },
    {
      "type": "p",
      "content": "callbacks.labelstudio_callback.get_default_label_configs(mode)"
    },
    {
      "type": "p",
      "content": "Get default Label Studio configs for the given mode."
    },
    {
      "type": "p",
      "content": "callbacks.llmonitor_callback.identify(user_id)"
    },
    {
      "type": "p",
      "content": "Builds an LLMonitor UserContextManager"
    },
    {
      "type": "p",
      "content": "callbacks.manager.get_bedrock_anthropic_callback()"
    },
    {
      "type": "p",
      "content": "Get the Bedrock anthropic callback handler in a context manager."
    },
    {
      "type": "p",
      "content": "callbacks.manager.get_openai_callback()"
    },
    {
      "type": "p",
      "content": "Get the OpenAI callback handler in a context manager."
    },
    {
      "type": "p",
      "content": "callbacks.manager.wandb_tracing_enabled([...])"
    },
    {
      "type": "p",
      "content": "Get the WandbTracer in a context manager."
    },
    {
      "type": "p",
      "content": "callbacks.mlflow_callback.analyze_text(text)"
    },
    {
      "type": "p",
      "content": "Analyze text using textstat and spacy."
    },
    {
      "type": "p",
      "content": "callbacks.mlflow_callback.construct_html_from_prompt_and_generation(...)"
    },
    {
      "type": "p",
      "content": "Construct an html element from a prompt and a generation."
    },
    {
      "type": "p",
      "content": "callbacks.mlflow_callback.get_text_complexity_metrics()"
    },
    {
      "type": "p",
      "content": "Get the text complexity metrics from textstat."
    },
    {
      "type": "p",
      "content": "callbacks.mlflow_callback.import_mlflow()"
    },
    {
      "type": "p",
      "content": "Import the mlflow python package and raise an error if it is not installed."
    },
    {
      "type": "p",
      "content": "callbacks.mlflow_callback.mlflow_callback_metrics()"
    },
    {
      "type": "p",
      "content": "Get the metrics to log to MLFlow."
    },
    {
      "type": "p",
      "content": "callbacks.openai_info.get_openai_token_cost_for_model(...)"
    },
    {
      "type": "p",
      "content": "Get the cost in USD for a given model and number of tokens."
    },
    {
      "type": "p",
      "content": "callbacks.openai_info.standardize_model_name(...)"
    },
    {
      "type": "p",
      "content": "Standardize the model name to a format that can be used in the OpenAI API."
    },
    {
      "type": "p",
      "content": "callbacks.sagemaker_callback.save_json(data, ...)"
    },
    {
      "type": "p",
      "content": "Save dict to local file path."
    },
    {
      "type": "p",
      "content": "callbacks.tracers.comet.import_comet_llm_api()"
    },
    {
      "type": "p",
      "content": "Import comet_llm api and raise an error if it is not installed."
    },
    {
      "type": "p",
      "content": "callbacks.tracers.wandb.build_tree(runs)"
    },
    {
      "type": "p",
      "content": "Builds a nested dictionary from a list of runs. :param runs: The list of runs to build the tree from. :return: The nested dictionary representing the langchain Run in a tree     structure compatible with WBTraceTree."
    },
    {
      "type": "p",
      "content": "callbacks.tracers.wandb.flatten_run(run)"
    },
    {
      "type": "p",
      "content": "Utility to flatten a nest run object into a list of runs."
    },
    {
      "type": "p",
      "content": "callbacks.tracers.wandb.modify_serialized_iterative(runs)"
    },
    {
      "type": "p",
      "content": "Utility to modify the serialized field of a list of runs dictionaries. removes any keys that match the exact_keys and any keys that contain any of the partial_keys. recursively moves the dictionaries under the kwargs key to the top level. changes the \"id\" field to a string \"_kind\" field that tells WBTraceTree how to visualize the run. promotes the \"serialized\" field to the top level. :param runs: The list of runs to modify. :param exact_keys: A tuple of keys to remove from the serialized field. :param partial_keys: A tuple of partial keys to remove from the serialized     field. :return: The modified list of runs."
    },
    {
      "type": "p",
      "content": "callbacks.tracers.wandb.truncate_run_iterative(runs)"
    },
    {
      "type": "p",
      "content": "Utility to truncate a list of runs dictionaries to only keep the specified"
    },
    {
      "type": "p",
      "content": "callbacks.uptrain_callback.import_uptrain()"
    },
    {
      "type": "p",
      "content": "Import theuptrainpackage."
    },
    {
      "type": "p",
      "content": "callbacks.utils.flatten_dict(nested_dict[, ...])"
    },
    {
      "type": "p",
      "content": "Flatten a nested dictionary into a flat dictionary."
    },
    {
      "type": "p",
      "content": "callbacks.utils.hash_string(s)"
    },
    {
      "type": "p",
      "content": "Hash a string using sha1."
    },
    {
      "type": "p",
      "content": "callbacks.utils.import_pandas()"
    },
    {
      "type": "p",
      "content": "Import the pandas python package and raise an error if it is not installed."
    },
    {
      "type": "p",
      "content": "callbacks.utils.import_spacy()"
    },
    {
      "type": "p",
      "content": "Import the spacy python package and raise an error if it is not installed."
    },
    {
      "type": "p",
      "content": "callbacks.utils.import_textstat()"
    },
    {
      "type": "p",
      "content": "Import the textstat python package and raise an error if it is not installed."
    },
    {
      "type": "p",
      "content": "callbacks.utils.load_json(json_path)"
    },
    {
      "type": "p",
      "content": "Load json file to a string."
    },
    {
      "type": "p",
      "content": "callbacks.wandb_callback.analyze_text(text)"
    },
    {
      "type": "p",
      "content": "Analyze text using textstat and spacy."
    },
    {
      "type": "p",
      "content": "callbacks.wandb_callback.construct_html_from_prompt_and_generation(...)"
    },
    {
      "type": "p",
      "content": "Construct an html element from a prompt and a generation."
    },
    {
      "type": "p",
      "content": "callbacks.wandb_callback.import_wandb()"
    },
    {
      "type": "p",
      "content": "Import the wandb python package and raise an error if it is not installed."
    },
    {
      "type": "p",
      "content": "callbacks.wandb_callback.load_json_to_dict(...)"
    },
    {
      "type": "p",
      "content": "Load json file to a dictionary."
    },
    {
      "type": "p",
      "content": "callbacks.whylabs_callback.import_langkit([...])"
    },
    {
      "type": "p",
      "content": "Import the langkit python package and raise an error if it is not installed."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.arangodb.ArangoGraphQAChain"
    },
    {
      "type": "p",
      "content": "Chain for question-answering against a graph by generating AQL statements."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.base.GraphQAChain"
    },
    {
      "type": "p",
      "content": "Chain for question-answering against a graph."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.cypher_utils.Schema(...)"
    },
    {
      "type": "p",
      "content": "Create new instance of Schema(left_node, relation, right_node)"
    },
    {
      "type": "p",
      "content": "chains.graph_qa.falkordb.FalkorDBQAChain"
    },
    {
      "type": "p",
      "content": "Chain for question-answering against a graph by generating Cypher statements."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.gremlin.GremlinQAChain"
    },
    {
      "type": "p",
      "content": "Chain for question-answering against a graph by generating gremlin statements."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.hugegraph.HugeGraphQAChain"
    },
    {
      "type": "p",
      "content": "Chain for question-answering against a graph by generating gremlin statements."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.kuzu.KuzuQAChain"
    },
    {
      "type": "p",
      "content": "Question-answering against a graph by generating Cypher statements for Kùzu."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.memgraph.MemgraphQAChain"
    },
    {
      "type": "p",
      "content": "Chain for question-answering against a graph by generating Cypher statements."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.nebulagraph.NebulaGraphQAChain"
    },
    {
      "type": "p",
      "content": "Chain for question-answering against a graph by generating nGQL statements."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.ontotext_graphdb.OntotextGraphDBQAChain"
    },
    {
      "type": "p",
      "content": "Question-answering against Ontotext GraphDB"
    },
    {
      "type": "p",
      "content": "chains.graph_qa.sparql.GraphSparqlQAChain"
    },
    {
      "type": "p",
      "content": "Question-answering against an RDF or OWL graph by generating SPARQL statements."
    },
    {
      "type": "p",
      "content": "chains.llm_requests.LLMRequestsChain"
    },
    {
      "type": "p",
      "content": "Chain that requests a URL and then uses an LLM to parse results."
    },
    {
      "type": "p",
      "content": "chains.openapi.chain.OpenAPIEndpointChain"
    },
    {
      "type": "p",
      "content": "Chain interacts with an OpenAPI endpoint using natural language."
    },
    {
      "type": "p",
      "content": "chains.openapi.requests_chain.APIRequesterChain"
    },
    {
      "type": "p",
      "content": "Get the request parser."
    },
    {
      "type": "p",
      "content": "chains.openapi.requests_chain.APIRequesterOutputParser"
    },
    {
      "type": "p",
      "content": "Parse the request and error tags."
    },
    {
      "type": "p",
      "content": "chains.openapi.response_chain.APIResponderChain"
    },
    {
      "type": "p",
      "content": "Get the response parser."
    },
    {
      "type": "p",
      "content": "chains.openapi.response_chain.APIResponderOutputParser"
    },
    {
      "type": "p",
      "content": "Parse the response and error tags."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.base.PebbloRetrievalQA"
    },
    {
      "type": "p",
      "content": "Retrieval Chain with Identity & Semantic Enforcement for question-answering against a vector database."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.App"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.AuthContext"
    },
    {
      "type": "p",
      "content": "Class for an authorization context."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.ChainInfo"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.ChainInput"
    },
    {
      "type": "p",
      "content": "Input for PebbloRetrievalQA chain."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.Context"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.Framework"
    },
    {
      "type": "p",
      "content": "Langchain framework details"
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.Model"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.PkgInfo"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.Prompt"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.Qa"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.Runtime"
    },
    {
      "type": "p",
      "content": "OS, language details"
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.SemanticContext"
    },
    {
      "type": "p",
      "content": "Class for a semantic context."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.SemanticEntities"
    },
    {
      "type": "p",
      "content": "Class for a semantic entity filter."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.SemanticTopics"
    },
    {
      "type": "p",
      "content": "Class for a semantic topic filter."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.models.VectorDB"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.utilities.PebbloRetrievalAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Pebblo Retrieval API."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.utilities.Routes(value)"
    },
    {
      "type": "p",
      "content": "Routes available for the Pebblo API as enumerator."
    },
    {
      "type": "p",
      "content": "chains.ernie_functions.base.convert_python_function_to_ernie_function(...)"
    },
    {
      "type": "p",
      "content": "Convert a Python function to an Ernie function-calling API compatible dict."
    },
    {
      "type": "p",
      "content": "chains.ernie_functions.base.convert_to_ernie_function(...)"
    },
    {
      "type": "p",
      "content": "Convert a raw function/class to an Ernie function."
    },
    {
      "type": "p",
      "content": "chains.ernie_functions.base.create_ernie_fn_chain(...)"
    },
    {
      "type": "p",
      "content": "[Legacy] Create an LLM chain that uses Ernie functions."
    },
    {
      "type": "p",
      "content": "chains.ernie_functions.base.create_ernie_fn_runnable(...)"
    },
    {
      "type": "p",
      "content": "Create a runnable sequence that uses Ernie functions."
    },
    {
      "type": "p",
      "content": "chains.ernie_functions.base.create_structured_output_chain(...)"
    },
    {
      "type": "p",
      "content": "[Legacy] Create an LLMChain that uses an Ernie function to get a structured output."
    },
    {
      "type": "p",
      "content": "chains.ernie_functions.base.create_structured_output_runnable(...)"
    },
    {
      "type": "p",
      "content": "Create a runnable that uses an Ernie function to get a structured output."
    },
    {
      "type": "p",
      "content": "chains.ernie_functions.base.get_ernie_output_parser(...)"
    },
    {
      "type": "p",
      "content": "Get the appropriate function output parser given the user functions."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.falkordb.extract_cypher(text)"
    },
    {
      "type": "p",
      "content": "Extract Cypher code from a text."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.gremlin.extract_gremlin(text)"
    },
    {
      "type": "p",
      "content": "Extract Gremlin code from a text."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.kuzu.extract_cypher(text)"
    },
    {
      "type": "p",
      "content": "Extract Cypher code from a text."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.kuzu.remove_prefix(text, prefix)"
    },
    {
      "type": "p",
      "content": "Remove a prefix from a text."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.memgraph.extract_cypher(text)"
    },
    {
      "type": "p",
      "content": "Extract Cypher code from a text."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.memgraph.get_function_response(...)"
    },
    {
      "type": "p",
      "content": "chains.graph_qa.neptune_cypher.extract_cypher(text)"
    },
    {
      "type": "p",
      "content": "Extract Cypher code from text using Regex."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.neptune_cypher.trim_query(query)"
    },
    {
      "type": "p",
      "content": "Trim the query to only include Cypher keywords."
    },
    {
      "type": "p",
      "content": "chains.graph_qa.neptune_cypher.use_simple_prompt(llm)"
    },
    {
      "type": "p",
      "content": "Decides whether to use the simple prompt"
    },
    {
      "type": "p",
      "content": "chains.graph_qa.neptune_sparql.extract_sparql(query)"
    },
    {
      "type": "p",
      "content": "Extract SPARQL code from a text."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.enforcement_filters.clear_enforcement_filters(...)"
    },
    {
      "type": "p",
      "content": "Clear the identity and semantic enforcement filters in the retriever search_kwargs."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.enforcement_filters.set_enforcement_filters(...)"
    },
    {
      "type": "p",
      "content": "Set identity and semantic enforcement filters in the retriever."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.utilities.get_ip()"
    },
    {
      "type": "p",
      "content": "Fetch local runtime ip address."
    },
    {
      "type": "p",
      "content": "chains.pebblo_retrieval.utilities.get_runtime()"
    },
    {
      "type": "p",
      "content": "Fetch the current Framework and Runtime details."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "chains.graph_qa.cypher.GraphCypherQAChain"
    },
    {
      "type": "p",
      "content": "chains.graph_qa.cypher_utils.CypherQueryCorrector(schemas)"
    },
    {
      "type": "p",
      "content": "chains.graph_qa.neptune_cypher.NeptuneOpenCypherQAChain"
    },
    {
      "type": "p",
      "content": "chains.graph_qa.neptune_sparql.NeptuneSparqlQAChain"
    },
    {
      "type": "p",
      "content": "Deprecated functions"
    },
    {
      "type": "p",
      "content": "chains.graph_qa.cypher.construct_schema(...)"
    },
    {
      "type": "p",
      "content": "chains.graph_qa.cypher.extract_cypher(text)"
    },
    {
      "type": "p",
      "content": "chains.graph_qa.cypher.get_function_response(...)"
    },
    {
      "type": "h2",
      "content": "chat_loaders#"
    },
    {
      "type": "p",
      "content": "chat_loaders.facebook_messenger.FolderFacebookMessengerChatLoader(path)"
    },
    {
      "type": "p",
      "content": "LoadFacebook Messengerchat data from a folder."
    },
    {
      "type": "p",
      "content": "chat_loaders.facebook_messenger.SingleFileFacebookMessengerChatLoader(path)"
    },
    {
      "type": "p",
      "content": "LoadFacebook Messengerchat data from a single file."
    },
    {
      "type": "p",
      "content": "chat_loaders.imessage.IMessageChatLoader([path])"
    },
    {
      "type": "p",
      "content": "Load chat sessions from theiMessagechat.db SQLite file."
    },
    {
      "type": "p",
      "content": "chat_loaders.langsmith.LangSmithDatasetChatLoader(*, ...)"
    },
    {
      "type": "p",
      "content": "Load chat sessions from a LangSmith dataset with the \"chat\" data type."
    },
    {
      "type": "p",
      "content": "chat_loaders.langsmith.LangSmithRunChatLoader(runs)"
    },
    {
      "type": "p",
      "content": "Load chat sessions from a list of LangSmith \"llm\" runs."
    },
    {
      "type": "p",
      "content": "chat_loaders.slack.SlackChatLoader(path)"
    },
    {
      "type": "p",
      "content": "LoadSlackconversations from a dump zip file."
    },
    {
      "type": "p",
      "content": "chat_loaders.telegram.TelegramChatLoader(path)"
    },
    {
      "type": "p",
      "content": "Loadtelegramconversations to LangChain chat messages."
    },
    {
      "type": "p",
      "content": "chat_loaders.whatsapp.WhatsAppChatLoader(path)"
    },
    {
      "type": "p",
      "content": "LoadWhatsAppconversations from a dump zip file or directory."
    },
    {
      "type": "p",
      "content": "chat_loaders.imessage.nanoseconds_from_2001_to_datetime(...)"
    },
    {
      "type": "p",
      "content": "Convert nanoseconds since 2001 to a datetime object."
    },
    {
      "type": "p",
      "content": "chat_loaders.utils.map_ai_messages(...)"
    },
    {
      "type": "p",
      "content": "Convert messages from the specified 'sender' to AI messages."
    },
    {
      "type": "p",
      "content": "chat_loaders.utils.map_ai_messages_in_session(...)"
    },
    {
      "type": "p",
      "content": "Convert messages from the specified 'sender' to AI messages."
    },
    {
      "type": "p",
      "content": "chat_loaders.utils.merge_chat_runs(chat_sessions)"
    },
    {
      "type": "p",
      "content": "Merge chat runs together."
    },
    {
      "type": "p",
      "content": "chat_loaders.utils.merge_chat_runs_in_session(...)"
    },
    {
      "type": "p",
      "content": "Merge chat runs together in a chat session."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "chat_loaders.gmail.GMailLoader(creds[, n, ...])"
    },
    {
      "type": "h2",
      "content": "chat_message_histories#"
    },
    {
      "type": "p",
      "content": "chat_message_histories.cassandra.CassandraChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Chat message history that is backed by Cassandra."
    },
    {
      "type": "p",
      "content": "chat_message_histories.cosmos_db.CosmosDBChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Chat message history backed by Azure CosmosDB."
    },
    {
      "type": "p",
      "content": "chat_message_histories.dynamodb.DynamoDBChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Chat message history that stores history in AWS DynamoDB."
    },
    {
      "type": "p",
      "content": "chat_message_histories.file.FileChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Chat message history that stores history in a local file."
    },
    {
      "type": "p",
      "content": "chat_message_histories.firestore.FirestoreChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Chat message history backed by Google Firestore."
    },
    {
      "type": "p",
      "content": "chat_message_histories.kafka.ConsumeStartPosition(value)"
    },
    {
      "type": "p",
      "content": "Consume start position for Kafka consumer to get chat history messages."
    },
    {
      "type": "p",
      "content": "chat_message_histories.kafka.KafkaChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Chat message history stored in Kafka."
    },
    {
      "type": "p",
      "content": "chat_message_histories.momento.MomentoChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Chat message history cache that uses Momento as a backend."
    },
    {
      "type": "p",
      "content": "chat_message_histories.redis.RedisChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Chat message history stored in a Redis database."
    },
    {
      "type": "p",
      "content": "chat_message_histories.rocksetdb.RocksetChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Uses Rockset to store chat messages."
    },
    {
      "type": "p",
      "content": "chat_message_histories.sql.BaseMessageConverter()"
    },
    {
      "type": "p",
      "content": "Convert BaseMessage to the SQLAlchemy model."
    },
    {
      "type": "p",
      "content": "chat_message_histories.sql.DefaultMessageConverter(...)"
    },
    {
      "type": "p",
      "content": "The default message converter for SQLChatMessageHistory."
    },
    {
      "type": "p",
      "content": "chat_message_histories.sql.SQLChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Chat message history stored in an SQL database."
    },
    {
      "type": "p",
      "content": "chat_message_histories.streamlit.StreamlitChatMessageHistory([key])"
    },
    {
      "type": "p",
      "content": "Chat message history that stores messages in Streamlit session state."
    },
    {
      "type": "p",
      "content": "chat_message_histories.tidb.TiDBChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Represents a chat message history stored in a TiDB database."
    },
    {
      "type": "p",
      "content": "chat_message_histories.upstash_redis.UpstashRedisChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Chat message history stored in an Upstash Redis database."
    },
    {
      "type": "p",
      "content": "chat_message_histories.xata.XataChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Chat message history stored in a Xata database."
    },
    {
      "type": "p",
      "content": "chat_message_histories.zep.SearchScope(value)"
    },
    {
      "type": "p",
      "content": "Scope for the document search."
    },
    {
      "type": "p",
      "content": "chat_message_histories.zep.SearchType(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of the types of search to perform."
    },
    {
      "type": "p",
      "content": "chat_message_histories.zep.ZepChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Chat message history that uses Zep as a backend."
    },
    {
      "type": "p",
      "content": "chat_message_histories.zep_cloud.ZepCloudChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "Chat message history that uses Zep Cloud as a backend."
    },
    {
      "type": "p",
      "content": "chat_message_histories.dynamodb.convert_messages(item)"
    },
    {
      "type": "p",
      "content": "chat_message_histories.kafka.ensure_topic_exists(...)"
    },
    {
      "type": "p",
      "content": "Create topic if it doesn't exist, and return the number of partitions."
    },
    {
      "type": "p",
      "content": "chat_message_histories.sql.create_message_model(...)"
    },
    {
      "type": "p",
      "content": "Create a message model for a given table name."
    },
    {
      "type": "p",
      "content": "chat_message_histories.zep_cloud.condense_zep_memory_into_human_message(...)"
    },
    {
      "type": "p",
      "content": "Condense Zep memory into a human message."
    },
    {
      "type": "p",
      "content": "chat_message_histories.zep_cloud.get_zep_message_role_type(role)"
    },
    {
      "type": "p",
      "content": "Get the Zep role type from the role string."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "chat_message_histories.astradb.AstraDBChatMessageHistory(*, ...)"
    },
    {
      "type": "p",
      "content": "chat_message_histories.elasticsearch.ElasticsearchChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "chat_message_histories.mongodb.MongoDBChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "chat_message_histories.neo4j.Neo4jChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "chat_message_histories.postgres.PostgresChatMessageHistory(...)"
    },
    {
      "type": "p",
      "content": "chat_message_histories.singlestoredb.SingleStoreDBChatMessageHistory(...)"
    },
    {
      "type": "h2",
      "content": "chat_models#"
    },
    {
      "type": "p",
      "content": "chat_models.anyscale.ChatAnyscale"
    },
    {
      "type": "p",
      "content": "AnyscaleChat large language models."
    },
    {
      "type": "p",
      "content": "chat_models.azureml_endpoint.AzureMLChatOnlineEndpoint"
    },
    {
      "type": "p",
      "content": "Azure ML Online Endpoint chat models."
    },
    {
      "type": "p",
      "content": "chat_models.azureml_endpoint.CustomOpenAIChatContentFormatter()"
    },
    {
      "type": "p",
      "content": "Chat Content formatter for models with OpenAI like API scheme."
    },
    {
      "type": "p",
      "content": "chat_models.azureml_endpoint.LlamaChatContentFormatter()"
    },
    {
      "type": "p",
      "content": "Deprecated: Kept for backwards compatibility"
    },
    {
      "type": "p",
      "content": "chat_models.azureml_endpoint.LlamaContentFormatter()"
    },
    {
      "type": "p",
      "content": "Content formatter forLLaMA."
    },
    {
      "type": "p",
      "content": "chat_models.azureml_endpoint.MistralChatContentFormatter()"
    },
    {
      "type": "p",
      "content": "Content formatter forMistral."
    },
    {
      "type": "p",
      "content": "chat_models.baichuan.ChatBaichuan"
    },
    {
      "type": "p",
      "content": "Baichuan chat model integration."
    },
    {
      "type": "p",
      "content": "chat_models.baidu_qianfan_endpoint.QianfanChatEndpoint"
    },
    {
      "type": "p",
      "content": "Baidu Qianfan chat model integration."
    },
    {
      "type": "p",
      "content": "chat_models.bedrock.ChatPromptAdapter()"
    },
    {
      "type": "p",
      "content": "Adapter class to prepare the inputs from Langchain to prompt format that Chat model expects."
    },
    {
      "type": "p",
      "content": "chat_models.coze.ChatCoze"
    },
    {
      "type": "p",
      "content": "ChatCoze chat models API by coze.com"
    },
    {
      "type": "p",
      "content": "chat_models.dappier.ChatDappierAI"
    },
    {
      "type": "p",
      "content": "Dappierchat large language models."
    },
    {
      "type": "p",
      "content": "chat_models.deepinfra.ChatDeepInfra"
    },
    {
      "type": "p",
      "content": "A chat model that uses the DeepInfra API."
    },
    {
      "type": "p",
      "content": "chat_models.deepinfra.ChatDeepInfraException"
    },
    {
      "type": "p",
      "content": "Exception raised when the DeepInfra API returns an error."
    },
    {
      "type": "p",
      "content": "chat_models.edenai.ChatEdenAI"
    },
    {
      "type": "p",
      "content": "EdenAIchat large language models."
    },
    {
      "type": "p",
      "content": "chat_models.everlyai.ChatEverlyAI"
    },
    {
      "type": "p",
      "content": "EverlyAIChat large language models."
    },
    {
      "type": "p",
      "content": "chat_models.fake.FakeListChatModel"
    },
    {
      "type": "p",
      "content": "Fake ChatModel for testing purposes."
    },
    {
      "type": "p",
      "content": "chat_models.fake.FakeMessagesListChatModel"
    },
    {
      "type": "p",
      "content": "Fake ChatModel for testing purposes."
    },
    {
      "type": "p",
      "content": "chat_models.friendli.ChatFriendli"
    },
    {
      "type": "p",
      "content": "Friendli LLM for chat."
    },
    {
      "type": "p",
      "content": "chat_models.google_palm.ChatGooglePalm"
    },
    {
      "type": "p",
      "content": "Google PaLMChat models API."
    },
    {
      "type": "p",
      "content": "chat_models.google_palm.ChatGooglePalmError"
    },
    {
      "type": "p",
      "content": "Error with theGoogle PaLMAPI."
    },
    {
      "type": "p",
      "content": "chat_models.gpt_router.GPTRouter"
    },
    {
      "type": "p",
      "content": "GPTRouter by Writesonic Inc."
    },
    {
      "type": "p",
      "content": "chat_models.gpt_router.GPTRouterException"
    },
    {
      "type": "p",
      "content": "Error with theGPTRouter APIs"
    },
    {
      "type": "p",
      "content": "chat_models.gpt_router.GPTRouterModel"
    },
    {
      "type": "p",
      "content": "GPTRouter model."
    },
    {
      "type": "p",
      "content": "chat_models.human.HumanInputChatModel"
    },
    {
      "type": "p",
      "content": "ChatModel which returns user input as the response."
    },
    {
      "type": "p",
      "content": "chat_models.hunyuan.ChatHunyuan"
    },
    {
      "type": "p",
      "content": "Tencent Hunyuan chat models API by Tencent."
    },
    {
      "type": "p",
      "content": "chat_models.javelin_ai_gateway.ChatJavelinAIGateway"
    },
    {
      "type": "p",
      "content": "Javelin AI Gatewaychat models API."
    },
    {
      "type": "p",
      "content": "chat_models.javelin_ai_gateway.ChatParams"
    },
    {
      "type": "p",
      "content": "Parameters for theJavelin AI GatewayLLM."
    },
    {
      "type": "p",
      "content": "chat_models.jinachat.JinaChat"
    },
    {
      "type": "p",
      "content": "Jina AIChat models API."
    },
    {
      "type": "p",
      "content": "chat_models.kinetica.ChatKinetica"
    },
    {
      "type": "p",
      "content": "Kinetica LLM Chat Model API."
    },
    {
      "type": "p",
      "content": "chat_models.kinetica.KineticaSqlOutputParser"
    },
    {
      "type": "p",
      "content": "Fetch and return data from the Kinetica LLM."
    },
    {
      "type": "p",
      "content": "chat_models.kinetica.KineticaSqlResponse"
    },
    {
      "type": "p",
      "content": "Response containing SQL and the fetched data."
    },
    {
      "type": "p",
      "content": "chat_models.kinetica.KineticaUtil()"
    },
    {
      "type": "p",
      "content": "Kinetica utility functions."
    },
    {
      "type": "p",
      "content": "chat_models.konko.ChatKonko"
    },
    {
      "type": "p",
      "content": "ChatKonkoChat large language models API."
    },
    {
      "type": "p",
      "content": "chat_models.litellm.ChatLiteLLMException"
    },
    {
      "type": "p",
      "content": "Error with theLiteLLM I/Olibrary"
    },
    {
      "type": "p",
      "content": "chat_models.llama_edge.LlamaEdgeChatService"
    },
    {
      "type": "p",
      "content": "Chat with LLMs viallama-api-server"
    },
    {
      "type": "p",
      "content": "chat_models.llamacpp.ChatLlamaCpp"
    },
    {
      "type": "p",
      "content": "llama.cpp model."
    },
    {
      "type": "p",
      "content": "chat_models.maritalk.ChatMaritalk"
    },
    {
      "type": "p",
      "content": "MariTalkChat models API."
    },
    {
      "type": "p",
      "content": "chat_models.maritalk.MaritalkHTTPError(...)"
    },
    {
      "type": "p",
      "content": "Initialize RequestException withrequestandresponseobjects."
    },
    {
      "type": "p",
      "content": "chat_models.minimax.MiniMaxChat"
    },
    {
      "type": "p",
      "content": "MiniMax chat model integration."
    },
    {
      "type": "p",
      "content": "chat_models.mlflow.ChatMlflow"
    },
    {
      "type": "p",
      "content": "MLflowchat models API."
    },
    {
      "type": "p",
      "content": "chat_models.mlflow_ai_gateway.ChatMLflowAIGateway"
    },
    {
      "type": "p",
      "content": "MLflow AI Gatewaychat models API."
    },
    {
      "type": "p",
      "content": "chat_models.mlflow_ai_gateway.ChatParams"
    },
    {
      "type": "p",
      "content": "Parameters for theMLflow AI GatewayLLM."
    },
    {
      "type": "p",
      "content": "chat_models.mlx.ChatMLX"
    },
    {
      "type": "p",
      "content": "MLX chat models."
    },
    {
      "type": "p",
      "content": "chat_models.moonshot.MoonshotChat"
    },
    {
      "type": "p",
      "content": "Moonshot chat model integration."
    },
    {
      "type": "p",
      "content": "chat_models.naver.ChatClovaX"
    },
    {
      "type": "p",
      "content": "NCP ClovaStudioChat Completion API."
    },
    {
      "type": "p",
      "content": "chat_models.oci_data_science.ChatOCIModelDeployment"
    },
    {
      "type": "p",
      "content": "OCI Data Science Model Deployment chat model integration."
    },
    {
      "type": "p",
      "content": "chat_models.oci_data_science.ChatOCIModelDeploymentTGI"
    },
    {
      "type": "p",
      "content": "OCI large language chat models deployed with Text Generation Inference."
    },
    {
      "type": "p",
      "content": "chat_models.oci_data_science.ChatOCIModelDeploymentVLLM"
    },
    {
      "type": "p",
      "content": "OCI large language chat models deployed with vLLM."
    },
    {
      "type": "p",
      "content": "chat_models.oci_generative_ai.ChatOCIGenAI"
    },
    {
      "type": "p",
      "content": "ChatOCIGenAI chat model integration."
    },
    {
      "type": "p",
      "content": "chat_models.oci_generative_ai.CohereProvider()"
    },
    {
      "type": "p",
      "content": "chat_models.oci_generative_ai.MetaProvider()"
    },
    {
      "type": "p",
      "content": "chat_models.oci_generative_ai.Provider()"
    },
    {
      "type": "p",
      "content": "chat_models.octoai.ChatOctoAI"
    },
    {
      "type": "p",
      "content": "OctoAI Chat large language models."
    },
    {
      "type": "p",
      "content": "chat_models.outlines.ChatOutlines"
    },
    {
      "type": "p",
      "content": "Outlines chat model integration."
    },
    {
      "type": "p",
      "content": "chat_models.pai_eas_endpoint.PaiEasChatEndpoint"
    },
    {
      "type": "p",
      "content": "Alibaba Cloud PAI-EAS LLM Service chat model API."
    },
    {
      "type": "p",
      "content": "chat_models.premai.ChatPremAI"
    },
    {
      "type": "p",
      "content": "PremAI Chat models."
    },
    {
      "type": "p",
      "content": "chat_models.premai.ChatPremAPIError"
    },
    {
      "type": "p",
      "content": "Error with thePremAIAPI."
    },
    {
      "type": "p",
      "content": "chat_models.promptlayer_openai.PromptLayerChatOpenAI"
    },
    {
      "type": "p",
      "content": "PromptLayerandOpenAIChat large language models API."
    },
    {
      "type": "p",
      "content": "chat_models.reka.ChatReka"
    },
    {
      "type": "p",
      "content": "Reka chat large language models."
    },
    {
      "type": "p",
      "content": "chat_models.snowflake.ChatSnowflakeCortex"
    },
    {
      "type": "p",
      "content": "Snowflake Cortex based Chat model"
    },
    {
      "type": "p",
      "content": "chat_models.snowflake.ChatSnowflakeCortexError"
    },
    {
      "type": "p",
      "content": "Error with Snowpark client."
    },
    {
      "type": "p",
      "content": "chat_models.sparkllm.ChatSparkLLM"
    },
    {
      "type": "p",
      "content": "IFlyTek Spark chat model integration."
    },
    {
      "type": "p",
      "content": "chat_models.symblai_nebula.ChatNebula"
    },
    {
      "type": "p",
      "content": "Nebulachat large language model -https://docs.symbl.ai/docs/nebula-llm"
    },
    {
      "type": "p",
      "content": "chat_models.tongyi.ChatTongyi"
    },
    {
      "type": "p",
      "content": "Alibaba Tongyi Qwen chat model integration."
    },
    {
      "type": "p",
      "content": "chat_models.volcengine_maas.VolcEngineMaasChat"
    },
    {
      "type": "p",
      "content": "Volc Engine Maas hosts a plethora of models."
    },
    {
      "type": "p",
      "content": "chat_models.writer.ChatWriter"
    },
    {
      "type": "p",
      "content": "Writer chat model."
    },
    {
      "type": "p",
      "content": "chat_models.yandex.ChatYandexGPT"
    },
    {
      "type": "p",
      "content": "YandexGPT large language models."
    },
    {
      "type": "p",
      "content": "chat_models.yi.ChatYi"
    },
    {
      "type": "p",
      "content": "Yi chat models API."
    },
    {
      "type": "p",
      "content": "chat_models.yuan2.ChatYuan2"
    },
    {
      "type": "p",
      "content": "Yuan2.0Chat models API."
    },
    {
      "type": "p",
      "content": "chat_models.zhipuai.ChatZhipuAI"
    },
    {
      "type": "p",
      "content": "ZhipuAI chat model integration."
    },
    {
      "type": "p",
      "content": "chat_models.anthropic.convert_messages_to_prompt_anthropic(...)"
    },
    {
      "type": "p",
      "content": "Format a list of messages into a full prompt for the Anthropic model"
    },
    {
      "type": "p",
      "content": "chat_models.baichuan.aconnect_httpx_sse(...)"
    },
    {
      "type": "p",
      "content": "Async context manager for connecting to an SSE stream."
    },
    {
      "type": "p",
      "content": "chat_models.baidu_qianfan_endpoint.convert_message_to_dict(message)"
    },
    {
      "type": "p",
      "content": "Convert a message to a dictionary that can be passed to the API."
    },
    {
      "type": "p",
      "content": "chat_models.bedrock.convert_messages_to_prompt_mistral(...)"
    },
    {
      "type": "p",
      "content": "Convert a list of messages to a prompt for mistral."
    },
    {
      "type": "p",
      "content": "chat_models.cohere.get_cohere_chat_request(...)"
    },
    {
      "type": "p",
      "content": "Get the request for the Cohere chat API."
    },
    {
      "type": "p",
      "content": "chat_models.cohere.get_role(message)"
    },
    {
      "type": "p",
      "content": "Get the role of the message."
    },
    {
      "type": "p",
      "content": "chat_models.fireworks.acompletion_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the async completion call."
    },
    {
      "type": "p",
      "content": "chat_models.fireworks.acompletion_with_retry_streaming(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call for streaming."
    },
    {
      "type": "p",
      "content": "chat_models.fireworks.completion_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "chat_models.fireworks.conditional_decorator(...)"
    },
    {
      "type": "p",
      "content": "Define conditional decorator."
    },
    {
      "type": "p",
      "content": "chat_models.fireworks.convert_dict_to_message(_dict)"
    },
    {
      "type": "p",
      "content": "Convert a dict response to a message."
    },
    {
      "type": "p",
      "content": "chat_models.friendli.get_chat_request(messages)"
    },
    {
      "type": "p",
      "content": "Get a request of the Friendli chat API."
    },
    {
      "type": "p",
      "content": "chat_models.friendli.get_role(message)"
    },
    {
      "type": "p",
      "content": "Get role of the message."
    },
    {
      "type": "p",
      "content": "chat_models.google_palm.achat_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the async completion call."
    },
    {
      "type": "p",
      "content": "chat_models.google_palm.chat_with_retry(llm, ...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "chat_models.gpt_router.acompletion_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the async completion call."
    },
    {
      "type": "p",
      "content": "chat_models.gpt_router.completion_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "chat_models.gpt_router.get_ordered_generation_requests(...)"
    },
    {
      "type": "p",
      "content": "Return the body for the model router input."
    },
    {
      "type": "p",
      "content": "chat_models.jinachat.acompletion_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the async completion call."
    },
    {
      "type": "p",
      "content": "chat_models.litellm.acompletion_with_retry(llm)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the async completion call."
    },
    {
      "type": "p",
      "content": "chat_models.litellm_router.get_llm_output(...)"
    },
    {
      "type": "p",
      "content": "Get llm output from usage and params."
    },
    {
      "type": "p",
      "content": "chat_models.meta.convert_messages_to_prompt_llama(...)"
    },
    {
      "type": "p",
      "content": "Convert a list of messages to a prompt for llama."
    },
    {
      "type": "p",
      "content": "chat_models.minimax.aconnect_httpx_sse(...)"
    },
    {
      "type": "p",
      "content": "Async context manager for connecting to an SSE stream."
    },
    {
      "type": "p",
      "content": "chat_models.minimax.connect_httpx_sse(...)"
    },
    {
      "type": "p",
      "content": "Context manager for connecting to an SSE stream."
    },
    {
      "type": "p",
      "content": "chat_models.openai.acompletion_with_retry(llm)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the async completion call."
    },
    {
      "type": "p",
      "content": "chat_models.premai.chat_with_retry(llm, ...)"
    },
    {
      "type": "p",
      "content": "Using tenacity for retry in completion call"
    },
    {
      "type": "p",
      "content": "chat_models.premai.create_prem_retry_decorator(llm, *)"
    },
    {
      "type": "p",
      "content": "Create a retry decorator for PremAI API errors."
    },
    {
      "type": "p",
      "content": "chat_models.reka.convert_to_reka_messages(...)"
    },
    {
      "type": "p",
      "content": "Convert LangChain messages to Reka message format."
    },
    {
      "type": "p",
      "content": "chat_models.reka.process_content(content)"
    },
    {
      "type": "p",
      "content": "Process content to handle both text and media inputs, returning a list of content items."
    },
    {
      "type": "p",
      "content": "chat_models.reka.process_content_item(item)"
    },
    {
      "type": "p",
      "content": "Process a single content item."
    },
    {
      "type": "p",
      "content": "chat_models.sparkllm.convert_dict_to_message(_dict)"
    },
    {
      "type": "p",
      "content": "chat_models.sparkllm.convert_message_to_dict(message)"
    },
    {
      "type": "p",
      "content": "chat_models.tongyi.convert_dict_to_message(_dict)"
    },
    {
      "type": "p",
      "content": "Convert a dict to a message."
    },
    {
      "type": "p",
      "content": "chat_models.tongyi.convert_message_chunk_to_message(...)"
    },
    {
      "type": "p",
      "content": "Convert a message chunk to a message."
    },
    {
      "type": "p",
      "content": "chat_models.tongyi.convert_message_to_dict(message)"
    },
    {
      "type": "p",
      "content": "Convert a message to a dict."
    },
    {
      "type": "p",
      "content": "chat_models.volcengine_maas.convert_dict_to_message(_dict)"
    },
    {
      "type": "p",
      "content": "Convert a dict to a message."
    },
    {
      "type": "p",
      "content": "chat_models.yandex.acompletion_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the async completion call."
    },
    {
      "type": "p",
      "content": "chat_models.yandex.completion_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "chat_models.yi.aconnect_httpx_sse(client, ...)"
    },
    {
      "type": "p",
      "content": "chat_models.yuan2.acompletion_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the async completion call."
    },
    {
      "type": "p",
      "content": "chat_models.zhipuai.aconnect_sse(client, ...)"
    },
    {
      "type": "p",
      "content": "Async context manager for connecting to an SSE stream."
    },
    {
      "type": "p",
      "content": "chat_models.zhipuai.connect_sse(client, ...)"
    },
    {
      "type": "p",
      "content": "Context manager for connecting to an SSE stream."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "chat_models.anthropic.ChatAnthropic"
    },
    {
      "type": "p",
      "content": "chat_models.azure_openai.AzureChatOpenAI"
    },
    {
      "type": "p",
      "content": "chat_models.bedrock.BedrockChat"
    },
    {
      "type": "p",
      "content": "chat_models.cloudflare_workersai.ChatCloudflareWorkersAI"
    },
    {
      "type": "p",
      "content": "chat_models.cohere.ChatCohere"
    },
    {
      "type": "p",
      "content": "chat_models.databricks.ChatDatabricks"
    },
    {
      "type": "p",
      "content": "chat_models.ernie.ErnieBotChat"
    },
    {
      "type": "p",
      "content": "chat_models.fireworks.ChatFireworks"
    },
    {
      "type": "p",
      "content": "chat_models.gigachat.GigaChat"
    },
    {
      "type": "p",
      "content": "chat_models.huggingface.ChatHuggingFace"
    },
    {
      "type": "p",
      "content": "chat_models.litellm.ChatLiteLLM"
    },
    {
      "type": "p",
      "content": "chat_models.litellm_router.ChatLiteLLMRouter"
    },
    {
      "type": "p",
      "content": "chat_models.ollama.ChatOllama"
    },
    {
      "type": "p",
      "content": "chat_models.openai.ChatOpenAI"
    },
    {
      "type": "p",
      "content": "chat_models.perplexity.ChatPerplexity"
    },
    {
      "type": "p",
      "content": "chat_models.sambanova.ChatSambaNovaCloud"
    },
    {
      "type": "p",
      "content": "chat_models.sambanova.ChatSambaStudio"
    },
    {
      "type": "p",
      "content": "chat_models.solar.SolarChat"
    },
    {
      "type": "p",
      "content": "chat_models.vertexai.ChatVertexAI"
    },
    {
      "type": "h2",
      "content": "cross_encoders#"
    },
    {
      "type": "p",
      "content": "cross_encoders.fake.FakeCrossEncoder"
    },
    {
      "type": "p",
      "content": "Fake cross encoder model."
    },
    {
      "type": "p",
      "content": "cross_encoders.huggingface.HuggingFaceCrossEncoder"
    },
    {
      "type": "p",
      "content": "HuggingFace cross encoder models."
    },
    {
      "type": "p",
      "content": "cross_encoders.sagemaker_endpoint.CrossEncoderContentHandler()"
    },
    {
      "type": "p",
      "content": "Content handler for CrossEncoder class."
    },
    {
      "type": "p",
      "content": "cross_encoders.sagemaker_endpoint.SagemakerEndpointCrossEncoder"
    },
    {
      "type": "p",
      "content": "SageMaker Inference CrossEncoder endpoint."
    },
    {
      "type": "p",
      "content": "docstore.arbitrary_fn.DocstoreFn(lookup_fn)"
    },
    {
      "type": "p",
      "content": "Docstore via arbitrary lookup function."
    },
    {
      "type": "p",
      "content": "docstore.base.AddableMixin()"
    },
    {
      "type": "p",
      "content": "Mixin class that supports adding texts."
    },
    {
      "type": "p",
      "content": "docstore.base.Docstore()"
    },
    {
      "type": "p",
      "content": "Interface to access to place that stores documents."
    },
    {
      "type": "p",
      "content": "docstore.in_memory.InMemoryDocstore([_dict])"
    },
    {
      "type": "p",
      "content": "Simple in memory docstore in the form of a dict."
    },
    {
      "type": "p",
      "content": "docstore.wikipedia.Wikipedia()"
    },
    {
      "type": "p",
      "content": "Wikipedia API."
    },
    {
      "type": "h2",
      "content": "document_compressors#"
    },
    {
      "type": "p",
      "content": "document_compressors.dashscope_rerank.DashScopeRerank"
    },
    {
      "type": "p",
      "content": "Document compressor that usesDashScope Rerank API."
    },
    {
      "type": "p",
      "content": "document_compressors.flashrank_rerank.FlashrankRerank"
    },
    {
      "type": "p",
      "content": "Document compressor using Flashrank interface."
    },
    {
      "type": "p",
      "content": "document_compressors.infinity_rerank.InfinityRerank"
    },
    {
      "type": "p",
      "content": "Document compressor that usesInfinity Rerank API."
    },
    {
      "type": "p",
      "content": "document_compressors.jina_rerank.JinaRerank"
    },
    {
      "type": "p",
      "content": "Document compressor that usesJina Rerank API."
    },
    {
      "type": "p",
      "content": "document_compressors.llmlingua_filter.LLMLinguaCompressor"
    },
    {
      "type": "p",
      "content": "Compress using LLMLingua Project."
    },
    {
      "type": "p",
      "content": "document_compressors.openvino_rerank.OpenVINOReranker"
    },
    {
      "type": "p",
      "content": "OpenVINO rerank models."
    },
    {
      "type": "p",
      "content": "document_compressors.openvino_rerank.RerankRequest([...])"
    },
    {
      "type": "p",
      "content": "Request for reranking."
    },
    {
      "type": "p",
      "content": "document_compressors.rankllm_rerank.ModelType(value)"
    },
    {
      "type": "p",
      "content": "document_compressors.rankllm_rerank.RankLLMRerank"
    },
    {
      "type": "p",
      "content": "Document compressor using Flashrank interface."
    },
    {
      "type": "p",
      "content": "document_compressors.volcengine_rerank.VolcengineRerank"
    },
    {
      "type": "p",
      "content": "Document compressor that usesVolcengine Rerank API."
    },
    {
      "type": "h2",
      "content": "document_loaders#"
    },
    {
      "type": "p",
      "content": "document_loaders.acreom.AcreomLoader(path[, ...])"
    },
    {
      "type": "p",
      "content": "Loadacreomvault from a directory."
    },
    {
      "type": "p",
      "content": "document_loaders.airbyte.AirbyteCDKLoader(...)"
    },
    {
      "type": "p",
      "content": "Load with anAirbytesource connector implemented using theCDK."
    },
    {
      "type": "p",
      "content": "document_loaders.airbyte.AirbyteGongLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromGongusing anAirbytesource connector."
    },
    {
      "type": "p",
      "content": "document_loaders.airbyte.AirbyteHubspotLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromHubspotusing anAirbytesource connector."
    },
    {
      "type": "p",
      "content": "document_loaders.airbyte.AirbyteSalesforceLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromSalesforceusing anAirbytesource connector."
    },
    {
      "type": "p",
      "content": "document_loaders.airbyte.AirbyteShopifyLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromShopifyusing anAirbytesource connector."
    },
    {
      "type": "p",
      "content": "document_loaders.airbyte.AirbyteStripeLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromStripeusing anAirbytesource connector."
    },
    {
      "type": "p",
      "content": "document_loaders.airbyte.AirbyteTypeformLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromTypeformusing anAirbytesource connector."
    },
    {
      "type": "p",
      "content": "document_loaders.airbyte.AirbyteZendeskSupportLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromZendesk Supportusing anAirbytesource connector."
    },
    {
      "type": "p",
      "content": "document_loaders.airbyte_json.AirbyteJSONLoader(...)"
    },
    {
      "type": "p",
      "content": "Load localAirbytejson files."
    },
    {
      "type": "p",
      "content": "document_loaders.airtable.AirtableLoader(...)"
    },
    {
      "type": "p",
      "content": "Load theAirtabletables."
    },
    {
      "type": "p",
      "content": "document_loaders.arcgis_loader.ArcGISLoader(layer)"
    },
    {
      "type": "p",
      "content": "Load records from an ArcGIS FeatureLayer."
    },
    {
      "type": "p",
      "content": "document_loaders.arxiv.ArxivLoader(query[, ...])"
    },
    {
      "type": "p",
      "content": "Load a query result fromArxiv."
    },
    {
      "type": "p",
      "content": "document_loaders.assemblyai.AssemblyAIAudioLoaderById(...)"
    },
    {
      "type": "p",
      "content": "Load AssemblyAI audio transcripts."
    },
    {
      "type": "p",
      "content": "document_loaders.assemblyai.AssemblyAIAudioTranscriptLoader(...)"
    },
    {
      "type": "p",
      "content": "Load AssemblyAI audio transcripts."
    },
    {
      "type": "p",
      "content": "document_loaders.assemblyai.TranscriptFormat(value)"
    },
    {
      "type": "p",
      "content": "Transcript format to use for the document loader."
    },
    {
      "type": "p",
      "content": "document_loaders.async_html.AsyncHtmlLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadHTMLasynchronously."
    },
    {
      "type": "p",
      "content": "document_loaders.athena.AthenaLoader(query, ...)"
    },
    {
      "type": "p",
      "content": "Load documents fromAWS Athena."
    },
    {
      "type": "p",
      "content": "document_loaders.azlyrics.AZLyricsLoader([...])"
    },
    {
      "type": "p",
      "content": "LoadAZLyricswebpages."
    },
    {
      "type": "p",
      "content": "document_loaders.azure_ai_data.AzureAIDataLoader(url)"
    },
    {
      "type": "p",
      "content": "Load from Azure AI Data."
    },
    {
      "type": "p",
      "content": "document_loaders.azure_blob_storage_container.AzureBlobStorageContainerLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromAzure Blob Storagecontainer."
    },
    {
      "type": "p",
      "content": "document_loaders.azure_blob_storage_file.AzureBlobStorageFileLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromAzure Blob Storagefiles."
    },
    {
      "type": "p",
      "content": "document_loaders.baiducloud_bos_directory.BaiduBOSDirectoryLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromBaidu BOS directory."
    },
    {
      "type": "p",
      "content": "document_loaders.baiducloud_bos_file.BaiduBOSFileLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromBaidu Cloud BOSfile."
    },
    {
      "type": "p",
      "content": "document_loaders.base_o365.O365BaseLoader"
    },
    {
      "type": "p",
      "content": "Base class for all loaders that uses O365 Package"
    },
    {
      "type": "p",
      "content": "document_loaders.bibtex.BibtexLoader(...[, ...])"
    },
    {
      "type": "p",
      "content": "Load abibtexfile."
    },
    {
      "type": "p",
      "content": "document_loaders.bilibili.BiliBiliLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fetching transcripts from BiliBili videos."
    },
    {
      "type": "p",
      "content": "document_loaders.blackboard.BlackboardLoader(...)"
    },
    {
      "type": "p",
      "content": "Load aBlackboardcourse."
    },
    {
      "type": "p",
      "content": "document_loaders.blob_loaders.cloud_blob_loader.CloudBlobLoader(url, *)"
    },
    {
      "type": "p",
      "content": "Load blobs from cloud URL or file:."
    },
    {
      "type": "p",
      "content": "document_loaders.blob_loaders.file_system.FileSystemBlobLoader(path, *)"
    },
    {
      "type": "p",
      "content": "Load blobs in the local file system."
    },
    {
      "type": "p",
      "content": "document_loaders.blob_loaders.youtube_audio.YoutubeAudioLoader(...)"
    },
    {
      "type": "p",
      "content": "Load YouTube urls as audio file(s)."
    },
    {
      "type": "p",
      "content": "document_loaders.blockchain.BlockchainDocumentLoader(...)"
    },
    {
      "type": "p",
      "content": "Load elements from a blockchain smart contract."
    },
    {
      "type": "p",
      "content": "document_loaders.blockchain.BlockchainType(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of the supported blockchains."
    },
    {
      "type": "p",
      "content": "document_loaders.brave_search.BraveSearchLoader(...)"
    },
    {
      "type": "p",
      "content": "Load withBrave Searchengine."
    },
    {
      "type": "p",
      "content": "document_loaders.browserbase.BrowserbaseLoader(urls)"
    },
    {
      "type": "p",
      "content": "Load pre-rendered web pages using a headless browser hosted on Browserbase."
    },
    {
      "type": "p",
      "content": "document_loaders.browserless.BrowserlessLoader(...)"
    },
    {
      "type": "p",
      "content": "Load webpages withBrowserless/content endpoint."
    },
    {
      "type": "p",
      "content": "document_loaders.cassandra.CassandraLoader(...)"
    },
    {
      "type": "p",
      "content": "Document Loader for Apache Cassandra."
    },
    {
      "type": "p",
      "content": "document_loaders.chatgpt.ChatGPTLoader(log_file)"
    },
    {
      "type": "p",
      "content": "Load conversations from exportedChatGPTdata."
    },
    {
      "type": "p",
      "content": "document_loaders.chm.CHMParser(path)"
    },
    {
      "type": "p",
      "content": "Microsoft Compiled HTML Help (CHM) Parser."
    },
    {
      "type": "p",
      "content": "document_loaders.chm.UnstructuredCHMLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadCHMfiles usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.chromium.AsyncChromiumLoader(urls, *)"
    },
    {
      "type": "p",
      "content": "Scrape HTML pages from URLs using a headless instance of the Chromium."
    },
    {
      "type": "p",
      "content": "document_loaders.college_confidential.CollegeConfidentialLoader([...])"
    },
    {
      "type": "p",
      "content": "LoadCollege Confidentialwebpages."
    },
    {
      "type": "p",
      "content": "document_loaders.concurrent.ConcurrentLoader(...)"
    },
    {
      "type": "p",
      "content": "Load and pars Documents concurrently."
    },
    {
      "type": "p",
      "content": "document_loaders.confluence.ConfluenceLoader(url)"
    },
    {
      "type": "p",
      "content": "LoadConfluencepages."
    },
    {
      "type": "p",
      "content": "document_loaders.confluence.ContentFormat(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of the content formats of Confluence page."
    },
    {
      "type": "p",
      "content": "document_loaders.conllu.CoNLLULoader(file_path)"
    },
    {
      "type": "p",
      "content": "LoadCoNLL-Ufiles."
    },
    {
      "type": "p",
      "content": "document_loaders.couchbase.CouchbaseLoader(...)"
    },
    {
      "type": "p",
      "content": "Load documents fromCouchbase."
    },
    {
      "type": "p",
      "content": "document_loaders.csv_loader.CSVLoader(file_path)"
    },
    {
      "type": "p",
      "content": "Load aCSVfile into a list of Documents."
    },
    {
      "type": "p",
      "content": "document_loaders.csv_loader.UnstructuredCSVLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadCSVfiles usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.cube_semantic.CubeSemanticLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadCube semantic layermetadata."
    },
    {
      "type": "p",
      "content": "document_loaders.datadog_logs.DatadogLogsLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadDatadoglogs."
    },
    {
      "type": "p",
      "content": "document_loaders.dataframe.BaseDataFrameLoader(...)"
    },
    {
      "type": "p",
      "content": "Initialize with dataframe object."
    },
    {
      "type": "p",
      "content": "document_loaders.dataframe.DataFrameLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadPandasDataFrame."
    },
    {
      "type": "p",
      "content": "document_loaders.dedoc.DedocAPIFileLoader(...)"
    },
    {
      "type": "p",
      "content": "Load files usingdedocAPI. The file loader automatically detects the file type (even with the wrong extension). By default, the loader makes a call to the locally hosteddedocAPI. More information aboutdedocAPI can be found indedocdocumentation:https://dedoc.readthedocs.io/en/latest/dedoc_api_usage/api.html."
    },
    {
      "type": "p",
      "content": "document_loaders.dedoc.DedocBaseLoader(...)"
    },
    {
      "type": "p",
      "content": "Base Loader that usesdedoc(https://dedoc.readthedocs.io)."
    },
    {
      "type": "p",
      "content": "document_loaders.dedoc.DedocFileLoader(...)"
    },
    {
      "type": "p",
      "content": "DedocFileLoader document loader integration to load files usingdedoc."
    },
    {
      "type": "p",
      "content": "document_loaders.diffbot.DiffbotLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadDiffbotjson file."
    },
    {
      "type": "p",
      "content": "document_loaders.directory.DirectoryLoader(...)"
    },
    {
      "type": "p",
      "content": "Load from a directory."
    },
    {
      "type": "p",
      "content": "document_loaders.discord.DiscordChatLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadDiscordchat logs."
    },
    {
      "type": "p",
      "content": "document_loaders.doc_intelligence.AzureAIDocumentIntelligenceLoader(...)"
    },
    {
      "type": "p",
      "content": "Load a PDF with Azure Document Intelligence."
    },
    {
      "type": "p",
      "content": "document_loaders.docusaurus.DocusaurusLoader(url)"
    },
    {
      "type": "p",
      "content": "Load from Docusaurus Documentation."
    },
    {
      "type": "p",
      "content": "document_loaders.dropbox.DropboxLoader"
    },
    {
      "type": "p",
      "content": "Load files fromDropbox."
    },
    {
      "type": "p",
      "content": "document_loaders.duckdb_loader.DuckDBLoader(query)"
    },
    {
      "type": "p",
      "content": "Load fromDuckDB."
    },
    {
      "type": "p",
      "content": "document_loaders.email.OutlookMessageLoader(...)"
    },
    {
      "type": "p",
      "content": "Loads Outlook Message files using extract_msg."
    },
    {
      "type": "p",
      "content": "document_loaders.email.UnstructuredEmailLoader(...)"
    },
    {
      "type": "p",
      "content": "Load email files usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.epub.UnstructuredEPubLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadEPubfiles usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.etherscan.EtherscanLoader(...)"
    },
    {
      "type": "p",
      "content": "Load transactions fromEthereummainnet."
    },
    {
      "type": "p",
      "content": "document_loaders.evernote.EverNoteLoader(...)"
    },
    {
      "type": "p",
      "content": "Document loader for EverNote ENEX export files."
    },
    {
      "type": "p",
      "content": "document_loaders.excel.UnstructuredExcelLoader(...)"
    },
    {
      "type": "p",
      "content": "Load Microsoft Excel files usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.facebook_chat.FacebookChatLoader(path)"
    },
    {
      "type": "p",
      "content": "LoadFacebook Chatmessages directory dump."
    },
    {
      "type": "p",
      "content": "document_loaders.fauna.FaunaLoader(query, ...)"
    },
    {
      "type": "p",
      "content": "Load fromFaunaDB."
    },
    {
      "type": "p",
      "content": "document_loaders.figma.FigmaFileLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadFigmafile."
    },
    {
      "type": "p",
      "content": "document_loaders.firecrawl.FireCrawlLoader(url, *)"
    },
    {
      "type": "p",
      "content": "FireCrawlLoader document loader integration"
    },
    {
      "type": "p",
      "content": "document_loaders.generic.GenericLoader(...)"
    },
    {
      "type": "p",
      "content": "Generic Document Loader."
    },
    {
      "type": "p",
      "content": "document_loaders.geodataframe.GeoDataFrameLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadgeopandasDataframe."
    },
    {
      "type": "p",
      "content": "document_loaders.git.GitLoader(repo_path[, ...])"
    },
    {
      "type": "p",
      "content": "LoadGitrepository files."
    },
    {
      "type": "p",
      "content": "document_loaders.gitbook.GitbookLoader(web_page)"
    },
    {
      "type": "p",
      "content": "LoadGitBookdata."
    },
    {
      "type": "p",
      "content": "document_loaders.github.BaseGitHubLoader"
    },
    {
      "type": "p",
      "content": "LoadGitHubrepository Issues."
    },
    {
      "type": "p",
      "content": "document_loaders.github.GitHubIssuesLoader"
    },
    {
      "type": "p",
      "content": "Load issues of a GitHub repository."
    },
    {
      "type": "p",
      "content": "document_loaders.github.GithubFileLoader"
    },
    {
      "type": "p",
      "content": "Load GitHub File"
    },
    {
      "type": "p",
      "content": "document_loaders.glue_catalog.GlueCatalogLoader(...)"
    },
    {
      "type": "p",
      "content": "Load table schemas from AWS Glue."
    },
    {
      "type": "p",
      "content": "document_loaders.gutenberg.GutenbergLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromGutenberg.org."
    },
    {
      "type": "p",
      "content": "document_loaders.helpers.FileEncoding(...)"
    },
    {
      "type": "p",
      "content": "File encoding as the NamedTuple."
    },
    {
      "type": "p",
      "content": "document_loaders.hn.HNLoader([web_path, ...])"
    },
    {
      "type": "p",
      "content": "LoadHacker Newsdata."
    },
    {
      "type": "p",
      "content": "document_loaders.html.UnstructuredHTMLLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadHTMLfiles usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.html_bs.BSHTMLLoader(file_path)"
    },
    {
      "type": "p",
      "content": "__ModuleName__ document loader integration"
    },
    {
      "type": "p",
      "content": "document_loaders.hugging_face_dataset.HuggingFaceDatasetLoader(path)"
    },
    {
      "type": "p",
      "content": "Load fromHugging Face Hubdatasets."
    },
    {
      "type": "p",
      "content": "document_loaders.hugging_face_model.HuggingFaceModelLoader(*)"
    },
    {
      "type": "p",
      "content": "Load model information fromHugging Face Hub, including README content."
    },
    {
      "type": "p",
      "content": "document_loaders.ifixit.IFixitLoader(web_path)"
    },
    {
      "type": "p",
      "content": "LoadiFixitrepair guides, device wikis and answers."
    },
    {
      "type": "p",
      "content": "document_loaders.image.UnstructuredImageLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadPNGandJPGfiles usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.image_captions.ImageCaptionLoader(images)"
    },
    {
      "type": "p",
      "content": "Load image captions."
    },
    {
      "type": "p",
      "content": "document_loaders.imsdb.IMSDbLoader([...])"
    },
    {
      "type": "p",
      "content": "LoadIMSDbwebpages."
    },
    {
      "type": "p",
      "content": "document_loaders.iugu.IuguLoader(resource[, ...])"
    },
    {
      "type": "p",
      "content": "Load fromIUGU."
    },
    {
      "type": "p",
      "content": "document_loaders.joplin.JoplinLoader([...])"
    },
    {
      "type": "p",
      "content": "Load notes fromJoplin."
    },
    {
      "type": "p",
      "content": "document_loaders.json_loader.JSONLoader(...)"
    },
    {
      "type": "p",
      "content": "Load aJSONfile using ajqschema."
    },
    {
      "type": "p",
      "content": "document_loaders.kinetica_loader.KineticaLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromKineticaAPI."
    },
    {
      "type": "p",
      "content": "document_loaders.lakefs.LakeFSClient(...)"
    },
    {
      "type": "p",
      "content": "Client for lakeFS."
    },
    {
      "type": "p",
      "content": "document_loaders.lakefs.LakeFSLoader(...[, ...])"
    },
    {
      "type": "p",
      "content": "Load fromlakeFS."
    },
    {
      "type": "p",
      "content": "document_loaders.lakefs.UnstructuredLakeFSLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromlakeFSas unstructured data."
    },
    {
      "type": "p",
      "content": "document_loaders.larksuite.LarkSuiteDocLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromLarkSuite(FeiShu)."
    },
    {
      "type": "p",
      "content": "document_loaders.larksuite.LarkSuiteWikiLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromLarkSuite(FeiShu) wiki."
    },
    {
      "type": "p",
      "content": "document_loaders.llmsherpa.LLMSherpaFileLoader(...)"
    },
    {
      "type": "p",
      "content": "Load Documents usingLLMSherpa."
    },
    {
      "type": "p",
      "content": "document_loaders.markdown.UnstructuredMarkdownLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadMarkdownfiles usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.mastodon.MastodonTootsLoader(...)"
    },
    {
      "type": "p",
      "content": "Load theMastodon'toots'."
    },
    {
      "type": "p",
      "content": "document_loaders.max_compute.MaxComputeLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromAlibaba Cloud MaxComputetable."
    },
    {
      "type": "p",
      "content": "document_loaders.mediawikidump.MWDumpLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadMediaWikidump from anXMLfile."
    },
    {
      "type": "p",
      "content": "document_loaders.merge.MergedDataLoader(loaders)"
    },
    {
      "type": "p",
      "content": "Merge documents from a list of loaders"
    },
    {
      "type": "p",
      "content": "document_loaders.mhtml.MHTMLLoader(file_path)"
    },
    {
      "type": "p",
      "content": "ParseMHTMLfiles withBeautifulSoup."
    },
    {
      "type": "p",
      "content": "document_loaders.mintbase.MintbaseDocumentLoader(...)"
    },
    {
      "type": "p",
      "content": "Load elements from a blockchain smart contract."
    },
    {
      "type": "p",
      "content": "document_loaders.modern_treasury.ModernTreasuryLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromModern Treasury."
    },
    {
      "type": "p",
      "content": "document_loaders.mongodb.MongodbLoader(...)"
    },
    {
      "type": "p",
      "content": "Load MongoDB documents."
    },
    {
      "type": "p",
      "content": "document_loaders.needle.NeedleLoader([...])"
    },
    {
      "type": "p",
      "content": "NeedleLoader is a document loader for managing documents stored in a collection."
    },
    {
      "type": "p",
      "content": "document_loaders.news.NewsURLLoader(urls[, ...])"
    },
    {
      "type": "p",
      "content": "Load news articles from URLs usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.notebook.NotebookLoader(path)"
    },
    {
      "type": "p",
      "content": "LoadJupyter notebook(.ipynb) files."
    },
    {
      "type": "p",
      "content": "document_loaders.notion.NotionDirectoryLoader(path, *)"
    },
    {
      "type": "p",
      "content": "LoadNotion directorydump."
    },
    {
      "type": "p",
      "content": "document_loaders.notiondb.NotionDBLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromNotion DB."
    },
    {
      "type": "p",
      "content": "document_loaders.nuclia.NucliaLoader(path, ...)"
    },
    {
      "type": "p",
      "content": "Load from any file type usingNuclia Understanding API."
    },
    {
      "type": "p",
      "content": "document_loaders.obs_directory.OBSDirectoryLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromHuawei OBS directory."
    },
    {
      "type": "p",
      "content": "document_loaders.obs_file.OBSFileLoader(...)"
    },
    {
      "type": "p",
      "content": "Load from theHuawei OBS file."
    },
    {
      "type": "p",
      "content": "document_loaders.obsidian.ObsidianLoader(path)"
    },
    {
      "type": "p",
      "content": "LoadObsidianfiles from directory."
    },
    {
      "type": "p",
      "content": "document_loaders.odt.UnstructuredODTLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadOpenOffice ODTfiles usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.onedrive.OneDriveLoader"
    },
    {
      "type": "p",
      "content": "Load documents from Microsoft OneDrive."
    },
    {
      "type": "p",
      "content": "document_loaders.onedrive_file.OneDriveFileLoader"
    },
    {
      "type": "p",
      "content": "Load a file fromMicrosoft OneDrive."
    },
    {
      "type": "p",
      "content": "document_loaders.onenote.OneNoteLoader"
    },
    {
      "type": "p",
      "content": "Load pages from OneNote notebooks."
    },
    {
      "type": "p",
      "content": "document_loaders.open_city_data.OpenCityDataLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromOpen City."
    },
    {
      "type": "p",
      "content": "document_loaders.oracleadb_loader.OracleAutonomousDatabaseLoader(...)"
    },
    {
      "type": "p",
      "content": "Load from oracle adb"
    },
    {
      "type": "p",
      "content": "document_loaders.oracleai.OracleDocLoader(...)"
    },
    {
      "type": "p",
      "content": "Read documents using OracleDocLoader :param conn: Oracle Connection, :param params: Loader parameters."
    },
    {
      "type": "p",
      "content": "document_loaders.oracleai.OracleDocReader()"
    },
    {
      "type": "p",
      "content": "Read a file"
    },
    {
      "type": "p",
      "content": "document_loaders.oracleai.OracleTextSplitter(...)"
    },
    {
      "type": "p",
      "content": "Splitting text using Oracle chunker."
    },
    {
      "type": "p",
      "content": "document_loaders.oracleai.ParseOracleDocMetadata()"
    },
    {
      "type": "p",
      "content": "Parse Oracle doc metadata..."
    },
    {
      "type": "p",
      "content": "document_loaders.org_mode.UnstructuredOrgModeLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadOrg-Modefiles usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.audio.AzureOpenAIWhisperParser(*)"
    },
    {
      "type": "p",
      "content": "Transcribe and parse audio files using Azure OpenAI Whisper."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.audio.FasterWhisperParser(*)"
    },
    {
      "type": "p",
      "content": "Transcribe and parse audio files with faster-whisper."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.audio.OpenAIWhisperParser([...])"
    },
    {
      "type": "p",
      "content": "Transcribe and parse audio files."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.audio.OpenAIWhisperParserLocal([...])"
    },
    {
      "type": "p",
      "content": "Transcribe and parse audio files with OpenAI Whisper model."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.audio.YandexSTTParser(*)"
    },
    {
      "type": "p",
      "content": "Transcribe and parse audio files."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.doc_intelligence.AzureAIDocumentIntelligenceParser(...)"
    },
    {
      "type": "p",
      "content": "Loads a PDF with Azure Document Intelligence (formerly Forms Recognizer)."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.docai.DocAIParsingResults(...)"
    },
    {
      "type": "p",
      "content": "Dataclass to store Document AI parsing results."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.documentloader_adapter.DocumentLoaderAsParser(...)"
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.generic.MimeTypeBasedParser(...)"
    },
    {
      "type": "p",
      "content": "Parser that usesmime-types to parse a blob."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.grobid.GrobidParser(...)"
    },
    {
      "type": "p",
      "content": "Load  articlePDFfiles usingGrobid."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.grobid.ServerUnavailableException"
    },
    {
      "type": "p",
      "content": "Exception raised when the Grobid server is unavailable."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.html.bs4.BS4HTMLParser(*)"
    },
    {
      "type": "p",
      "content": "Parse HTML files usingBeautiful Soup."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.images.BaseImageBlobParser()"
    },
    {
      "type": "p",
      "content": "Abstract base class for parsing image blobs into text."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.images.LLMImageBlobParser(*, ...)"
    },
    {
      "type": "p",
      "content": "Parser for analyzing images using a language model (LLM)."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.images.RapidOCRBlobParser()"
    },
    {
      "type": "p",
      "content": "Parser for extracting text from images using the RapidOCR library."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.images.TesseractBlobParser(*)"
    },
    {
      "type": "p",
      "content": "Parse for extracting text from images using the Tesseract OCR library."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.c.CSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for C."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.cobol.CobolSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter forCOBOL."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.code_segmenter.CodeSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Abstract class for the code segmenter."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.cpp.CPPSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for C++."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.csharp.CSharpSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for C#."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.elixir.ElixirSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for Elixir."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.go.GoSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for Go."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.java.JavaSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for Java."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.javascript.JavaScriptSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for JavaScript."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.kotlin.KotlinSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for Kotlin."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.language_parser.LanguageParser([...])"
    },
    {
      "type": "p",
      "content": "Parse using the respective programming language syntax."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.lua.LuaSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for Lua."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.perl.PerlSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for Perl."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.php.PHPSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for PHP."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.python.PythonSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter forPython."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.ruby.RubySegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for Ruby."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.rust.RustSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for Rust."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.scala.ScalaSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for Scala."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.sql.SQLSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for SQL."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.tree_sitter_segmenter.TreeSitterSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Abstract class for`CodeSegmenter`s that use the tree-sitter library."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.language.typescript.TypeScriptSegmenter(code)"
    },
    {
      "type": "p",
      "content": "Code segmenter for TypeScript."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.msword.MsWordParser()"
    },
    {
      "type": "p",
      "content": "Parse the Microsoft Word documents from a blob."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.pdf.AmazonTextractPDFParser([...])"
    },
    {
      "type": "p",
      "content": "SendPDFfiles toAmazon Textractand parse them."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.pdf.DocumentIntelligenceParser(...)"
    },
    {
      "type": "p",
      "content": "Loads a PDF with Azure Document Intelligence (formerly Form Recognizer) and chunks at character level."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.pdf.PDFMinerParser([...])"
    },
    {
      "type": "p",
      "content": "Parse a blob from a PDF usingpdfminer.sixlibrary."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.pdf.PDFPlumberParser([...])"
    },
    {
      "type": "p",
      "content": "ParsePDFwithPDFPlumber."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.pdf.PyMuPDFParser([...])"
    },
    {
      "type": "p",
      "content": "Parse a blob from a PDF usingPyMuPDFlibrary."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.pdf.PyPDFParser([...])"
    },
    {
      "type": "p",
      "content": "Parse a blob from a PDF usingpypdflibrary."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.pdf.PyPDFium2Parser([...])"
    },
    {
      "type": "p",
      "content": "Parse a blob from a PDF usingPyPDFium2library."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.txt.TextParser()"
    },
    {
      "type": "p",
      "content": "Parser for text blobs."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.vsdx.VsdxParser()"
    },
    {
      "type": "p",
      "content": "Parser for vsdx files."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.AmazonTextractPDFLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadPDFfiles from a local file system, HTTP or S3."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.BasePDFLoader(file_path, *)"
    },
    {
      "type": "p",
      "content": "Base Loader class forPDFfiles."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.DedocPDFLoader(file_path, *)"
    },
    {
      "type": "p",
      "content": "DedocPDFLoader document loader integration to load PDF files usingdedoc. The file loader can automatically detect the correctness of a textual layer in the     PDF document. Note that__init__method supports parameters that differ from ones of     DedocBaseLoader."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.DocumentIntelligenceLoader(...)"
    },
    {
      "type": "p",
      "content": "Load a PDF with Azure Document Intelligence"
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.MathpixPDFLoader(file_path)"
    },
    {
      "type": "p",
      "content": "LoadPDFfiles usingMathpixservice."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.OnlinePDFLoader(...[, ...])"
    },
    {
      "type": "p",
      "content": "Load onlinePDF."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.PDFMinerLoader(file_path, *)"
    },
    {
      "type": "p",
      "content": "Load and parse a PDF file using 'pdfminer.six' library."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.PDFMinerPDFasHTMLLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadPDFfiles as HTML content usingPDFMiner."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.PDFPlumberLoader(file_path)"
    },
    {
      "type": "p",
      "content": "LoadPDFfiles usingpdfplumber."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.PagedPDFSplitter"
    },
    {
      "type": "p",
      "content": "alias ofPyPDFLoader"
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.PyMuPDFLoader(file_path, *)"
    },
    {
      "type": "p",
      "content": "Load and parse a PDF file using 'PyMuPDF' library."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.PyPDFDirectoryLoader(path)"
    },
    {
      "type": "p",
      "content": "Load and parse a directory of PDF files using 'pypdf' library."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.PyPDFLoader(file_path)"
    },
    {
      "type": "p",
      "content": "Load and parse a PDF file using 'pypdf' library."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.PyPDFium2Loader(...[, ...])"
    },
    {
      "type": "p",
      "content": "Load and parse a PDF file using thepypdfium2library."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.UnstructuredPDFLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadPDFfiles usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.pdf.ZeroxPDFLoader(file_path)"
    },
    {
      "type": "p",
      "content": "Document loader utilizing Zerox library:getomni-ai/zerox"
    },
    {
      "type": "p",
      "content": "document_loaders.pebblo.PebbloSafeLoader(...)"
    },
    {
      "type": "p",
      "content": "Pebblo Safe Loader class is a wrapper around document loaders enabling the data to be scrutinized."
    },
    {
      "type": "p",
      "content": "document_loaders.pebblo.PebbloTextLoader(...)"
    },
    {
      "type": "p",
      "content": "Loader for text data."
    },
    {
      "type": "p",
      "content": "document_loaders.polars_dataframe.PolarsDataFrameLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadPolarsDataFrame."
    },
    {
      "type": "p",
      "content": "document_loaders.powerpoint.UnstructuredPowerPointLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadMicrosoft PowerPointfiles usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.psychic.PsychicLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromPsychic.dev."
    },
    {
      "type": "p",
      "content": "document_loaders.pubmed.PubMedLoader(query)"
    },
    {
      "type": "p",
      "content": "Load from thePubMedbiomedical library."
    },
    {
      "type": "p",
      "content": "document_loaders.pyspark_dataframe.PySparkDataFrameLoader([...])"
    },
    {
      "type": "p",
      "content": "LoadPySparkDataFrames."
    },
    {
      "type": "p",
      "content": "document_loaders.python.PythonLoader(file_path)"
    },
    {
      "type": "p",
      "content": "LoadPythonfiles, respecting any non-default encoding if specified."
    },
    {
      "type": "p",
      "content": "document_loaders.quip.QuipLoader(api_url, ...)"
    },
    {
      "type": "p",
      "content": "LoadQuippages."
    },
    {
      "type": "p",
      "content": "document_loaders.readthedocs.ReadTheDocsLoader(path)"
    },
    {
      "type": "p",
      "content": "LoadReadTheDocsdocumentation directory."
    },
    {
      "type": "p",
      "content": "document_loaders.recursive_url_loader.RecursiveUrlLoader(url)"
    },
    {
      "type": "p",
      "content": "Recursively load all child links from a root URL."
    },
    {
      "type": "p",
      "content": "document_loaders.reddit.RedditPostsLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadRedditposts."
    },
    {
      "type": "p",
      "content": "document_loaders.roam.RoamLoader(path)"
    },
    {
      "type": "p",
      "content": "LoadRoamfiles from a directory."
    },
    {
      "type": "p",
      "content": "document_loaders.rocksetdb.ColumnNotFoundError(...)"
    },
    {
      "type": "p",
      "content": "Column not found error."
    },
    {
      "type": "p",
      "content": "document_loaders.rocksetdb.RocksetLoader(...)"
    },
    {
      "type": "p",
      "content": "Load from aRocksetdatabase."
    },
    {
      "type": "p",
      "content": "document_loaders.rspace.RSpaceLoader(global_id)"
    },
    {
      "type": "p",
      "content": "Load content from RSpace notebooks, folders, documents or PDF Gallery files."
    },
    {
      "type": "p",
      "content": "document_loaders.rss.RSSFeedLoader([urls, ...])"
    },
    {
      "type": "p",
      "content": "Load news articles fromRSSfeeds usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.rst.UnstructuredRSTLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadRSTfiles usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.rtf.UnstructuredRTFLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadRTFfiles usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.s3_directory.S3DirectoryLoader(bucket)"
    },
    {
      "type": "p",
      "content": "Load fromAmazon AWS S3directory."
    },
    {
      "type": "p",
      "content": "document_loaders.s3_file.S3FileLoader(...[, ...])"
    },
    {
      "type": "p",
      "content": "Load fromAmazon AWS S3file."
    },
    {
      "type": "p",
      "content": "document_loaders.scrapfly.ScrapflyLoader(urls, *)"
    },
    {
      "type": "p",
      "content": "Turn a url to llm accessible markdown withScrapfly.io."
    },
    {
      "type": "p",
      "content": "document_loaders.scrapingant.ScrapingAntLoader(urls, *)"
    },
    {
      "type": "p",
      "content": "Turn an url to LLM accessible markdown withScrapingAnt."
    },
    {
      "type": "p",
      "content": "document_loaders.sharepoint.SharePointLoader"
    },
    {
      "type": "p",
      "content": "Load  fromSharePoint."
    },
    {
      "type": "p",
      "content": "document_loaders.sitemap.SitemapLoader(web_path)"
    },
    {
      "type": "p",
      "content": "Load a sitemap and its URLs."
    },
    {
      "type": "p",
      "content": "document_loaders.slack_directory.SlackDirectoryLoader(...)"
    },
    {
      "type": "p",
      "content": "Load from aSlackdirectory dump."
    },
    {
      "type": "p",
      "content": "document_loaders.snowflake_loader.SnowflakeLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromSnowflakeAPI."
    },
    {
      "type": "p",
      "content": "document_loaders.spider.SpiderLoader(url, *)"
    },
    {
      "type": "p",
      "content": "Load web pages as Documents using Spider AI."
    },
    {
      "type": "p",
      "content": "document_loaders.spreedly.SpreedlyLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromSpreedlyAPI."
    },
    {
      "type": "p",
      "content": "document_loaders.sql_database.SQLDatabaseLoader(...)"
    },
    {
      "type": "p",
      "content": "Load documents by querying database tables supported by SQLAlchemy."
    },
    {
      "type": "p",
      "content": "document_loaders.srt.SRTLoader(file_path)"
    },
    {
      "type": "p",
      "content": "Load.srt(subtitle) files."
    },
    {
      "type": "p",
      "content": "document_loaders.stripe.StripeLoader(resource)"
    },
    {
      "type": "p",
      "content": "Load fromStripeAPI."
    },
    {
      "type": "p",
      "content": "document_loaders.surrealdb.SurrealDBLoader([...])"
    },
    {
      "type": "p",
      "content": "Load SurrealDB documents."
    },
    {
      "type": "p",
      "content": "document_loaders.telegram.TelegramChatApiLoader([...])"
    },
    {
      "type": "p",
      "content": "LoadTelegramchat json directory dump."
    },
    {
      "type": "p",
      "content": "document_loaders.telegram.TelegramChatFileLoader(path)"
    },
    {
      "type": "p",
      "content": "Load fromTelegram chatdump."
    },
    {
      "type": "p",
      "content": "document_loaders.telegram.TelegramChatLoader"
    },
    {
      "type": "p",
      "content": "alias ofTelegramChatFileLoader"
    },
    {
      "type": "p",
      "content": "document_loaders.tencent_cos_directory.TencentCOSDirectoryLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromTencent Cloud COSdirectory."
    },
    {
      "type": "p",
      "content": "document_loaders.tencent_cos_file.TencentCOSFileLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromTencent Cloud COSfile."
    },
    {
      "type": "p",
      "content": "document_loaders.tensorflow_datasets.TensorflowDatasetLoader(...)"
    },
    {
      "type": "p",
      "content": "Load fromTensorFlow Dataset."
    },
    {
      "type": "p",
      "content": "document_loaders.text.TextLoader(file_path)"
    },
    {
      "type": "p",
      "content": "Load text file."
    },
    {
      "type": "p",
      "content": "document_loaders.tidb.TiDBLoader(...[, ...])"
    },
    {
      "type": "p",
      "content": "Load documents from TiDB."
    },
    {
      "type": "p",
      "content": "document_loaders.tomarkdown.ToMarkdownLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadHTMLusing2markdown API."
    },
    {
      "type": "p",
      "content": "document_loaders.toml.TomlLoader(source)"
    },
    {
      "type": "p",
      "content": "LoadTOMLfiles."
    },
    {
      "type": "p",
      "content": "document_loaders.trello.TrelloLoader(client, ...)"
    },
    {
      "type": "p",
      "content": "Load cards from aTrelloboard."
    },
    {
      "type": "p",
      "content": "document_loaders.tsv.UnstructuredTSVLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadTSVfiles usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.twitter.TwitterTweetLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadTwittertweets."
    },
    {
      "type": "p",
      "content": "document_loaders.unstructured.UnstructuredBaseLoader([...])"
    },
    {
      "type": "p",
      "content": "Base Loader that usesUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.url.UnstructuredURLLoader(urls)"
    },
    {
      "type": "p",
      "content": "Load files from remote URLs usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.url_playwright.PlaywrightEvaluator()"
    },
    {
      "type": "p",
      "content": "Abstract base class for all evaluators."
    },
    {
      "type": "p",
      "content": "document_loaders.url_playwright.PlaywrightURLLoader(urls)"
    },
    {
      "type": "p",
      "content": "LoadHTMLpages withPlaywrightand parse withUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.url_playwright.UnstructuredHtmlEvaluator([...])"
    },
    {
      "type": "p",
      "content": "Evaluate the page HTML content using theunstructuredlibrary."
    },
    {
      "type": "p",
      "content": "document_loaders.url_selenium.SeleniumURLLoader(urls)"
    },
    {
      "type": "p",
      "content": "LoadHTMLpages withSeleniumand parse withUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.vsdx.VsdxLoader(file_path)"
    },
    {
      "type": "p",
      "content": "Initialize with file path."
    },
    {
      "type": "p",
      "content": "document_loaders.weather.WeatherDataLoader(...)"
    },
    {
      "type": "p",
      "content": "Load weather data withOpen Weather MapAPI."
    },
    {
      "type": "p",
      "content": "document_loaders.web_base.WebBaseLoader([...])"
    },
    {
      "type": "p",
      "content": "WebBaseLoader document loader integration"
    },
    {
      "type": "p",
      "content": "document_loaders.whatsapp_chat.WhatsAppChatLoader(path)"
    },
    {
      "type": "p",
      "content": "LoadWhatsAppmessages text file."
    },
    {
      "type": "p",
      "content": "document_loaders.wikipedia.WikipediaLoader(query)"
    },
    {
      "type": "p",
      "content": "Load fromWikipedia."
    },
    {
      "type": "p",
      "content": "document_loaders.word_document.Docx2txtLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadDOCXfile usingdocx2txtand chunks at character level."
    },
    {
      "type": "p",
      "content": "document_loaders.word_document.UnstructuredWordDocumentLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadMicrosoft Wordfile usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.xml.UnstructuredXMLLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadXMLfile usingUnstructured."
    },
    {
      "type": "p",
      "content": "document_loaders.xorbits.XorbitsLoader(...)"
    },
    {
      "type": "p",
      "content": "LoadXorbitsDataFrame."
    },
    {
      "type": "p",
      "content": "document_loaders.youtube.GoogleApiClient([...])"
    },
    {
      "type": "p",
      "content": "Generic Google API Client."
    },
    {
      "type": "p",
      "content": "document_loaders.youtube.GoogleApiYoutubeLoader(...)"
    },
    {
      "type": "p",
      "content": "Load all Videos from aYouTubeChannel."
    },
    {
      "type": "p",
      "content": "document_loaders.youtube.TranscriptFormat(value)"
    },
    {
      "type": "p",
      "content": "Output formats of transcripts fromYoutubeLoader."
    },
    {
      "type": "p",
      "content": "document_loaders.youtube.YoutubeLoader(video_id)"
    },
    {
      "type": "p",
      "content": "LoadYouTubevideo transcripts."
    },
    {
      "type": "p",
      "content": "document_loaders.yuque.YuqueLoader(access_token)"
    },
    {
      "type": "p",
      "content": "Load documents fromYuque."
    },
    {
      "type": "p",
      "content": "document_loaders.base_o365.fetch_extensions(...)"
    },
    {
      "type": "p",
      "content": "Fetch the mime types for the specified file types."
    },
    {
      "type": "p",
      "content": "document_loaders.base_o365.fetch_mime_types(...)"
    },
    {
      "type": "p",
      "content": "Fetch the mime types for the specified file types."
    },
    {
      "type": "p",
      "content": "document_loaders.chatgpt.concatenate_rows(...)"
    },
    {
      "type": "p",
      "content": "Combine message information in a readable format ready to be used."
    },
    {
      "type": "p",
      "content": "document_loaders.facebook_chat.concatenate_rows(row)"
    },
    {
      "type": "p",
      "content": "Combine message information in a readable format ready to be used."
    },
    {
      "type": "p",
      "content": "document_loaders.helpers.detect_file_encodings(...)"
    },
    {
      "type": "p",
      "content": "Try to detect the file encoding."
    },
    {
      "type": "p",
      "content": "document_loaders.notebook.concatenate_cells(...)"
    },
    {
      "type": "p",
      "content": "Combine cells information in a readable format ready to be used."
    },
    {
      "type": "p",
      "content": "document_loaders.notebook.remove_newlines(x)"
    },
    {
      "type": "p",
      "content": "Recursively remove newlines, no matter the data structure they are stored in."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.pdf.extract_from_images_with_rapidocr(images)"
    },
    {
      "type": "p",
      "content": "Extract text from images with RapidOCR."
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.registry.get_parser(...)"
    },
    {
      "type": "p",
      "content": "Get a parser by parser name."
    },
    {
      "type": "p",
      "content": "document_loaders.rocksetdb.default_joiner(docs)"
    },
    {
      "type": "p",
      "content": "Default joiner for content columns."
    },
    {
      "type": "p",
      "content": "document_loaders.telegram.concatenate_rows(row)"
    },
    {
      "type": "p",
      "content": "Combine message information in a readable format ready to be used."
    },
    {
      "type": "p",
      "content": "document_loaders.telegram.text_to_docs(text)"
    },
    {
      "type": "p",
      "content": "Convert a string or list of strings to a list of Documents with metadata."
    },
    {
      "type": "p",
      "content": "document_loaders.unstructured.get_elements_from_api([...])"
    },
    {
      "type": "p",
      "content": "Retrieve a list of elements from theUnstructured API."
    },
    {
      "type": "p",
      "content": "document_loaders.unstructured.satisfies_min_unstructured_version(...)"
    },
    {
      "type": "p",
      "content": "Check if the installedUnstructuredversion exceeds the minimum version for the feature in question."
    },
    {
      "type": "p",
      "content": "document_loaders.unstructured.validate_unstructured_version(...)"
    },
    {
      "type": "p",
      "content": "Raise an error if theUnstructuredversion does not exceed the specified minimum."
    },
    {
      "type": "p",
      "content": "document_loaders.whatsapp_chat.concatenate_rows(...)"
    },
    {
      "type": "p",
      "content": "Combine message information in a readable format ready to be used."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "document_loaders.apify_dataset.ApifyDatasetLoader"
    },
    {
      "type": "p",
      "content": "document_loaders.astradb.AstraDBLoader(...)"
    },
    {
      "type": "p",
      "content": "document_loaders.bigquery.BigQueryLoader(query)"
    },
    {
      "type": "p",
      "content": "document_loaders.docugami.DocugamiLoader"
    },
    {
      "type": "p",
      "content": "document_loaders.gcs_directory.GCSDirectoryLoader(...)"
    },
    {
      "type": "p",
      "content": "document_loaders.gcs_file.GCSFileLoader(...)"
    },
    {
      "type": "p",
      "content": "document_loaders.google_speech_to_text.GoogleSpeechToTextLoader(...)"
    },
    {
      "type": "p",
      "content": "document_loaders.googledrive.GoogleDriveLoader"
    },
    {
      "type": "p",
      "content": "document_loaders.parsers.docai.DocAIParser(*)"
    },
    {
      "type": "p",
      "content": "document_loaders.unstructured.UnstructuredAPIFileIOLoader(file, *)"
    },
    {
      "type": "p",
      "content": "document_loaders.unstructured.UnstructuredAPIFileLoader(...)"
    },
    {
      "type": "p",
      "content": "document_loaders.unstructured.UnstructuredFileIOLoader(file, *)"
    },
    {
      "type": "p",
      "content": "document_loaders.unstructured.UnstructuredFileLoader(...)"
    },
    {
      "type": "h2",
      "content": "document_transformers#"
    },
    {
      "type": "p",
      "content": "document_transformers.beautiful_soup_transformer.BeautifulSoupTransformer()"
    },
    {
      "type": "p",
      "content": "Transform HTML content by extracting specific tags and removing unwanted ones."
    },
    {
      "type": "p",
      "content": "document_transformers.doctran_text_extract.DoctranPropertyExtractor(...)"
    },
    {
      "type": "p",
      "content": "Extract properties from text documents using doctran."
    },
    {
      "type": "p",
      "content": "document_transformers.doctran_text_qa.DoctranQATransformer([...])"
    },
    {
      "type": "p",
      "content": "Extract QA from text documents using doctran."
    },
    {
      "type": "p",
      "content": "document_transformers.doctran_text_translate.DoctranTextTranslator([...])"
    },
    {
      "type": "p",
      "content": "Translate text documents using doctran."
    },
    {
      "type": "p",
      "content": "document_transformers.embeddings_redundant_filter.EmbeddingsClusteringFilter"
    },
    {
      "type": "p",
      "content": "Perform K-means clustering on document vectors."
    },
    {
      "type": "p",
      "content": "document_transformers.embeddings_redundant_filter.EmbeddingsRedundantFilter"
    },
    {
      "type": "p",
      "content": "Filter that drops redundant documents by comparing their embeddings."
    },
    {
      "type": "p",
      "content": "document_transformers.html2text.Html2TextTransformer([...])"
    },
    {
      "type": "p",
      "content": "Replace occurrences of a particular search pattern with a replacement string"
    },
    {
      "type": "p",
      "content": "document_transformers.long_context_reorder.LongContextReorder"
    },
    {
      "type": "p",
      "content": "Reorder long context."
    },
    {
      "type": "p",
      "content": "document_transformers.markdownify.MarkdownifyTransformer([...])"
    },
    {
      "type": "p",
      "content": "Converts HTML documents to Markdown format with customizable options for handling links, images, other tags and heading styles using the markdownify library."
    },
    {
      "type": "p",
      "content": "document_transformers.nuclia_text_transform.NucliaTextTransformer(nua)"
    },
    {
      "type": "p",
      "content": "Nuclia Text Transformer."
    },
    {
      "type": "p",
      "content": "document_transformers.openai_functions.OpenAIMetadataTagger"
    },
    {
      "type": "p",
      "content": "Extract metadata tags from document contents using OpenAI functions."
    },
    {
      "type": "p",
      "content": "document_transformers.beautiful_soup_transformer.get_navigable_strings(...)"
    },
    {
      "type": "p",
      "content": "Get all navigable strings from a BeautifulSoup element."
    },
    {
      "type": "p",
      "content": "document_transformers.embeddings_redundant_filter.get_stateful_documents(...)"
    },
    {
      "type": "p",
      "content": "Convert a list of documents to a list of documents with state."
    },
    {
      "type": "p",
      "content": "document_transformers.openai_functions.create_metadata_tagger(...)"
    },
    {
      "type": "p",
      "content": "Create a DocumentTransformer that uses an OpenAI function chain to automatically"
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "document_transformers.google_translate.GoogleTranslateTransformer(...)"
    },
    {
      "type": "h2",
      "content": "embeddings#"
    },
    {
      "type": "p",
      "content": "embeddings.aleph_alpha.AlephAlphaAsymmetricSemanticEmbedding"
    },
    {
      "type": "p",
      "content": "Aleph Alpha's asymmetric semantic embedding."
    },
    {
      "type": "p",
      "content": "embeddings.aleph_alpha.AlephAlphaSymmetricSemanticEmbedding"
    },
    {
      "type": "p",
      "content": "Symmetric version of the Aleph Alpha's semantic embeddings."
    },
    {
      "type": "p",
      "content": "embeddings.anyscale.AnyscaleEmbeddings"
    },
    {
      "type": "p",
      "content": "AnyscaleEmbeddings API."
    },
    {
      "type": "p",
      "content": "embeddings.ascend.AscendEmbeddings"
    },
    {
      "type": "p",
      "content": "Ascend NPU accelerate Embedding model"
    },
    {
      "type": "p",
      "content": "embeddings.awa.AwaEmbeddings"
    },
    {
      "type": "p",
      "content": "Embedding documents and queries with Awa DB."
    },
    {
      "type": "p",
      "content": "embeddings.baichuan.BaichuanTextEmbeddings"
    },
    {
      "type": "p",
      "content": "Baichuan Text Embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.baidu_qianfan_endpoint.QianfanEmbeddingsEndpoint"
    },
    {
      "type": "p",
      "content": "Baidu Qianfan Embeddings embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.bookend.BookendEmbeddings"
    },
    {
      "type": "p",
      "content": "Bookend AI sentence_transformers embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.clarifai.ClarifaiEmbeddings"
    },
    {
      "type": "p",
      "content": "Clarifai embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.dashscope.DashScopeEmbeddings"
    },
    {
      "type": "p",
      "content": "DashScope embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.deepinfra.DeepInfraEmbeddings"
    },
    {
      "type": "p",
      "content": "Deep Infra's embedding inference service."
    },
    {
      "type": "p",
      "content": "embeddings.edenai.EdenAiEmbeddings"
    },
    {
      "type": "p",
      "content": "EdenAI embedding."
    },
    {
      "type": "p",
      "content": "embeddings.embaas.EmbaasEmbeddings"
    },
    {
      "type": "p",
      "content": "Embaas's embedding service."
    },
    {
      "type": "p",
      "content": "embeddings.embaas.EmbaasEmbeddingsPayload"
    },
    {
      "type": "p",
      "content": "Payload for the Embaas embeddings API."
    },
    {
      "type": "p",
      "content": "embeddings.fake.DeterministicFakeEmbedding"
    },
    {
      "type": "p",
      "content": "Fake embedding model that always returns the same embedding vector for the same text."
    },
    {
      "type": "p",
      "content": "embeddings.fake.FakeEmbeddings"
    },
    {
      "type": "p",
      "content": "Fake embedding model."
    },
    {
      "type": "p",
      "content": "embeddings.fastembed.FastEmbedEmbeddings"
    },
    {
      "type": "p",
      "content": "Qdrant FastEmbedding models."
    },
    {
      "type": "p",
      "content": "embeddings.google_palm.GooglePalmEmbeddings"
    },
    {
      "type": "p",
      "content": "Google's PaLM Embeddings APIs."
    },
    {
      "type": "p",
      "content": "embeddings.gpt4all.GPT4AllEmbeddings"
    },
    {
      "type": "p",
      "content": "GPT4All embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.gradient_ai.GradientEmbeddings"
    },
    {
      "type": "p",
      "content": "Gradient.ai Embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.gradient_ai.TinyAsyncGradientEmbeddingClient(...)"
    },
    {
      "type": "p",
      "content": "Deprecated, TinyAsyncGradientEmbeddingClient was removed."
    },
    {
      "type": "p",
      "content": "embeddings.hunyuan.HunyuanEmbeddings"
    },
    {
      "type": "p",
      "content": "Tencent Hunyuan embedding models API by Tencent."
    },
    {
      "type": "p",
      "content": "embeddings.infinity.InfinityEmbeddings"
    },
    {
      "type": "p",
      "content": "Self-hosted embedding models forinfinitypackage."
    },
    {
      "type": "p",
      "content": "embeddings.infinity.TinyAsyncOpenAIInfinityEmbeddingClient([...])"
    },
    {
      "type": "p",
      "content": "Helper tool to embed Infinity."
    },
    {
      "type": "p",
      "content": "embeddings.infinity_local.InfinityEmbeddingsLocal"
    },
    {
      "type": "p",
      "content": "Optimized Infinity embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.ipex_llm.IpexLLMBgeEmbeddings"
    },
    {
      "type": "p",
      "content": "Wrapper around the BGE embedding model with IPEX-LLM optimizations on Intel CPUs and GPUs."
    },
    {
      "type": "p",
      "content": "embeddings.itrex.QuantizedBgeEmbeddings"
    },
    {
      "type": "p",
      "content": "Leverage Itrex runtime to unlock the performance of compressed NLP models."
    },
    {
      "type": "p",
      "content": "embeddings.javelin_ai_gateway.JavelinAIGatewayEmbeddings"
    },
    {
      "type": "p",
      "content": "Javelin AI Gateway embeddings."
    },
    {
      "type": "p",
      "content": "embeddings.jina.JinaEmbeddings"
    },
    {
      "type": "p",
      "content": "Jina embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.johnsnowlabs.JohnSnowLabsEmbeddings"
    },
    {
      "type": "p",
      "content": "JohnSnowLabs embedding models"
    },
    {
      "type": "p",
      "content": "embeddings.laser.LaserEmbeddings"
    },
    {
      "type": "p",
      "content": "LASER Language-Agnostic SEntence Representations."
    },
    {
      "type": "p",
      "content": "embeddings.llamacpp.LlamaCppEmbeddings"
    },
    {
      "type": "p",
      "content": "llama.cpp embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.llamafile.LlamafileEmbeddings"
    },
    {
      "type": "p",
      "content": "Llamafile lets you distribute and run large language models with a single file."
    },
    {
      "type": "p",
      "content": "embeddings.llm_rails.LLMRailsEmbeddings"
    },
    {
      "type": "p",
      "content": "LLMRails embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.localai.LocalAIEmbeddings"
    },
    {
      "type": "p",
      "content": "LocalAI embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.minimax.MiniMaxEmbeddings"
    },
    {
      "type": "p",
      "content": "MiniMax embedding model integration."
    },
    {
      "type": "p",
      "content": "embeddings.mlflow.MlflowCohereEmbeddings"
    },
    {
      "type": "p",
      "content": "Cohere embedding LLMs in MLflow."
    },
    {
      "type": "p",
      "content": "embeddings.mlflow.MlflowEmbeddings"
    },
    {
      "type": "p",
      "content": "Embedding LLMs in MLflow."
    },
    {
      "type": "p",
      "content": "embeddings.mlflow_gateway.MlflowAIGatewayEmbeddings"
    },
    {
      "type": "p",
      "content": "MLflow AI Gateway embeddings."
    },
    {
      "type": "p",
      "content": "embeddings.model2vec.Model2vecEmbeddings(model)"
    },
    {
      "type": "p",
      "content": "Model2Vec embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.modelscope_hub.ModelScopeEmbeddings"
    },
    {
      "type": "p",
      "content": "ModelScopeHub embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.mosaicml.MosaicMLInstructorEmbeddings"
    },
    {
      "type": "p",
      "content": "MosaicML embedding service."
    },
    {
      "type": "p",
      "content": "embeddings.naver.ClovaXEmbeddings"
    },
    {
      "type": "p",
      "content": "NCP ClovaStudioEmbedding API."
    },
    {
      "type": "p",
      "content": "embeddings.nlpcloud.NLPCloudEmbeddings"
    },
    {
      "type": "p",
      "content": "NLP Cloud embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.oci_generative_ai.OCIAuthType(value)"
    },
    {
      "type": "p",
      "content": "OCI authentication types as enumerator."
    },
    {
      "type": "p",
      "content": "embeddings.oci_generative_ai.OCIGenAIEmbeddings"
    },
    {
      "type": "p",
      "content": "OCI embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.octoai_embeddings.OctoAIEmbeddings"
    },
    {
      "type": "p",
      "content": "OctoAI Compute Service embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.openvino.OpenVINOBgeEmbeddings"
    },
    {
      "type": "p",
      "content": "OpenVNO BGE embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.openvino.OpenVINOEmbeddings"
    },
    {
      "type": "p",
      "content": "OpenVINO embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.optimum_intel.QuantizedBiEncoderEmbeddings"
    },
    {
      "type": "p",
      "content": "Quantized bi-encoders embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.oracleai.OracleEmbeddings"
    },
    {
      "type": "p",
      "content": "Get Embeddings"
    },
    {
      "type": "p",
      "content": "embeddings.ovhcloud.OVHCloudEmbeddings"
    },
    {
      "type": "p",
      "content": "OVHcloud AI Endpoints Embeddings."
    },
    {
      "type": "p",
      "content": "embeddings.premai.PremAIEmbeddings"
    },
    {
      "type": "p",
      "content": "Prem's Embedding APIs"
    },
    {
      "type": "p",
      "content": "embeddings.sagemaker_endpoint.EmbeddingsContentHandler()"
    },
    {
      "type": "p",
      "content": "Content handler for LLM class."
    },
    {
      "type": "p",
      "content": "embeddings.sagemaker_endpoint.SagemakerEndpointEmbeddings"
    },
    {
      "type": "p",
      "content": "Custom Sagemaker Inference Endpoints."
    },
    {
      "type": "p",
      "content": "embeddings.self_hosted.SelfHostedEmbeddings"
    },
    {
      "type": "p",
      "content": "Custom embedding models on self-hosted remote hardware."
    },
    {
      "type": "p",
      "content": "embeddings.self_hosted_hugging_face.SelfHostedHuggingFaceEmbeddings"
    },
    {
      "type": "p",
      "content": "HuggingFace embedding models on self-hosted remote hardware."
    },
    {
      "type": "p",
      "content": "embeddings.self_hosted_hugging_face.SelfHostedHuggingFaceInstructEmbeddings"
    },
    {
      "type": "p",
      "content": "HuggingFace InstructEmbedding models on self-hosted remote hardware."
    },
    {
      "type": "p",
      "content": "embeddings.spacy_embeddings.SpacyEmbeddings"
    },
    {
      "type": "p",
      "content": "Embeddings by spaCy models."
    },
    {
      "type": "p",
      "content": "embeddings.sparkllm.AssembleHeaderException(msg)"
    },
    {
      "type": "p",
      "content": "Exception raised for errors in the header assembly."
    },
    {
      "type": "p",
      "content": "embeddings.sparkllm.SparkLLMTextEmbeddings"
    },
    {
      "type": "p",
      "content": "SparkLLM embedding model integration."
    },
    {
      "type": "p",
      "content": "embeddings.sparkllm.Url(host, path, schema)"
    },
    {
      "type": "p",
      "content": "URL class for parsing the URL."
    },
    {
      "type": "p",
      "content": "embeddings.tensorflow_hub.TensorflowHubEmbeddings"
    },
    {
      "type": "p",
      "content": "TensorflowHub embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.text2vec.Text2vecEmbeddings"
    },
    {
      "type": "p",
      "content": "text2vec embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.textembed.AsyncOpenAITextEmbedEmbeddingClient([...])"
    },
    {
      "type": "p",
      "content": "A client to handle synchronous and asynchronous requests to the TextEmbed API."
    },
    {
      "type": "p",
      "content": "embeddings.textembed.TextEmbedEmbeddings"
    },
    {
      "type": "p",
      "content": "A class to handle embedding requests to the TextEmbed API."
    },
    {
      "type": "p",
      "content": "embeddings.titan_takeoff.Device(value)"
    },
    {
      "type": "p",
      "content": "Device to use for inference, cuda or cpu."
    },
    {
      "type": "p",
      "content": "embeddings.titan_takeoff.MissingConsumerGroup"
    },
    {
      "type": "p",
      "content": "Exception raised when no consumer group is provided on initialization of TitanTakeoffEmbed or in embed request."
    },
    {
      "type": "p",
      "content": "embeddings.titan_takeoff.ReaderConfig"
    },
    {
      "type": "p",
      "content": "Configuration for the reader to be deployed in Takeoff."
    },
    {
      "type": "p",
      "content": "embeddings.titan_takeoff.TakeoffEmbeddingException"
    },
    {
      "type": "p",
      "content": "Custom exception for interfacing with Takeoff Embedding class."
    },
    {
      "type": "p",
      "content": "embeddings.titan_takeoff.TitanTakeoffEmbed([...])"
    },
    {
      "type": "p",
      "content": "Interface with Takeoff Inference API for embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.volcengine.VolcanoEmbeddings"
    },
    {
      "type": "p",
      "content": "Volcengine Embeddingsembedding models."
    },
    {
      "type": "p",
      "content": "embeddings.xinference.XinferenceEmbeddings([...])"
    },
    {
      "type": "p",
      "content": "Xinference embedding models."
    },
    {
      "type": "p",
      "content": "embeddings.yandex.YandexGPTEmbeddings"
    },
    {
      "type": "p",
      "content": "YandexGPT Embeddings models."
    },
    {
      "type": "p",
      "content": "embeddings.zhipuai.ZhipuAIEmbeddings"
    },
    {
      "type": "p",
      "content": "ZhipuAI embedding model integration."
    },
    {
      "type": "p",
      "content": "embeddings.dashscope.embed_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the embedding call."
    },
    {
      "type": "p",
      "content": "embeddings.google_palm.embed_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "embeddings.jina.get_bytes_str(file_path)"
    },
    {
      "type": "p",
      "content": "Get the bytes string of a file."
    },
    {
      "type": "p",
      "content": "embeddings.jina.is_local(url)"
    },
    {
      "type": "p",
      "content": "Check if a URL is a local file."
    },
    {
      "type": "p",
      "content": "embeddings.localai.async_embed_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the embedding call."
    },
    {
      "type": "p",
      "content": "embeddings.localai.embed_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the embedding call."
    },
    {
      "type": "p",
      "content": "embeddings.minimax.embed_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "embeddings.nemo.is_endpoint_live(url, ...)"
    },
    {
      "type": "p",
      "content": "Check if an endpoint is live by sending a GET request to the specified URL."
    },
    {
      "type": "p",
      "content": "embeddings.openai.async_embed_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the embedding call."
    },
    {
      "type": "p",
      "content": "embeddings.openai.embed_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the embedding call."
    },
    {
      "type": "p",
      "content": "embeddings.premai.create_prem_retry_decorator(...)"
    },
    {
      "type": "p",
      "content": "Create a retry decorator for PremAIEmbeddings."
    },
    {
      "type": "p",
      "content": "embeddings.premai.embed_with_retry(embedder, ...)"
    },
    {
      "type": "p",
      "content": "Using tenacity for retry in embedding calls"
    },
    {
      "type": "p",
      "content": "embeddings.self_hosted_hugging_face.load_embedding_model(...)"
    },
    {
      "type": "p",
      "content": "Load the embedding model."
    },
    {
      "type": "p",
      "content": "embeddings.solar.embed_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "embeddings.voyageai.embed_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the embedding call."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "embeddings.azure_openai.AzureOpenAIEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.bedrock.BedrockEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.cloudflare_workersai.CloudflareWorkersAIEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.clova.ClovaEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.cohere.CohereEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.databricks.DatabricksEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.elasticsearch.ElasticsearchEmbeddings(...)"
    },
    {
      "type": "p",
      "content": "embeddings.ernie.ErnieEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.gigachat.GigaChatEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.huggingface.HuggingFaceBgeEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.huggingface.HuggingFaceEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.huggingface.HuggingFaceInferenceAPIEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.huggingface.HuggingFaceInstructEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.huggingface_hub.HuggingFaceHubEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.nemo.NeMoEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.ollama.OllamaEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.openai.OpenAIEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.sambanova.SambaStudioEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.solar.SolarEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.vertexai.VertexAIEmbeddings"
    },
    {
      "type": "p",
      "content": "embeddings.voyageai.VoyageEmbeddings"
    },
    {
      "type": "h2",
      "content": "example_selectors#"
    },
    {
      "type": "p",
      "content": "example_selectors.ngram_overlap.NGramOverlapExampleSelector"
    },
    {
      "type": "p",
      "content": "Select and order examples based on ngram overlap score (sentence_bleu score from NLTK package)."
    },
    {
      "type": "p",
      "content": "example_selectors.ngram_overlap.ngram_overlap_score(...)"
    },
    {
      "type": "p",
      "content": "Compute ngram overlap score of source and example as sentence_bleu score from NLTK package."
    },
    {
      "type": "h2",
      "content": "graph_vectorstores#"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.cassandra.AdjacentNode(...)"
    },
    {
      "type": "p",
      "content": "Create an Adjacent Node."
    },
    {
      "type": "p",
      "content": "graph_vectorstores.cassandra.CassandraGraphVectorStore(...)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.extractors.gliner_link_extractor.GLiNERLinkExtractor(...)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.extractors.hierarchy_link_extractor.HierarchyLinkExtractor(*)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.extractors.html_link_extractor.HtmlInput(...)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.extractors.html_link_extractor.HtmlLinkExtractor(*)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.extractors.keybert_link_extractor.KeybertLinkExtractor(*)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.extractors.link_extractor.LinkExtractor(...)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.extractors.link_extractor_adapter.LinkExtractorAdapter(...)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.extractors.link_extractor_transformer.LinkExtractorTransformer(...)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.links.Link(kind, ...)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.mmr_helper.MmrHelper(k, ...)"
    },
    {
      "type": "p",
      "content": "Helper for executing an MMR traversal query."
    },
    {
      "type": "p",
      "content": "graph_vectorstores.links.add_links(doc, *links)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.links.copy_with_links(...)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.links.get_links(doc)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.networkx.documents_to_networkx(...)"
    },
    {
      "type": "p",
      "content": "Return the networkx directed graph corresponding to the documents."
    },
    {
      "type": "p",
      "content": "graph_vectorstores.visualize.render_graphviz(...)"
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.base.GraphVectorStore(...)"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.base.GraphVectorStoreRetriever"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.base.Node"
    },
    {
      "type": "p",
      "content": "Deprecated functions"
    },
    {
      "type": "p",
      "content": "graph_vectorstores.base.nodes_to_documents(nodes)"
    },
    {
      "type": "p",
      "content": "graphs.age_graph.AGEGraph(graph_name, conf)"
    },
    {
      "type": "p",
      "content": "Apache AGE wrapper for graph operations."
    },
    {
      "type": "p",
      "content": "graphs.age_graph.AGEQueryException(exception)"
    },
    {
      "type": "p",
      "content": "Exception for the AGE queries."
    },
    {
      "type": "p",
      "content": "graphs.arangodb_graph.ArangoGraph(db)"
    },
    {
      "type": "p",
      "content": "ArangoDB wrapper for graph operations."
    },
    {
      "type": "p",
      "content": "graphs.falkordb_graph.FalkorDBGraph(database)"
    },
    {
      "type": "p",
      "content": "FalkorDB wrapper for graph operations."
    },
    {
      "type": "p",
      "content": "graphs.graph_document.GraphDocument"
    },
    {
      "type": "p",
      "content": "Represents a graph document consisting of nodes and relationships."
    },
    {
      "type": "p",
      "content": "graphs.graph_document.Node"
    },
    {
      "type": "p",
      "content": "Represents a node in a graph with associated properties."
    },
    {
      "type": "p",
      "content": "graphs.graph_document.Relationship"
    },
    {
      "type": "p",
      "content": "Represents a directed relationship between two nodes in a graph."
    },
    {
      "type": "p",
      "content": "graphs.graph_store.GraphStore()"
    },
    {
      "type": "p",
      "content": "Abstract class for graph operations."
    },
    {
      "type": "p",
      "content": "graphs.gremlin_graph.GremlinGraph([url, ...])"
    },
    {
      "type": "p",
      "content": "Gremlin wrapper for graph operations."
    },
    {
      "type": "p",
      "content": "graphs.hugegraph.HugeGraph([username, ...])"
    },
    {
      "type": "p",
      "content": "HugeGraph wrapper for graph operations."
    },
    {
      "type": "p",
      "content": "graphs.index_creator.GraphIndexCreator"
    },
    {
      "type": "p",
      "content": "Functionality to create graph index."
    },
    {
      "type": "p",
      "content": "graphs.kuzu_graph.KuzuGraph(db[, database, ...])"
    },
    {
      "type": "p",
      "content": "Kùzu wrapper for graph operations."
    },
    {
      "type": "p",
      "content": "graphs.memgraph_graph.MemgraphGraph([url, ...])"
    },
    {
      "type": "p",
      "content": "Memgraph wrapper for graph operations."
    },
    {
      "type": "p",
      "content": "graphs.nebula_graph.NebulaGraph(space[, ...])"
    },
    {
      "type": "p",
      "content": "NebulaGraph wrapper for graph operations."
    },
    {
      "type": "p",
      "content": "graphs.neptune_graph.BaseNeptuneGraph()"
    },
    {
      "type": "p",
      "content": "Abstract base class for Neptune."
    },
    {
      "type": "p",
      "content": "graphs.neptune_graph.NeptuneQueryException(...)"
    },
    {
      "type": "p",
      "content": "Exception for the Neptune queries."
    },
    {
      "type": "p",
      "content": "graphs.networkx_graph.KnowledgeTriple(...)"
    },
    {
      "type": "p",
      "content": "Knowledge triple in the graph."
    },
    {
      "type": "p",
      "content": "graphs.networkx_graph.NetworkxEntityGraph([graph])"
    },
    {
      "type": "p",
      "content": "Networkx wrapper for entity graph operations."
    },
    {
      "type": "p",
      "content": "graphs.ontotext_graphdb_graph.OntotextGraphDBGraph(...)"
    },
    {
      "type": "p",
      "content": "Ontotext GraphDBhttps://graphdb.ontotext.com/wrapper for graph operations."
    },
    {
      "type": "p",
      "content": "graphs.rdf_graph.RdfGraph([source_file, ...])"
    },
    {
      "type": "p",
      "content": "RDFlib wrapper for graph operations."
    },
    {
      "type": "p",
      "content": "graphs.tigergraph_graph.TigerGraph(conn)"
    },
    {
      "type": "p",
      "content": "TigerGraph wrapper for graph operations."
    },
    {
      "type": "p",
      "content": "graphs.arangodb_graph.get_arangodb_client([...])"
    },
    {
      "type": "p",
      "content": "Get the Arango DB client from credentials."
    },
    {
      "type": "p",
      "content": "graphs.memgraph_graph.get_reformated_schema(...)"
    },
    {
      "type": "p",
      "content": "graphs.memgraph_graph.get_schema_subset(data)"
    },
    {
      "type": "p",
      "content": "graphs.memgraph_graph.transform_schema_to_text(schema)"
    },
    {
      "type": "p",
      "content": "graphs.networkx_graph.get_entities(entity_str)"
    },
    {
      "type": "p",
      "content": "Extract entities from entity string."
    },
    {
      "type": "p",
      "content": "graphs.networkx_graph.parse_triples(...)"
    },
    {
      "type": "p",
      "content": "Parse knowledge triples from the knowledge string."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "graphs.neo4j_graph.Neo4jGraph([url, ...])"
    },
    {
      "type": "p",
      "content": "graphs.neptune_graph.NeptuneAnalyticsGraph(...)"
    },
    {
      "type": "p",
      "content": "graphs.neptune_graph.NeptuneGraph(host[, ...])"
    },
    {
      "type": "p",
      "content": "graphs.neptune_rdf_graph.NeptuneRdfGraph(host)"
    },
    {
      "type": "p",
      "content": "Deprecated functions"
    },
    {
      "type": "p",
      "content": "graphs.neo4j_graph.clean_string_values(text)"
    },
    {
      "type": "p",
      "content": "graphs.neo4j_graph.value_sanitize(d)"
    },
    {
      "type": "p",
      "content": "indexes.base.RecordManager(namespace)"
    },
    {
      "type": "p",
      "content": "Abstract base class for a record manager."
    },
    {
      "type": "p",
      "content": "llms.ai21.AI21"
    },
    {
      "type": "p",
      "content": "AI21 large language models."
    },
    {
      "type": "p",
      "content": "llms.ai21.AI21PenaltyData"
    },
    {
      "type": "p",
      "content": "Parameters for AI21 penalty data."
    },
    {
      "type": "p",
      "content": "llms.aleph_alpha.AlephAlpha"
    },
    {
      "type": "p",
      "content": "Aleph Alpha large language models."
    },
    {
      "type": "p",
      "content": "llms.amazon_api_gateway.AmazonAPIGateway"
    },
    {
      "type": "p",
      "content": "Amazon API Gateway to access LLM models hosted on AWS."
    },
    {
      "type": "p",
      "content": "llms.amazon_api_gateway.ContentHandlerAmazonAPIGateway()"
    },
    {
      "type": "p",
      "content": "Adapter to prepare the inputs from Langchain to a format that LLM model expects."
    },
    {
      "type": "p",
      "content": "llms.anyscale.Anyscale"
    },
    {
      "type": "p",
      "content": "Anyscale large language models."
    },
    {
      "type": "p",
      "content": "llms.aphrodite.Aphrodite"
    },
    {
      "type": "p",
      "content": "Aphrodite language model."
    },
    {
      "type": "p",
      "content": "llms.arcee.Arcee"
    },
    {
      "type": "p",
      "content": "Arcee's Domain Adapted Language Models (DALMs)."
    },
    {
      "type": "p",
      "content": "llms.aviary.Aviary"
    },
    {
      "type": "p",
      "content": "Aviary hosted models."
    },
    {
      "type": "p",
      "content": "llms.aviary.AviaryBackend(backend_url, bearer)"
    },
    {
      "type": "p",
      "content": "Aviary backend."
    },
    {
      "type": "p",
      "content": "llms.azureml_endpoint.AzureMLBaseEndpoint"
    },
    {
      "type": "p",
      "content": "Azure ML Online Endpoint models."
    },
    {
      "type": "p",
      "content": "llms.azureml_endpoint.AzureMLEndpointApiType(value)"
    },
    {
      "type": "p",
      "content": "Azure ML endpoints API types."
    },
    {
      "type": "p",
      "content": "llms.azureml_endpoint.AzureMLEndpointClient(...)"
    },
    {
      "type": "p",
      "content": "AzureML Managed Endpoint client."
    },
    {
      "type": "p",
      "content": "llms.azureml_endpoint.AzureMLOnlineEndpoint"
    },
    {
      "type": "p",
      "content": "Azure ML Online Endpoint models."
    },
    {
      "type": "p",
      "content": "llms.azureml_endpoint.ContentFormatterBase()"
    },
    {
      "type": "p",
      "content": "Transform request and response of AzureML endpoint to match with required schema."
    },
    {
      "type": "p",
      "content": "llms.azureml_endpoint.CustomOpenAIContentFormatter()"
    },
    {
      "type": "p",
      "content": "Content formatter for models that use the OpenAI like API scheme."
    },
    {
      "type": "p",
      "content": "llms.azureml_endpoint.DollyContentFormatter()"
    },
    {
      "type": "p",
      "content": "Content handler for the Dolly-v2-12b model"
    },
    {
      "type": "p",
      "content": "llms.azureml_endpoint.GPT2ContentFormatter()"
    },
    {
      "type": "p",
      "content": "Content handler for GPT2"
    },
    {
      "type": "p",
      "content": "llms.azureml_endpoint.HFContentFormatter()"
    },
    {
      "type": "p",
      "content": "Content handler for LLMs from the HuggingFace catalog."
    },
    {
      "type": "p",
      "content": "llms.azureml_endpoint.LlamaContentFormatter()"
    },
    {
      "type": "p",
      "content": "Deprecated: Kept for backwards compatibility"
    },
    {
      "type": "p",
      "content": "llms.azureml_endpoint.OSSContentFormatter()"
    },
    {
      "type": "p",
      "content": "Deprecated: Kept for backwards compatibility"
    },
    {
      "type": "p",
      "content": "llms.baichuan.BaichuanLLM"
    },
    {
      "type": "p",
      "content": "Baichuan large language models."
    },
    {
      "type": "p",
      "content": "llms.baidu_qianfan_endpoint.QianfanLLMEndpoint"
    },
    {
      "type": "p",
      "content": "Baidu Qianfan completion model integration."
    },
    {
      "type": "p",
      "content": "llms.bananadev.Banana"
    },
    {
      "type": "p",
      "content": "Banana large language models."
    },
    {
      "type": "p",
      "content": "llms.baseten.Baseten"
    },
    {
      "type": "p",
      "content": "Baseten model"
    },
    {
      "type": "p",
      "content": "llms.beam.Beam"
    },
    {
      "type": "p",
      "content": "Beam API for gpt2 large language model."
    },
    {
      "type": "p",
      "content": "llms.bedrock.BedrockBase"
    },
    {
      "type": "p",
      "content": "Base class for Bedrock models."
    },
    {
      "type": "p",
      "content": "llms.bedrock.LLMInputOutputAdapter()"
    },
    {
      "type": "p",
      "content": "Adapter class to prepare the inputs from Langchain to a format that LLM model expects."
    },
    {
      "type": "p",
      "content": "llms.bigdl_llm.BigdlLLM"
    },
    {
      "type": "p",
      "content": "Wrapper around the BigdlLLM model"
    },
    {
      "type": "p",
      "content": "llms.bittensor.NIBittensorLLM"
    },
    {
      "type": "p",
      "content": "NIBittensor LLMs"
    },
    {
      "type": "p",
      "content": "llms.cerebriumai.CerebriumAI"
    },
    {
      "type": "p",
      "content": "CerebriumAI large language models."
    },
    {
      "type": "p",
      "content": "llms.chatglm.ChatGLM"
    },
    {
      "type": "p",
      "content": "ChatGLM LLM service."
    },
    {
      "type": "p",
      "content": "llms.chatglm3.ChatGLM3"
    },
    {
      "type": "p",
      "content": "ChatGLM3 LLM service."
    },
    {
      "type": "p",
      "content": "llms.clarifai.Clarifai"
    },
    {
      "type": "p",
      "content": "Clarifai large language models."
    },
    {
      "type": "p",
      "content": "llms.cloudflare_workersai.CloudflareWorkersAI"
    },
    {
      "type": "p",
      "content": "Cloudflare Workers AI service."
    },
    {
      "type": "p",
      "content": "llms.ctransformers.CTransformers"
    },
    {
      "type": "p",
      "content": "C Transformers LLM models."
    },
    {
      "type": "p",
      "content": "llms.ctranslate2.CTranslate2"
    },
    {
      "type": "p",
      "content": "CTranslate2 language model."
    },
    {
      "type": "p",
      "content": "llms.deepinfra.DeepInfra"
    },
    {
      "type": "p",
      "content": "DeepInfra models."
    },
    {
      "type": "p",
      "content": "llms.deepsparse.DeepSparse"
    },
    {
      "type": "p",
      "content": "Neural Magic DeepSparse LLM interface."
    },
    {
      "type": "p",
      "content": "llms.edenai.EdenAI"
    },
    {
      "type": "p",
      "content": "EdenAI models."
    },
    {
      "type": "p",
      "content": "llms.exllamav2.ExLlamaV2"
    },
    {
      "type": "p",
      "content": "ExllamaV2 API."
    },
    {
      "type": "p",
      "content": "llms.fake.FakeListLLM"
    },
    {
      "type": "p",
      "content": "Fake LLM for testing purposes."
    },
    {
      "type": "p",
      "content": "llms.fake.FakeStreamingListLLM"
    },
    {
      "type": "p",
      "content": "Fake streaming list LLM for testing purposes."
    },
    {
      "type": "p",
      "content": "llms.forefrontai.ForefrontAI"
    },
    {
      "type": "p",
      "content": "ForefrontAI large language models."
    },
    {
      "type": "p",
      "content": "llms.friendli.BaseFriendli"
    },
    {
      "type": "p",
      "content": "Base class of Friendli."
    },
    {
      "type": "p",
      "content": "llms.friendli.Friendli"
    },
    {
      "type": "p",
      "content": "Friendli LLM."
    },
    {
      "type": "p",
      "content": "llms.gigachat.GigaChat"
    },
    {
      "type": "p",
      "content": "GigaChatlarge language models API."
    },
    {
      "type": "p",
      "content": "llms.gooseai.GooseAI"
    },
    {
      "type": "p",
      "content": "GooseAI large language models."
    },
    {
      "type": "p",
      "content": "llms.gpt4all.GPT4All"
    },
    {
      "type": "p",
      "content": "GPT4All language models."
    },
    {
      "type": "p",
      "content": "llms.gradient_ai.GradientLLM"
    },
    {
      "type": "p",
      "content": "Gradient.ai LLM Endpoints."
    },
    {
      "type": "p",
      "content": "llms.gradient_ai.TrainResult"
    },
    {
      "type": "p",
      "content": "Train result."
    },
    {
      "type": "p",
      "content": "llms.human.HumanInputLLM"
    },
    {
      "type": "p",
      "content": "User input as the response."
    },
    {
      "type": "p",
      "content": "llms.ipex_llm.IpexLLM"
    },
    {
      "type": "p",
      "content": "IpexLLM model."
    },
    {
      "type": "p",
      "content": "llms.javelin_ai_gateway.JavelinAIGateway"
    },
    {
      "type": "p",
      "content": "Javelin AI Gateway LLMs."
    },
    {
      "type": "p",
      "content": "llms.javelin_ai_gateway.Params"
    },
    {
      "type": "p",
      "content": "Parameters for the Javelin AI Gateway LLM."
    },
    {
      "type": "p",
      "content": "llms.koboldai.KoboldApiLLM"
    },
    {
      "type": "p",
      "content": "Kobold API language model."
    },
    {
      "type": "p",
      "content": "llms.konko.Konko"
    },
    {
      "type": "p",
      "content": "Konko AI models."
    },
    {
      "type": "p",
      "content": "llms.layerup_security.LayerupSecurity"
    },
    {
      "type": "p",
      "content": "Layerup Security LLM service."
    },
    {
      "type": "p",
      "content": "llms.llamacpp.LlamaCpp"
    },
    {
      "type": "p",
      "content": "llama.cpp model."
    },
    {
      "type": "p",
      "content": "llms.llamafile.Llamafile"
    },
    {
      "type": "p",
      "content": "Llamafile lets you distribute and run large language models with a single file."
    },
    {
      "type": "p",
      "content": "llms.manifest.ManifestWrapper"
    },
    {
      "type": "p",
      "content": "HazyResearch's Manifest library."
    },
    {
      "type": "p",
      "content": "llms.minimax.Minimax"
    },
    {
      "type": "p",
      "content": "Minimax large language models."
    },
    {
      "type": "p",
      "content": "llms.minimax.MinimaxCommon"
    },
    {
      "type": "p",
      "content": "Common parameters for Minimax large language models."
    },
    {
      "type": "p",
      "content": "llms.mlflow.Mlflow"
    },
    {
      "type": "p",
      "content": "MLflow LLM service."
    },
    {
      "type": "p",
      "content": "llms.mlflow_ai_gateway.MlflowAIGateway"
    },
    {
      "type": "p",
      "content": "MLflow AI Gateway LLMs."
    },
    {
      "type": "p",
      "content": "llms.mlflow_ai_gateway.Params"
    },
    {
      "type": "p",
      "content": "Parameters for the MLflow AI Gateway LLM."
    },
    {
      "type": "p",
      "content": "llms.mlx_pipeline.MLXPipeline"
    },
    {
      "type": "p",
      "content": "MLX Pipeline API."
    },
    {
      "type": "p",
      "content": "llms.modal.Modal"
    },
    {
      "type": "p",
      "content": "Modal large language models."
    },
    {
      "type": "p",
      "content": "llms.moonshot.Moonshot"
    },
    {
      "type": "p",
      "content": "Moonshot large language models."
    },
    {
      "type": "p",
      "content": "llms.moonshot.MoonshotCommon"
    },
    {
      "type": "p",
      "content": "Common parameters for Moonshot LLMs."
    },
    {
      "type": "p",
      "content": "llms.mosaicml.MosaicML"
    },
    {
      "type": "p",
      "content": "MosaicML LLM service."
    },
    {
      "type": "p",
      "content": "llms.nlpcloud.NLPCloud"
    },
    {
      "type": "p",
      "content": "NLPCloud large language models."
    },
    {
      "type": "p",
      "content": "llms.oci_data_science_model_deployment_endpoint.BaseOCIModelDeployment"
    },
    {
      "type": "p",
      "content": "Base class for LLM deployed on OCI Data Science Model Deployment."
    },
    {
      "type": "p",
      "content": "llms.oci_data_science_model_deployment_endpoint.OCIModelDeploymentLLM"
    },
    {
      "type": "p",
      "content": "LLM deployed on OCI Data Science Model Deployment."
    },
    {
      "type": "p",
      "content": "llms.oci_data_science_model_deployment_endpoint.OCIModelDeploymentTGI"
    },
    {
      "type": "p",
      "content": "OCI Data Science Model Deployment TGI Endpoint."
    },
    {
      "type": "p",
      "content": "llms.oci_data_science_model_deployment_endpoint.OCIModelDeploymentVLLM"
    },
    {
      "type": "p",
      "content": "VLLM deployed on OCI Data Science Model Deployment"
    },
    {
      "type": "p",
      "content": "llms.oci_data_science_model_deployment_endpoint.ServerError"
    },
    {
      "type": "p",
      "content": "Raises when encounter server error when making inference."
    },
    {
      "type": "p",
      "content": "llms.oci_data_science_model_deployment_endpoint.TokenExpiredError"
    },
    {
      "type": "p",
      "content": "Raises when token expired."
    },
    {
      "type": "p",
      "content": "llms.oci_generative_ai.CohereProvider()"
    },
    {
      "type": "p",
      "content": "llms.oci_generative_ai.MetaProvider()"
    },
    {
      "type": "p",
      "content": "llms.oci_generative_ai.OCIAuthType(value)"
    },
    {
      "type": "p",
      "content": "OCI authentication types as enumerator."
    },
    {
      "type": "p",
      "content": "llms.oci_generative_ai.OCIGenAI"
    },
    {
      "type": "p",
      "content": "OCI large language models."
    },
    {
      "type": "p",
      "content": "llms.oci_generative_ai.OCIGenAIBase"
    },
    {
      "type": "p",
      "content": "Base class for OCI GenAI models"
    },
    {
      "type": "p",
      "content": "llms.oci_generative_ai.Provider()"
    },
    {
      "type": "p",
      "content": "llms.octoai_endpoint.OctoAIEndpoint"
    },
    {
      "type": "p",
      "content": "OctoAI LLM Endpoints - OpenAI compatible."
    },
    {
      "type": "p",
      "content": "llms.ollama.OllamaEndpointNotFoundError"
    },
    {
      "type": "p",
      "content": "Raised when the Ollama endpoint is not found."
    },
    {
      "type": "p",
      "content": "llms.opaqueprompts.OpaquePrompts"
    },
    {
      "type": "p",
      "content": "LLM that uses OpaquePrompts to sanitize prompts."
    },
    {
      "type": "p",
      "content": "llms.openai.BaseOpenAI"
    },
    {
      "type": "p",
      "content": "Base OpenAI large language model class."
    },
    {
      "type": "p",
      "content": "llms.openllm.OpenLLM"
    },
    {
      "type": "p",
      "content": "OpenAI's compatible API client for OpenLLM server"
    },
    {
      "type": "p",
      "content": "llms.openlm.OpenLM"
    },
    {
      "type": "p",
      "content": "OpenLM models."
    },
    {
      "type": "p",
      "content": "llms.outlines.Outlines"
    },
    {
      "type": "p",
      "content": "LLM wrapper for the Outlines library."
    },
    {
      "type": "p",
      "content": "llms.pai_eas_endpoint.PaiEasEndpoint"
    },
    {
      "type": "p",
      "content": "Langchain LLM class to help to access eass llm service."
    },
    {
      "type": "p",
      "content": "llms.petals.Petals"
    },
    {
      "type": "p",
      "content": "Petals Bloom models."
    },
    {
      "type": "p",
      "content": "llms.pipelineai.PipelineAI"
    },
    {
      "type": "p",
      "content": "PipelineAI large language models."
    },
    {
      "type": "p",
      "content": "llms.predibase.Predibase"
    },
    {
      "type": "p",
      "content": "Use your Predibase models with Langchain."
    },
    {
      "type": "p",
      "content": "llms.promptlayer_openai.PromptLayerOpenAI"
    },
    {
      "type": "p",
      "content": "PromptLayer OpenAI large language models."
    },
    {
      "type": "p",
      "content": "llms.promptlayer_openai.PromptLayerOpenAIChat"
    },
    {
      "type": "p",
      "content": "PromptLayer OpenAI large language models."
    },
    {
      "type": "p",
      "content": "llms.replicate.Replicate"
    },
    {
      "type": "p",
      "content": "Replicate models."
    },
    {
      "type": "p",
      "content": "llms.rwkv.RWKV"
    },
    {
      "type": "p",
      "content": "RWKV language models."
    },
    {
      "type": "p",
      "content": "llms.sagemaker_endpoint.ContentHandlerBase()"
    },
    {
      "type": "p",
      "content": "Handler class to transform input from LLM to a format that SageMaker endpoint expects."
    },
    {
      "type": "p",
      "content": "llms.sagemaker_endpoint.LLMContentHandler()"
    },
    {
      "type": "p",
      "content": "Content handler for LLM class."
    },
    {
      "type": "p",
      "content": "llms.sagemaker_endpoint.LineIterator(stream)"
    },
    {
      "type": "p",
      "content": "Parse the byte stream input."
    },
    {
      "type": "p",
      "content": "llms.sambanova.SambaNovaCloud"
    },
    {
      "type": "p",
      "content": "SambaNova Cloud large language models."
    },
    {
      "type": "p",
      "content": "llms.sambanova.SambaStudio"
    },
    {
      "type": "p",
      "content": "SambaStudio large language models."
    },
    {
      "type": "p",
      "content": "llms.self_hosted.SelfHostedPipeline"
    },
    {
      "type": "p",
      "content": "Model inference on self-hosted remote hardware."
    },
    {
      "type": "p",
      "content": "llms.self_hosted_hugging_face.SelfHostedHuggingFaceLLM"
    },
    {
      "type": "p",
      "content": "HuggingFace Pipeline API to run on self-hosted remote hardware."
    },
    {
      "type": "p",
      "content": "llms.solar.Solar"
    },
    {
      "type": "p",
      "content": "Solar large language models."
    },
    {
      "type": "p",
      "content": "llms.solar.SolarCommon"
    },
    {
      "type": "p",
      "content": "Common configuration for Solar LLMs."
    },
    {
      "type": "p",
      "content": "llms.sparkllm.SparkLLM"
    },
    {
      "type": "p",
      "content": "iFlyTek Spark completion model integration."
    },
    {
      "type": "p",
      "content": "llms.stochasticai.StochasticAI"
    },
    {
      "type": "p",
      "content": "StochasticAI large language models."
    },
    {
      "type": "p",
      "content": "llms.symblai_nebula.Nebula"
    },
    {
      "type": "p",
      "content": "Nebula Service models."
    },
    {
      "type": "p",
      "content": "llms.textgen.TextGen"
    },
    {
      "type": "p",
      "content": "Text generation models from WebUI."
    },
    {
      "type": "p",
      "content": "llms.titan_takeoff.Device(value)"
    },
    {
      "type": "p",
      "content": "The device to use for inference, cuda or cpu"
    },
    {
      "type": "p",
      "content": "llms.titan_takeoff.ReaderConfig"
    },
    {
      "type": "p",
      "content": "Configuration for the reader to be deployed in Titan Takeoff API."
    },
    {
      "type": "p",
      "content": "llms.titan_takeoff.TitanTakeoff"
    },
    {
      "type": "p",
      "content": "Titan Takeoff API LLMs."
    },
    {
      "type": "p",
      "content": "llms.tongyi.Tongyi"
    },
    {
      "type": "p",
      "content": "Tongyi completion model integration."
    },
    {
      "type": "p",
      "content": "llms.vllm.VLLM"
    },
    {
      "type": "p",
      "content": "VLLM language model."
    },
    {
      "type": "p",
      "content": "llms.vllm.VLLMOpenAI"
    },
    {
      "type": "p",
      "content": "vLLM OpenAI-compatible API client"
    },
    {
      "type": "p",
      "content": "llms.volcengine_maas.VolcEngineMaasBase"
    },
    {
      "type": "p",
      "content": "Base class for VolcEngineMaas models."
    },
    {
      "type": "p",
      "content": "llms.volcengine_maas.VolcEngineMaasLLM"
    },
    {
      "type": "p",
      "content": "volc engine maas hosts a plethora of models."
    },
    {
      "type": "p",
      "content": "llms.weight_only_quantization.WeightOnlyQuantPipeline"
    },
    {
      "type": "p",
      "content": "Weight only quantized model."
    },
    {
      "type": "p",
      "content": "llms.writer.Writer"
    },
    {
      "type": "p",
      "content": "Writer large language models."
    },
    {
      "type": "p",
      "content": "llms.xinference.Xinference"
    },
    {
      "type": "p",
      "content": "Xinferencelarge-scale model inference service."
    },
    {
      "type": "p",
      "content": "llms.yandex.YandexGPT"
    },
    {
      "type": "p",
      "content": "Yandex large language models."
    },
    {
      "type": "p",
      "content": "llms.yi.YiLLM"
    },
    {
      "type": "p",
      "content": "Yi large language models."
    },
    {
      "type": "p",
      "content": "llms.you.You"
    },
    {
      "type": "p",
      "content": "Wrapper around You.com's conversational Smart and Research APIs."
    },
    {
      "type": "p",
      "content": "llms.yuan2.Yuan2"
    },
    {
      "type": "p",
      "content": "Yuan2.0 language models."
    },
    {
      "type": "p",
      "content": "llms.anyscale.create_llm_result(choices, ...)"
    },
    {
      "type": "p",
      "content": "Create the LLMResult from the choices and prompts."
    },
    {
      "type": "p",
      "content": "llms.anyscale.update_token_usage(keys, ...)"
    },
    {
      "type": "p",
      "content": "Update token usage."
    },
    {
      "type": "p",
      "content": "llms.aviary.get_completions(model, prompt[, ...])"
    },
    {
      "type": "p",
      "content": "Get completions from Aviary models."
    },
    {
      "type": "p",
      "content": "llms.aviary.get_models()"
    },
    {
      "type": "p",
      "content": "List available models"
    },
    {
      "type": "p",
      "content": "llms.cohere.acompletion_with_retry(llm, **kwargs)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "llms.cohere.completion_with_retry(llm, **kwargs)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "llms.databricks.get_default_api_token()"
    },
    {
      "type": "p",
      "content": "Get the default Databricks personal access token."
    },
    {
      "type": "p",
      "content": "llms.databricks.get_default_host()"
    },
    {
      "type": "p",
      "content": "Get the default Databricks workspace hostname."
    },
    {
      "type": "p",
      "content": "llms.databricks.get_repl_context()"
    },
    {
      "type": "p",
      "content": "Get the notebook REPL context if running inside a Databricks notebook."
    },
    {
      "type": "p",
      "content": "llms.fireworks.acompletion_with_retry(llm, ...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "llms.fireworks.acompletion_with_retry_batching(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "llms.fireworks.acompletion_with_retry_streaming(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call for streaming."
    },
    {
      "type": "p",
      "content": "llms.fireworks.completion_with_retry(llm, ...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "llms.fireworks.completion_with_retry_batching(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "llms.fireworks.conditional_decorator(...)"
    },
    {
      "type": "p",
      "content": "Conditionally apply a decorator."
    },
    {
      "type": "p",
      "content": "llms.google_palm.completion_with_retry(llm, ...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "llms.koboldai.clean_url(url)"
    },
    {
      "type": "p",
      "content": "Remove trailing slash and /api from url if present."
    },
    {
      "type": "p",
      "content": "llms.layerup_security.default_guardrail_violation_handler(...)"
    },
    {
      "type": "p",
      "content": "Default guardrail violation handler."
    },
    {
      "type": "p",
      "content": "llms.loading.load_llm(file, **kwargs)"
    },
    {
      "type": "p",
      "content": "Load LLM from a file."
    },
    {
      "type": "p",
      "content": "llms.loading.load_llm_from_config(config, ...)"
    },
    {
      "type": "p",
      "content": "Load LLM from Config Dict."
    },
    {
      "type": "p",
      "content": "llms.openai.acompletion_with_retry(llm[, ...])"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the async completion call."
    },
    {
      "type": "p",
      "content": "llms.openai.completion_with_retry(llm[, ...])"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "llms.openai.update_token_usage(keys, ...)"
    },
    {
      "type": "p",
      "content": "Update token usage."
    },
    {
      "type": "p",
      "content": "llms.symblai_nebula.completion_with_retry(...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "llms.symblai_nebula.make_request(self, prompt)"
    },
    {
      "type": "p",
      "content": "Generate text from the model."
    },
    {
      "type": "p",
      "content": "llms.tongyi.agenerate_with_last_element_mark(...)"
    },
    {
      "type": "p",
      "content": "Generate elements from an async iterable, and a boolean indicating if it is the last element."
    },
    {
      "type": "p",
      "content": "llms.tongyi.astream_generate_with_retry(llm, ...)"
    },
    {
      "type": "p",
      "content": "Async version ofstream_generate_with_retry."
    },
    {
      "type": "p",
      "content": "llms.tongyi.check_response(resp)"
    },
    {
      "type": "p",
      "content": "Check the response from the completion call."
    },
    {
      "type": "p",
      "content": "llms.tongyi.generate_with_last_element_mark(...)"
    },
    {
      "type": "p",
      "content": "Generate elements from an iterable, and a boolean indicating if it is the last element."
    },
    {
      "type": "p",
      "content": "llms.tongyi.generate_with_retry(llm, **kwargs)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "llms.tongyi.stream_generate_with_retry(llm, ...)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "llms.utils.enforce_stop_tokens(text, stop)"
    },
    {
      "type": "p",
      "content": "Cut off the text as soon as any stop words occur."
    },
    {
      "type": "p",
      "content": "llms.vertexai.acompletion_with_retry(llm, prompt)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "llms.vertexai.completion_with_retry(llm, prompt)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "llms.vertexai.is_codey_model(model_name)"
    },
    {
      "type": "p",
      "content": "Return True if the model name is a Codey model."
    },
    {
      "type": "p",
      "content": "llms.vertexai.is_gemini_model(model_name)"
    },
    {
      "type": "p",
      "content": "Return True if the model name is a Gemini model."
    },
    {
      "type": "p",
      "content": "llms.yandex.acompletion_with_retry(llm, **kwargs)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the async completion call."
    },
    {
      "type": "p",
      "content": "llms.yandex.completion_with_retry(llm, **kwargs)"
    },
    {
      "type": "p",
      "content": "Use tenacity to retry the completion call."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "llms.anthropic.Anthropic"
    },
    {
      "type": "p",
      "content": "llms.bedrock.Bedrock"
    },
    {
      "type": "p",
      "content": "llms.cohere.BaseCohere"
    },
    {
      "type": "p",
      "content": "llms.cohere.Cohere"
    },
    {
      "type": "p",
      "content": "llms.databricks.Databricks"
    },
    {
      "type": "p",
      "content": "llms.fireworks.Fireworks"
    },
    {
      "type": "p",
      "content": "llms.google_palm.GooglePalm"
    },
    {
      "type": "p",
      "content": "llms.huggingface_endpoint.HuggingFaceEndpoint"
    },
    {
      "type": "p",
      "content": "llms.huggingface_hub.HuggingFaceHub"
    },
    {
      "type": "p",
      "content": "llms.huggingface_pipeline.HuggingFacePipeline"
    },
    {
      "type": "p",
      "content": "llms.huggingface_text_gen_inference.HuggingFaceTextGenInference"
    },
    {
      "type": "p",
      "content": "llms.ollama.Ollama"
    },
    {
      "type": "p",
      "content": "llms.openai.AzureOpenAI"
    },
    {
      "type": "p",
      "content": "llms.openai.OpenAI"
    },
    {
      "type": "p",
      "content": "llms.openai.OpenAIChat"
    },
    {
      "type": "p",
      "content": "llms.predictionguard.PredictionGuard"
    },
    {
      "type": "p",
      "content": "llms.sagemaker_endpoint.SagemakerEndpoint"
    },
    {
      "type": "p",
      "content": "llms.together.Together"
    },
    {
      "type": "p",
      "content": "llms.vertexai.VertexAI"
    },
    {
      "type": "p",
      "content": "llms.vertexai.VertexAIModelGarden"
    },
    {
      "type": "p",
      "content": "llms.watsonxllm.WatsonxLLM"
    },
    {
      "type": "p",
      "content": "memory.kg.ConversationKGMemory"
    },
    {
      "type": "p",
      "content": "Knowledge graph conversation memory."
    },
    {
      "type": "p",
      "content": "memory.motorhead_memory.MotorheadMemory"
    },
    {
      "type": "p",
      "content": "Chat message memory backed by Motorhead service."
    },
    {
      "type": "p",
      "content": "memory.zep_cloud_memory.ZepCloudMemory()"
    },
    {
      "type": "p",
      "content": "memory.zep_memory.ZepMemory"
    },
    {
      "type": "p",
      "content": "Persist your chain history to the Zep MemoryStore."
    },
    {
      "type": "h2",
      "content": "output_parsers#"
    },
    {
      "type": "p",
      "content": "output_parsers.ernie_functions.JsonKeyOutputFunctionsParser"
    },
    {
      "type": "p",
      "content": "Parse an output as the element of the Json object."
    },
    {
      "type": "p",
      "content": "output_parsers.ernie_functions.JsonOutputFunctionsParser"
    },
    {
      "type": "p",
      "content": "Parse an output as the Json object."
    },
    {
      "type": "p",
      "content": "output_parsers.ernie_functions.OutputFunctionsParser"
    },
    {
      "type": "p",
      "content": "Parse an output that is one of sets of values."
    },
    {
      "type": "p",
      "content": "output_parsers.ernie_functions.PydanticAttrOutputFunctionsParser"
    },
    {
      "type": "p",
      "content": "Parse an output as an attribute of a pydantic object."
    },
    {
      "type": "p",
      "content": "output_parsers.ernie_functions.PydanticOutputFunctionsParser"
    },
    {
      "type": "p",
      "content": "Parse an output as a pydantic object."
    },
    {
      "type": "p",
      "content": "output_parsers.rail_parser.GuardrailsOutputParser"
    },
    {
      "type": "p",
      "content": "Parse the output of an LLM call using Guardrails."
    },
    {
      "type": "h2",
      "content": "query_constructors#"
    },
    {
      "type": "p",
      "content": "query_constructors.astradb.AstraDBTranslator()"
    },
    {
      "type": "p",
      "content": "Translate AstraDB internal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.chroma.ChromaTranslator()"
    },
    {
      "type": "p",
      "content": "TranslateChromainternal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.dashvector.DashvectorTranslator()"
    },
    {
      "type": "p",
      "content": "Logic for converting internal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.databricks_vector_search.DatabricksVectorSearchTranslator()"
    },
    {
      "type": "p",
      "content": "TranslateDatabricks vector searchinternal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.deeplake.DeepLakeTranslator()"
    },
    {
      "type": "p",
      "content": "TranslateDeepLakeinternal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.dingo.DingoDBTranslator()"
    },
    {
      "type": "p",
      "content": "TranslateDingoDBinternal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.elasticsearch.ElasticsearchTranslator()"
    },
    {
      "type": "p",
      "content": "TranslateElasticsearchinternal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.milvus.MilvusTranslator()"
    },
    {
      "type": "p",
      "content": "Translate Milvus internal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.mongodb_atlas.MongoDBAtlasTranslator()"
    },
    {
      "type": "p",
      "content": "Translate Mongo internal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.myscale.MyScaleTranslator([...])"
    },
    {
      "type": "p",
      "content": "TranslateMyScaleinternal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.opensearch.OpenSearchTranslator()"
    },
    {
      "type": "p",
      "content": "TranslateOpenSearchinternal query domain-specific language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.pgvector.PGVectorTranslator()"
    },
    {
      "type": "p",
      "content": "TranslatePGVectorinternal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.pinecone.PineconeTranslator()"
    },
    {
      "type": "p",
      "content": "TranslatePineconeinternal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.qdrant.QdrantTranslator(...)"
    },
    {
      "type": "p",
      "content": "TranslateQdrantinternal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.redis.RedisTranslator(schema)"
    },
    {
      "type": "p",
      "content": "Visitor for translating structured queries to Redis filter expressions."
    },
    {
      "type": "p",
      "content": "query_constructors.supabase.SupabaseVectorTranslator()"
    },
    {
      "type": "p",
      "content": "Translate Langchain filters to Supabase PostgREST filters."
    },
    {
      "type": "p",
      "content": "query_constructors.tencentvectordb.TencentVectorDBTranslator([...])"
    },
    {
      "type": "p",
      "content": "Translate StructuredQuery to Tencent VectorDB query."
    },
    {
      "type": "p",
      "content": "query_constructors.timescalevector.TimescaleVectorTranslator()"
    },
    {
      "type": "p",
      "content": "Translate the internal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.vectara.VectaraTranslator()"
    },
    {
      "type": "p",
      "content": "TranslateVectarainternal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.weaviate.WeaviateTranslator()"
    },
    {
      "type": "p",
      "content": "TranslateWeaviateinternal query language elements to valid filters."
    },
    {
      "type": "p",
      "content": "query_constructors.deeplake.can_cast_to_float(string)"
    },
    {
      "type": "p",
      "content": "Check if a string can be cast to a float."
    },
    {
      "type": "p",
      "content": "query_constructors.milvus.process_value(...)"
    },
    {
      "type": "p",
      "content": "Convert a value to a string and add double quotes if it is a string."
    },
    {
      "type": "p",
      "content": "query_constructors.vectara.process_value(value)"
    },
    {
      "type": "p",
      "content": "Convert a value to a string and add single quotes if it is a string."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "query_constructors.hanavector.HanaTranslator(...)"
    },
    {
      "type": "p",
      "content": "query_constructors.neo4j.Neo4jTranslator(...)"
    },
    {
      "type": "h2",
      "content": "retrievers#"
    },
    {
      "type": "p",
      "content": "retrievers.arcee.ArceeRetriever"
    },
    {
      "type": "p",
      "content": "Arcee Domain Adapted Language Models (DALMs) retriever."
    },
    {
      "type": "p",
      "content": "retrievers.arxiv.ArxivRetriever"
    },
    {
      "type": "p",
      "content": "Arxivretriever."
    },
    {
      "type": "p",
      "content": "retrievers.asknews.AskNewsRetriever"
    },
    {
      "type": "p",
      "content": "AskNews retriever."
    },
    {
      "type": "p",
      "content": "retrievers.azure_ai_search.AzureAISearchRetriever"
    },
    {
      "type": "p",
      "content": "Azure AI Searchservice retriever."
    },
    {
      "type": "p",
      "content": "retrievers.azure_ai_search.AzureCognitiveSearchRetriever"
    },
    {
      "type": "p",
      "content": "Azure Cognitive Searchservice retriever."
    },
    {
      "type": "p",
      "content": "retrievers.bedrock.RetrievalConfig"
    },
    {
      "type": "p",
      "content": "Configuration for retrieval."
    },
    {
      "type": "p",
      "content": "retrievers.bedrock.VectorSearchConfig"
    },
    {
      "type": "p",
      "content": "Configuration for vector search."
    },
    {
      "type": "p",
      "content": "retrievers.bm25.BM25Retriever"
    },
    {
      "type": "p",
      "content": "BM25retriever without Elasticsearch."
    },
    {
      "type": "p",
      "content": "retrievers.breebs.BreebsRetriever"
    },
    {
      "type": "p",
      "content": "A retriever class forBreebs."
    },
    {
      "type": "p",
      "content": "retrievers.chaindesk.ChaindeskRetriever"
    },
    {
      "type": "p",
      "content": "Chaindesk APIretriever."
    },
    {
      "type": "p",
      "content": "retrievers.chatgpt_plugin_retriever.ChatGPTPluginRetriever"
    },
    {
      "type": "p",
      "content": "ChatGPT pluginretriever."
    },
    {
      "type": "p",
      "content": "retrievers.databerry.DataberryRetriever"
    },
    {
      "type": "p",
      "content": "Databerry APIretriever."
    },
    {
      "type": "p",
      "content": "retrievers.docarray.DocArrayRetriever"
    },
    {
      "type": "p",
      "content": "DocArray Document Indicesretriever."
    },
    {
      "type": "p",
      "content": "retrievers.docarray.SearchType(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of the types of search to perform."
    },
    {
      "type": "p",
      "content": "retrievers.dria_index.DriaRetriever"
    },
    {
      "type": "p",
      "content": "Driaretriever using the DriaAPIWrapper."
    },
    {
      "type": "p",
      "content": "retrievers.elastic_search_bm25.ElasticSearchBM25Retriever"
    },
    {
      "type": "p",
      "content": "Elasticsearchretriever that usesBM25."
    },
    {
      "type": "p",
      "content": "retrievers.embedchain.EmbedchainRetriever"
    },
    {
      "type": "p",
      "content": "Embedchainretriever."
    },
    {
      "type": "p",
      "content": "retrievers.google_vertex_ai_search.GoogleCloudEnterpriseSearchRetriever"
    },
    {
      "type": "p",
      "content": "Google Vertex Search APIretriever alias for backwards compatibility."
    },
    {
      "type": "p",
      "content": "retrievers.kay.KayAiRetriever"
    },
    {
      "type": "p",
      "content": "Retriever for Kay.ai datasets."
    },
    {
      "type": "p",
      "content": "retrievers.kendra.AdditionalResultAttribute"
    },
    {
      "type": "p",
      "content": "Additional result attribute."
    },
    {
      "type": "p",
      "content": "retrievers.kendra.AdditionalResultAttributeValue"
    },
    {
      "type": "p",
      "content": "Value of an additional result attribute."
    },
    {
      "type": "p",
      "content": "retrievers.kendra.DocumentAttribute"
    },
    {
      "type": "p",
      "content": "Document attribute."
    },
    {
      "type": "p",
      "content": "retrievers.kendra.DocumentAttributeValue"
    },
    {
      "type": "p",
      "content": "Value of a document attribute."
    },
    {
      "type": "p",
      "content": "retrievers.kendra.Highlight"
    },
    {
      "type": "p",
      "content": "Information that highlights the keywords in the excerpt."
    },
    {
      "type": "p",
      "content": "retrievers.kendra.QueryResult"
    },
    {
      "type": "p",
      "content": "Amazon Kendra Query APIsearch result."
    },
    {
      "type": "p",
      "content": "retrievers.kendra.QueryResultItem"
    },
    {
      "type": "p",
      "content": "Query API result item."
    },
    {
      "type": "p",
      "content": "retrievers.kendra.ResultItem"
    },
    {
      "type": "p",
      "content": "Base class of a result item."
    },
    {
      "type": "p",
      "content": "retrievers.kendra.RetrieveResult"
    },
    {
      "type": "p",
      "content": "Amazon Kendra Retrieve APIsearch result."
    },
    {
      "type": "p",
      "content": "retrievers.kendra.RetrieveResultItem"
    },
    {
      "type": "p",
      "content": "Retrieve API result item."
    },
    {
      "type": "p",
      "content": "retrievers.kendra.TextWithHighLights"
    },
    {
      "type": "p",
      "content": "Text with highlights."
    },
    {
      "type": "p",
      "content": "retrievers.knn.KNNRetriever"
    },
    {
      "type": "p",
      "content": "KNNretriever."
    },
    {
      "type": "p",
      "content": "retrievers.llama_index.LlamaIndexGraphRetriever"
    },
    {
      "type": "p",
      "content": "LlamaIndexgraph data structure retriever."
    },
    {
      "type": "p",
      "content": "retrievers.llama_index.LlamaIndexRetriever"
    },
    {
      "type": "p",
      "content": "LlamaIndexretriever."
    },
    {
      "type": "p",
      "content": "retrievers.metal.MetalRetriever"
    },
    {
      "type": "p",
      "content": "Metal APIretriever."
    },
    {
      "type": "p",
      "content": "retrievers.milvus.MilvusRetriever"
    },
    {
      "type": "p",
      "content": "Milvus API retriever."
    },
    {
      "type": "p",
      "content": "retrievers.nanopq.NanoPQRetriever"
    },
    {
      "type": "p",
      "content": "`NanoPQ retriever."
    },
    {
      "type": "p",
      "content": "retrievers.needle.NeedleRetriever"
    },
    {
      "type": "p",
      "content": "NeedleRetriever retrieves relevant documents or context from a Needle collection based on a search query."
    },
    {
      "type": "p",
      "content": "retrievers.outline.OutlineRetriever"
    },
    {
      "type": "p",
      "content": "Retriever for Outline API."
    },
    {
      "type": "p",
      "content": "retrievers.pinecone_hybrid_search.PineconeHybridSearchRetriever"
    },
    {
      "type": "p",
      "content": "Pinecone Hybrid Searchretriever."
    },
    {
      "type": "p",
      "content": "retrievers.pubmed.PubMedRetriever"
    },
    {
      "type": "p",
      "content": "PubMed APIretriever."
    },
    {
      "type": "p",
      "content": "retrievers.rememberizer.RememberizerRetriever"
    },
    {
      "type": "p",
      "content": "Rememberizerretriever."
    },
    {
      "type": "p",
      "content": "retrievers.remote_retriever.RemoteLangChainRetriever"
    },
    {
      "type": "p",
      "content": "LangChain APIretriever."
    },
    {
      "type": "p",
      "content": "retrievers.svm.SVMRetriever"
    },
    {
      "type": "p",
      "content": "SVMretriever."
    },
    {
      "type": "p",
      "content": "retrievers.tavily_search_api.SearchDepth(value)"
    },
    {
      "type": "p",
      "content": "Search depth as enumerator."
    },
    {
      "type": "p",
      "content": "retrievers.tavily_search_api.TavilySearchAPIRetriever"
    },
    {
      "type": "p",
      "content": "Tavily Search API retriever."
    },
    {
      "type": "p",
      "content": "retrievers.tfidf.TFIDFRetriever"
    },
    {
      "type": "p",
      "content": "TF-IDFretriever."
    },
    {
      "type": "p",
      "content": "retrievers.thirdai_neuraldb.NeuralDBRetriever"
    },
    {
      "type": "p",
      "content": "Document retriever that uses ThirdAI's NeuralDB."
    },
    {
      "type": "p",
      "content": "retrievers.vespa_retriever.VespaRetriever"
    },
    {
      "type": "p",
      "content": "Vesparetriever."
    },
    {
      "type": "p",
      "content": "retrievers.web_research.QuestionListOutputParser"
    },
    {
      "type": "p",
      "content": "Output parser for a list of numbered questions."
    },
    {
      "type": "p",
      "content": "retrievers.web_research.SearchQueries"
    },
    {
      "type": "p",
      "content": "Search queries to research for the user's goal."
    },
    {
      "type": "p",
      "content": "retrievers.web_research.WebResearchRetriever"
    },
    {
      "type": "p",
      "content": "Google Search APIretriever."
    },
    {
      "type": "p",
      "content": "retrievers.wikipedia.WikipediaRetriever"
    },
    {
      "type": "p",
      "content": "Wikipedia APIretriever."
    },
    {
      "type": "p",
      "content": "retrievers.you.YouRetriever"
    },
    {
      "type": "p",
      "content": "You.com Search API retriever."
    },
    {
      "type": "p",
      "content": "retrievers.zep.SearchScope(value)"
    },
    {
      "type": "p",
      "content": "Which documents to search."
    },
    {
      "type": "p",
      "content": "retrievers.zep.SearchType(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of the types of search to perform."
    },
    {
      "type": "p",
      "content": "retrievers.zep.ZepRetriever"
    },
    {
      "type": "p",
      "content": "ZepMemoryStore Retriever."
    },
    {
      "type": "p",
      "content": "retrievers.zep_cloud.ZepCloudRetriever"
    },
    {
      "type": "p",
      "content": "Zep CloudMemoryStore Retriever."
    },
    {
      "type": "p",
      "content": "retrievers.zilliz.ZillizRetriever"
    },
    {
      "type": "p",
      "content": "Zilliz APIretriever."
    },
    {
      "type": "p",
      "content": "retrievers.bm25.default_preprocessing_func(text)"
    },
    {
      "type": "p",
      "content": "retrievers.kendra.clean_excerpt(excerpt)"
    },
    {
      "type": "p",
      "content": "Clean an excerpt from Kendra."
    },
    {
      "type": "p",
      "content": "retrievers.kendra.combined_text(item)"
    },
    {
      "type": "p",
      "content": "Combine a ResultItem title and excerpt into a single string."
    },
    {
      "type": "p",
      "content": "retrievers.knn.create_index(contexts, embeddings)"
    },
    {
      "type": "p",
      "content": "Create an index of embeddings for a list of contexts."
    },
    {
      "type": "p",
      "content": "retrievers.milvus.MilvusRetreiver(*args, ...)"
    },
    {
      "type": "p",
      "content": "Deprecated MilvusRetreiver."
    },
    {
      "type": "p",
      "content": "retrievers.nanopq.create_index(contexts, ...)"
    },
    {
      "type": "p",
      "content": "Create an index of embeddings for a list of contexts."
    },
    {
      "type": "p",
      "content": "retrievers.pinecone_hybrid_search.create_index(...)"
    },
    {
      "type": "p",
      "content": "Create an index from a list of contexts."
    },
    {
      "type": "p",
      "content": "retrievers.pinecone_hybrid_search.hash_text(text)"
    },
    {
      "type": "p",
      "content": "Hash a text using SHA256."
    },
    {
      "type": "p",
      "content": "retrievers.svm.create_index(contexts, embeddings)"
    },
    {
      "type": "p",
      "content": "Create an index of embeddings for a list of contexts."
    },
    {
      "type": "p",
      "content": "retrievers.zilliz.ZillizRetreiver(*args, ...)"
    },
    {
      "type": "p",
      "content": "Deprecated ZillizRetreiver."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "retrievers.bedrock.AmazonKnowledgeBasesRetriever"
    },
    {
      "type": "p",
      "content": "retrievers.cohere_rag_retriever.CohereRagRetriever"
    },
    {
      "type": "p",
      "content": "retrievers.google_cloud_documentai_warehouse.GoogleDocumentAIWarehouseRetriever"
    },
    {
      "type": "p",
      "content": "retrievers.google_vertex_ai_search.GoogleVertexAIMultiTurnSearchRetriever"
    },
    {
      "type": "p",
      "content": "retrievers.google_vertex_ai_search.GoogleVertexAISearchRetriever"
    },
    {
      "type": "p",
      "content": "retrievers.kendra.AmazonKendraRetriever"
    },
    {
      "type": "p",
      "content": "retrievers.qdrant_sparse_vector_retriever.QdrantSparseVectorRetriever"
    },
    {
      "type": "p",
      "content": "retrievers.weaviate_hybrid_search.WeaviateHybridSearchRetriever"
    },
    {
      "type": "p",
      "content": "storage.astradb.AstraDBBaseStore(*args, **kwargs)"
    },
    {
      "type": "p",
      "content": "Base class for the DataStax AstraDB data store."
    },
    {
      "type": "p",
      "content": "storage.cassandra.CassandraByteStore(table, *)"
    },
    {
      "type": "p",
      "content": "A ByteStore implementation using Cassandra as the backend."
    },
    {
      "type": "p",
      "content": "storage.mongodb.MongoDBByteStore(...[, ...])"
    },
    {
      "type": "p",
      "content": "BaseStore implementation using MongoDB as the underlying store."
    },
    {
      "type": "p",
      "content": "storage.mongodb.MongoDBStore(...[, ...])"
    },
    {
      "type": "p",
      "content": "BaseStore implementation using MongoDB as the underlying store."
    },
    {
      "type": "p",
      "content": "storage.redis.RedisStore(*[, client, ...])"
    },
    {
      "type": "p",
      "content": "BaseStore implementation using Redis as the underlying store."
    },
    {
      "type": "p",
      "content": "storage.sql.LangchainKeyValueStores(**kwargs)"
    },
    {
      "type": "p",
      "content": "Table used to save values."
    },
    {
      "type": "p",
      "content": "storage.sql.SQLStore(*, namespace[, db_url, ...])"
    },
    {
      "type": "p",
      "content": "BaseStore interface that works on an SQL database."
    },
    {
      "type": "p",
      "content": "storage.upstash_redis.UpstashRedisByteStore(*)"
    },
    {
      "type": "p",
      "content": "BaseStore implementation using Upstash Redis as the underlying store to store raw bytes."
    },
    {
      "type": "p",
      "content": "storage.sql.items_equal(x, y)"
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "storage.astradb.AstraDBByteStore(collection_name)"
    },
    {
      "type": "p",
      "content": "storage.astradb.AstraDBStore(collection_name)"
    },
    {
      "type": "p",
      "content": "storage.upstash_redis.UpstashRedisStore(*[, ...])"
    },
    {
      "type": "p",
      "content": "tools.ainetwork.app.AINAppOps"
    },
    {
      "type": "p",
      "content": "Tool for app operations."
    },
    {
      "type": "p",
      "content": "tools.ainetwork.app.AppOperationType(value)"
    },
    {
      "type": "p",
      "content": "Type of app operation as enumerator."
    },
    {
      "type": "p",
      "content": "tools.ainetwork.app.AppSchema"
    },
    {
      "type": "p",
      "content": "Schema for app operations."
    },
    {
      "type": "p",
      "content": "tools.ainetwork.base.AINBaseTool"
    },
    {
      "type": "p",
      "content": "Base class for the AINetwork tools."
    },
    {
      "type": "p",
      "content": "tools.ainetwork.base.OperationType(value)"
    },
    {
      "type": "p",
      "content": "Type of operation as enumerator."
    },
    {
      "type": "p",
      "content": "tools.ainetwork.owner.AINOwnerOps"
    },
    {
      "type": "p",
      "content": "Tool for owner operations."
    },
    {
      "type": "p",
      "content": "tools.ainetwork.owner.RuleSchema"
    },
    {
      "type": "p",
      "content": "Schema for owner operations."
    },
    {
      "type": "p",
      "content": "tools.ainetwork.rule.AINRuleOps"
    },
    {
      "type": "p",
      "content": "Tool for owner operations."
    },
    {
      "type": "p",
      "content": "tools.ainetwork.rule.RuleSchema"
    },
    {
      "type": "p",
      "content": "Schema for owner operations."
    },
    {
      "type": "p",
      "content": "tools.ainetwork.transfer.AINTransfer"
    },
    {
      "type": "p",
      "content": "Tool for transfer operations."
    },
    {
      "type": "p",
      "content": "tools.ainetwork.transfer.TransferSchema"
    },
    {
      "type": "p",
      "content": "Schema for transfer operations."
    },
    {
      "type": "p",
      "content": "tools.ainetwork.value.AINValueOps"
    },
    {
      "type": "p",
      "content": "Tool for value operations."
    },
    {
      "type": "p",
      "content": "tools.ainetwork.value.ValueSchema"
    },
    {
      "type": "p",
      "content": "Schema for value operations."
    },
    {
      "type": "p",
      "content": "tools.amadeus.base.AmadeusBaseTool"
    },
    {
      "type": "p",
      "content": "Base Tool for Amadeus."
    },
    {
      "type": "p",
      "content": "tools.amadeus.closest_airport.AmadeusClosestAirport"
    },
    {
      "type": "p",
      "content": "Tool for finding the closest airport to a particular location."
    },
    {
      "type": "p",
      "content": "tools.amadeus.closest_airport.ClosestAirportSchema"
    },
    {
      "type": "p",
      "content": "Schema for the AmadeusClosestAirport tool."
    },
    {
      "type": "p",
      "content": "tools.amadeus.flight_search.AmadeusFlightSearch"
    },
    {
      "type": "p",
      "content": "Tool for searching for a single flight between two airports."
    },
    {
      "type": "p",
      "content": "tools.amadeus.flight_search.FlightSearchSchema"
    },
    {
      "type": "p",
      "content": "Schema for the AmadeusFlightSearch tool."
    },
    {
      "type": "p",
      "content": "tools.arxiv.tool.ArxivInput"
    },
    {
      "type": "p",
      "content": "Input for the Arxiv tool."
    },
    {
      "type": "p",
      "content": "tools.arxiv.tool.ArxivQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that searches the Arxiv API."
    },
    {
      "type": "p",
      "content": "tools.asknews.tool.AskNewsSearch"
    },
    {
      "type": "p",
      "content": "Tool that searches the AskNews API."
    },
    {
      "type": "p",
      "content": "tools.asknews.tool.SearchInput"
    },
    {
      "type": "p",
      "content": "Input for the AskNews Search tool."
    },
    {
      "type": "p",
      "content": "tools.audio.huggingface_text_to_speech_inference.HuggingFaceTextToSpeechModelInference"
    },
    {
      "type": "p",
      "content": "HuggingFace Text-to-Speech Model Inference."
    },
    {
      "type": "p",
      "content": "tools.azure_ai_services.document_intelligence.AzureAiServicesDocumentIntelligenceTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Azure AI Services Document Intelligence API."
    },
    {
      "type": "p",
      "content": "tools.azure_ai_services.image_analysis.AzureAiServicesImageAnalysisTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Azure AI Services Image Analysis API."
    },
    {
      "type": "p",
      "content": "tools.azure_ai_services.speech_to_text.AzureAiServicesSpeechToTextTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Azure AI Services Speech to Text API."
    },
    {
      "type": "p",
      "content": "tools.azure_ai_services.text_analytics_for_health.AzureAiServicesTextAnalyticsForHealthTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Azure AI Services Text Analytics for Health API."
    },
    {
      "type": "p",
      "content": "tools.azure_ai_services.text_to_speech.AzureAiServicesTextToSpeechTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Azure AI Services Text to Speech API."
    },
    {
      "type": "p",
      "content": "tools.azure_cognitive_services.form_recognizer.AzureCogsFormRecognizerTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Azure Cognitive Services Form Recognizer API."
    },
    {
      "type": "p",
      "content": "tools.azure_cognitive_services.image_analysis.AzureCogsImageAnalysisTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Azure Cognitive Services Image Analysis API."
    },
    {
      "type": "p",
      "content": "tools.azure_cognitive_services.speech2text.AzureCogsSpeech2TextTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Azure Cognitive Services Speech2Text API."
    },
    {
      "type": "p",
      "content": "tools.azure_cognitive_services.text2speech.AzureCogsText2SpeechTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Azure Cognitive Services Text2Speech API."
    },
    {
      "type": "p",
      "content": "tools.azure_cognitive_services.text_analytics_health.AzureCogsTextAnalyticsHealthTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Azure Cognitive Services Text Analytics for Health API."
    },
    {
      "type": "p",
      "content": "tools.bearly.tool.BearlyInterpreterTool(api_key)"
    },
    {
      "type": "p",
      "content": "Tool for evaluating python code in a sandbox environment."
    },
    {
      "type": "p",
      "content": "tools.bearly.tool.BearlyInterpreterToolArguments"
    },
    {
      "type": "p",
      "content": "Arguments for the BearlyInterpreterTool."
    },
    {
      "type": "p",
      "content": "tools.bearly.tool.FileInfo"
    },
    {
      "type": "p",
      "content": "Information about a file to be uploaded."
    },
    {
      "type": "p",
      "content": "tools.bing_search.tool.BingSearchResults"
    },
    {
      "type": "p",
      "content": "Bing Search tool."
    },
    {
      "type": "p",
      "content": "tools.bing_search.tool.BingSearchRun"
    },
    {
      "type": "p",
      "content": "Tool that queries the Bing search API."
    },
    {
      "type": "p",
      "content": "tools.brave_search.tool.BraveSearch"
    },
    {
      "type": "p",
      "content": "Tool that queries the BraveSearch."
    },
    {
      "type": "p",
      "content": "tools.cassandra_database.tool.BaseCassandraDatabaseTool"
    },
    {
      "type": "p",
      "content": "Base tool for interacting with an Apache Cassandra database."
    },
    {
      "type": "p",
      "content": "tools.cassandra_database.tool.GetSchemaCassandraDatabaseTool"
    },
    {
      "type": "p",
      "content": "Tool for getting the schema of a keyspace in an Apache Cassandra database."
    },
    {
      "type": "p",
      "content": "tools.cassandra_database.tool.GetTableDataCassandraDatabaseTool"
    },
    {
      "type": "p",
      "content": "Tool for getting data from a table in an Apache Cassandra database."
    },
    {
      "type": "p",
      "content": "tools.cassandra_database.tool.QueryCassandraDatabaseTool"
    },
    {
      "type": "p",
      "content": "Tool for querying an Apache Cassandra database with provided CQL."
    },
    {
      "type": "p",
      "content": "tools.clickup.tool.ClickupAction"
    },
    {
      "type": "p",
      "content": "Tool that queries the  Clickup API."
    },
    {
      "type": "p",
      "content": "tools.cogniswitch.tool.CogniswitchKnowledgeRequest"
    },
    {
      "type": "p",
      "content": "Tool that uses the Cogniswitch service to answer questions."
    },
    {
      "type": "p",
      "content": "tools.cogniswitch.tool.CogniswitchKnowledgeSourceFile"
    },
    {
      "type": "p",
      "content": "Tool that uses the Cogniswitch services to store data from file."
    },
    {
      "type": "p",
      "content": "tools.cogniswitch.tool.CogniswitchKnowledgeSourceURL"
    },
    {
      "type": "p",
      "content": "Tool that uses the Cogniswitch services to store data from a URL."
    },
    {
      "type": "p",
      "content": "tools.cogniswitch.tool.CogniswitchKnowledgeStatus"
    },
    {
      "type": "p",
      "content": "Tool that uses the Cogniswitch services to get the"
    },
    {
      "type": "p",
      "content": "tools.connery.models.Action"
    },
    {
      "type": "p",
      "content": "Connery Action model."
    },
    {
      "type": "p",
      "content": "tools.connery.models.Parameter"
    },
    {
      "type": "p",
      "content": "Connery Action parameter model."
    },
    {
      "type": "p",
      "content": "tools.connery.models.Validation"
    },
    {
      "type": "p",
      "content": "Connery Action parameter validation model."
    },
    {
      "type": "p",
      "content": "tools.connery.service.ConneryService"
    },
    {
      "type": "p",
      "content": "Service for interacting with the Connery Runner API."
    },
    {
      "type": "p",
      "content": "tools.connery.tool.ConneryAction"
    },
    {
      "type": "p",
      "content": "Connery Action tool."
    },
    {
      "type": "p",
      "content": "tools.dataforseo_api_search.tool.DataForSeoAPISearchResults"
    },
    {
      "type": "p",
      "content": "Tool that queries the DataForSeo Google Search API and get back json."
    },
    {
      "type": "p",
      "content": "tools.dataforseo_api_search.tool.DataForSeoAPISearchRun"
    },
    {
      "type": "p",
      "content": "Tool that queries the DataForSeo Google search API."
    },
    {
      "type": "p",
      "content": "tools.dataherald.tool.DataheraldTextToSQL"
    },
    {
      "type": "p",
      "content": "Tool that queries using the Dataherald SDK."
    },
    {
      "type": "p",
      "content": "tools.dataherald.tool.DataheraldTextToSQLInput"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "tools.ddg_search.tool.DDGInput"
    },
    {
      "type": "p",
      "content": "Input for the DuckDuckGo search tool."
    },
    {
      "type": "p",
      "content": "tools.ddg_search.tool.DuckDuckGoSearchResults"
    },
    {
      "type": "p",
      "content": "Tool that queries the DuckDuckGo search API and returns the results inoutput_format."
    },
    {
      "type": "p",
      "content": "tools.ddg_search.tool.DuckDuckGoSearchRun"
    },
    {
      "type": "p",
      "content": "DuckDuckGo tool."
    },
    {
      "type": "p",
      "content": "tools.e2b_data_analysis.tool.E2BDataAnalysisTool"
    },
    {
      "type": "p",
      "content": "Tool for running python code in a sandboxed environment for data analysis."
    },
    {
      "type": "p",
      "content": "tools.e2b_data_analysis.tool.E2BDataAnalysisToolArguments"
    },
    {
      "type": "p",
      "content": "Arguments for the E2BDataAnalysisTool."
    },
    {
      "type": "p",
      "content": "tools.e2b_data_analysis.tool.UploadedFile"
    },
    {
      "type": "p",
      "content": "Description of the uploaded path with its remote path."
    },
    {
      "type": "p",
      "content": "tools.e2b_data_analysis.unparse.Unparser(tree)"
    },
    {
      "type": "p",
      "content": "Traverse an AST and output source code for the abstract syntax; original formatting is disregarded."
    },
    {
      "type": "p",
      "content": "tools.edenai.audio_speech_to_text.EdenAiSpeechToTextTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Eden AI Speech To Text API."
    },
    {
      "type": "p",
      "content": "tools.edenai.audio_speech_to_text.SpeechToTextInput"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "tools.edenai.audio_text_to_speech.EdenAiTextToSpeechTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Eden AI Text to speech API."
    },
    {
      "type": "p",
      "content": "tools.edenai.audio_text_to_speech.TextToSpeechInput"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "tools.edenai.edenai_base_tool.EdenaiTool"
    },
    {
      "type": "p",
      "content": "the base tool for all the EdenAI Tools ."
    },
    {
      "type": "p",
      "content": "tools.edenai.image_explicitcontent.EdenAiExplicitImageTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Eden AI Explicit image detection."
    },
    {
      "type": "p",
      "content": "tools.edenai.image_explicitcontent.ExplicitImageInput"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "tools.edenai.image_objectdetection.EdenAiObjectDetectionTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Eden AI Object detection API."
    },
    {
      "type": "p",
      "content": "tools.edenai.image_objectdetection.ObjectDetectionInput"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "tools.edenai.ocr_identityparser.EdenAiParsingIDTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Eden AI  Identity parsing API."
    },
    {
      "type": "p",
      "content": "tools.edenai.ocr_identityparser.IDParsingInput"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "tools.edenai.ocr_invoiceparser.EdenAiParsingInvoiceTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Eden AI Invoice parsing API."
    },
    {
      "type": "p",
      "content": "tools.edenai.ocr_invoiceparser.InvoiceParsingInput"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "tools.edenai.text_moderation.EdenAiTextModerationTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Eden AI Explicit text detection."
    },
    {
      "type": "p",
      "content": "tools.edenai.text_moderation.TextModerationInput"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "tools.eleven_labs.models.ElevenLabsModel(value)"
    },
    {
      "type": "p",
      "content": "Models available for Eleven Labs Text2Speech."
    },
    {
      "type": "p",
      "content": "tools.eleven_labs.text2speech.ElevenLabsModel(value)"
    },
    {
      "type": "p",
      "content": "Models available for Eleven Labs Text2Speech."
    },
    {
      "type": "p",
      "content": "tools.eleven_labs.text2speech.ElevenLabsText2SpeechTool"
    },
    {
      "type": "p",
      "content": "Tool that queries the Eleven Labs Text2Speech API."
    },
    {
      "type": "p",
      "content": "tools.few_shot.tool.FewShotSQLTool"
    },
    {
      "type": "p",
      "content": "Tool to get example SQL queries related to an input question."
    },
    {
      "type": "p",
      "content": "tools.file_management.copy.CopyFileTool"
    },
    {
      "type": "p",
      "content": "Tool that copies a file."
    },
    {
      "type": "p",
      "content": "tools.file_management.copy.FileCopyInput"
    },
    {
      "type": "p",
      "content": "Input for CopyFileTool."
    },
    {
      "type": "p",
      "content": "tools.file_management.delete.DeleteFileTool"
    },
    {
      "type": "p",
      "content": "Tool that deletes a file."
    },
    {
      "type": "p",
      "content": "tools.file_management.delete.FileDeleteInput"
    },
    {
      "type": "p",
      "content": "Input for DeleteFileTool."
    },
    {
      "type": "p",
      "content": "tools.file_management.file_search.FileSearchInput"
    },
    {
      "type": "p",
      "content": "Input for FileSearchTool."
    },
    {
      "type": "p",
      "content": "tools.file_management.file_search.FileSearchTool"
    },
    {
      "type": "p",
      "content": "Tool that searches for files in a subdirectory that match a regex pattern."
    },
    {
      "type": "p",
      "content": "tools.file_management.list_dir.DirectoryListingInput"
    },
    {
      "type": "p",
      "content": "Input for ListDirectoryTool."
    },
    {
      "type": "p",
      "content": "tools.file_management.list_dir.ListDirectoryTool"
    },
    {
      "type": "p",
      "content": "Tool that lists files and directories in a specified folder."
    },
    {
      "type": "p",
      "content": "tools.file_management.move.FileMoveInput"
    },
    {
      "type": "p",
      "content": "Input for MoveFileTool."
    },
    {
      "type": "p",
      "content": "tools.file_management.move.MoveFileTool"
    },
    {
      "type": "p",
      "content": "Tool that moves a file."
    },
    {
      "type": "p",
      "content": "tools.file_management.read.ReadFileInput"
    },
    {
      "type": "p",
      "content": "Input for ReadFileTool."
    },
    {
      "type": "p",
      "content": "tools.file_management.read.ReadFileTool"
    },
    {
      "type": "p",
      "content": "Tool that reads a file."
    },
    {
      "type": "p",
      "content": "tools.file_management.utils.BaseFileToolMixin"
    },
    {
      "type": "p",
      "content": "Mixin for file system tools."
    },
    {
      "type": "p",
      "content": "tools.file_management.utils.FileValidationError"
    },
    {
      "type": "p",
      "content": "Error for paths outside the root directory."
    },
    {
      "type": "p",
      "content": "tools.file_management.write.WriteFileInput"
    },
    {
      "type": "p",
      "content": "Input for WriteFileTool."
    },
    {
      "type": "p",
      "content": "tools.file_management.write.WriteFileTool"
    },
    {
      "type": "p",
      "content": "Tool that writes a file to disk."
    },
    {
      "type": "p",
      "content": "tools.financial_datasets.balance_sheets.BalanceSheets"
    },
    {
      "type": "p",
      "content": "Tool that gets balance sheets for a given ticker over a given period."
    },
    {
      "type": "p",
      "content": "tools.financial_datasets.balance_sheets.BalanceSheetsSchema"
    },
    {
      "type": "p",
      "content": "Input for BalanceSheets."
    },
    {
      "type": "p",
      "content": "tools.financial_datasets.cash_flow_statements.CashFlowStatements"
    },
    {
      "type": "p",
      "content": "Tool that gets cash flow statements for a given ticker over a given period."
    },
    {
      "type": "p",
      "content": "tools.financial_datasets.cash_flow_statements.CashFlowStatementsSchema"
    },
    {
      "type": "p",
      "content": "Input for CashFlowStatements."
    },
    {
      "type": "p",
      "content": "tools.financial_datasets.income_statements.IncomeStatements"
    },
    {
      "type": "p",
      "content": "Tool that gets income statements for a given ticker over a given period."
    },
    {
      "type": "p",
      "content": "tools.financial_datasets.income_statements.IncomeStatementsSchema"
    },
    {
      "type": "p",
      "content": "Input for IncomeStatements."
    },
    {
      "type": "p",
      "content": "tools.github.tool.GitHubAction"
    },
    {
      "type": "p",
      "content": "Tool for interacting with the GitHub API."
    },
    {
      "type": "p",
      "content": "tools.gitlab.tool.GitLabAction"
    },
    {
      "type": "p",
      "content": "Tool for interacting with the GitLab API."
    },
    {
      "type": "p",
      "content": "tools.gmail.base.GmailBaseTool"
    },
    {
      "type": "p",
      "content": "Base class for Gmail tools."
    },
    {
      "type": "p",
      "content": "tools.gmail.create_draft.CreateDraftSchema"
    },
    {
      "type": "p",
      "content": "Input for CreateDraftTool."
    },
    {
      "type": "p",
      "content": "tools.gmail.create_draft.GmailCreateDraft"
    },
    {
      "type": "p",
      "content": "Tool that creates a draft email for Gmail."
    },
    {
      "type": "p",
      "content": "tools.gmail.get_message.GmailGetMessage"
    },
    {
      "type": "p",
      "content": "Tool that gets a message by ID from Gmail."
    },
    {
      "type": "p",
      "content": "tools.gmail.get_message.SearchArgsSchema"
    },
    {
      "type": "p",
      "content": "Input for GetMessageTool."
    },
    {
      "type": "p",
      "content": "tools.gmail.get_thread.GetThreadSchema"
    },
    {
      "type": "p",
      "content": "Input for GetMessageTool."
    },
    {
      "type": "p",
      "content": "tools.gmail.get_thread.GmailGetThread"
    },
    {
      "type": "p",
      "content": "Tool that gets a thread by ID from Gmail."
    },
    {
      "type": "p",
      "content": "tools.gmail.search.GmailSearch"
    },
    {
      "type": "p",
      "content": "Tool that searches for messages or threads in Gmail."
    },
    {
      "type": "p",
      "content": "tools.gmail.search.Resource(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of Resources to search."
    },
    {
      "type": "p",
      "content": "tools.gmail.search.SearchArgsSchema"
    },
    {
      "type": "p",
      "content": "Input for SearchGmailTool."
    },
    {
      "type": "p",
      "content": "tools.gmail.send_message.GmailSendMessage"
    },
    {
      "type": "p",
      "content": "Tool that sends a message to Gmail."
    },
    {
      "type": "p",
      "content": "tools.gmail.send_message.SendMessageSchema"
    },
    {
      "type": "p",
      "content": "Input for SendMessageTool."
    },
    {
      "type": "p",
      "content": "tools.golden_query.tool.GoldenQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that adds the capability to query using the Golden API and get back JSON."
    },
    {
      "type": "p",
      "content": "tools.google_books.GoogleBooksQueryInput"
    },
    {
      "type": "p",
      "content": "Input for the GoogleBooksQuery tool."
    },
    {
      "type": "p",
      "content": "tools.google_books.GoogleBooksQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that searches the Google Books API."
    },
    {
      "type": "p",
      "content": "tools.google_finance.tool.GoogleFinanceQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that queries the Google Finance API."
    },
    {
      "type": "p",
      "content": "tools.google_jobs.tool.GoogleJobsQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that queries the Google Jobs API."
    },
    {
      "type": "p",
      "content": "tools.google_lens.tool.GoogleLensQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that queries the Google Lens API."
    },
    {
      "type": "p",
      "content": "tools.google_places.tool.GooglePlacesSchema"
    },
    {
      "type": "p",
      "content": "Input for GooglePlacesTool."
    },
    {
      "type": "p",
      "content": "tools.google_scholar.tool.GoogleScholarQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that queries the Google search API."
    },
    {
      "type": "p",
      "content": "tools.google_serper.tool.GoogleSerperResults"
    },
    {
      "type": "p",
      "content": "Tool that queries the Serper.dev Google Search API and get back json."
    },
    {
      "type": "p",
      "content": "tools.google_serper.tool.GoogleSerperRun"
    },
    {
      "type": "p",
      "content": "Tool that queries the Serper.dev Google search API."
    },
    {
      "type": "p",
      "content": "tools.google_trends.tool.GoogleTrendsQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that queries the Google trends API."
    },
    {
      "type": "p",
      "content": "tools.graphql.tool.BaseGraphQLTool"
    },
    {
      "type": "p",
      "content": "Base tool for querying a GraphQL API."
    },
    {
      "type": "p",
      "content": "tools.human.tool.HumanInputRun"
    },
    {
      "type": "p",
      "content": "Tool that asks user for input."
    },
    {
      "type": "p",
      "content": "tools.ifttt.IFTTTWebhook"
    },
    {
      "type": "p",
      "content": "IFTTT Webhook."
    },
    {
      "type": "p",
      "content": "tools.jina_search.tool.JinaInput"
    },
    {
      "type": "p",
      "content": "Input for the Jina search tool."
    },
    {
      "type": "p",
      "content": "tools.jina_search.tool.JinaSearch"
    },
    {
      "type": "p",
      "content": "Tool that queries the JinaSearch."
    },
    {
      "type": "p",
      "content": "tools.jira.tool.JiraAction"
    },
    {
      "type": "p",
      "content": "Tool that queries the Atlassian Jira API."
    },
    {
      "type": "p",
      "content": "tools.json.tool.JsonGetValueTool"
    },
    {
      "type": "p",
      "content": "Tool for getting a value in a JSON spec."
    },
    {
      "type": "p",
      "content": "tools.json.tool.JsonListKeysTool"
    },
    {
      "type": "p",
      "content": "Tool for listing keys in a JSON spec."
    },
    {
      "type": "p",
      "content": "tools.json.tool.JsonSpec"
    },
    {
      "type": "p",
      "content": "Base class for JSON spec."
    },
    {
      "type": "p",
      "content": "tools.memorize.tool.Memorize"
    },
    {
      "type": "p",
      "content": "Tool that trains a language model."
    },
    {
      "type": "p",
      "content": "tools.memorize.tool.TrainableLLM(*args, **kwargs)"
    },
    {
      "type": "p",
      "content": "Protocol for trainable language models."
    },
    {
      "type": "p",
      "content": "tools.merriam_webster.tool.MerriamWebsterQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that searches the Merriam-Webster API."
    },
    {
      "type": "p",
      "content": "tools.mojeek_search.tool.MojeekSearch"
    },
    {
      "type": "p",
      "content": "Initialize the tool."
    },
    {
      "type": "p",
      "content": "tools.multion.close_session.CloseSessionSchema"
    },
    {
      "type": "p",
      "content": "Input for UpdateSessionTool."
    },
    {
      "type": "p",
      "content": "tools.multion.close_session.MultionCloseSession"
    },
    {
      "type": "p",
      "content": "Tool that closes an existing Multion Browser Window with provided fields."
    },
    {
      "type": "p",
      "content": "tools.multion.create_session.CreateSessionSchema"
    },
    {
      "type": "p",
      "content": "Input for CreateSessionTool."
    },
    {
      "type": "p",
      "content": "tools.multion.create_session.MultionCreateSession"
    },
    {
      "type": "p",
      "content": "Tool that creates a new Multion Browser Window with provided fields."
    },
    {
      "type": "p",
      "content": "tools.multion.update_session.MultionUpdateSession"
    },
    {
      "type": "p",
      "content": "Tool that updates an existing Multion Browser Window with provided fields."
    },
    {
      "type": "p",
      "content": "tools.multion.update_session.UpdateSessionSchema"
    },
    {
      "type": "p",
      "content": "Input for UpdateSessionTool."
    },
    {
      "type": "p",
      "content": "tools.nasa.tool.NasaAction"
    },
    {
      "type": "p",
      "content": "Tool that queries the Atlassian Jira API."
    },
    {
      "type": "p",
      "content": "tools.nuclia.tool.NUASchema"
    },
    {
      "type": "p",
      "content": "Input for Nuclia Understanding API."
    },
    {
      "type": "p",
      "content": "tools.nuclia.tool.NucliaUnderstandingAPI"
    },
    {
      "type": "p",
      "content": "Tool to process files with the Nuclia Understanding API."
    },
    {
      "type": "p",
      "content": "tools.office365.base.O365BaseTool"
    },
    {
      "type": "p",
      "content": "Base class for the Office 365 tools."
    },
    {
      "type": "p",
      "content": "tools.office365.create_draft_message.CreateDraftMessageSchema"
    },
    {
      "type": "p",
      "content": "Input for SendMessageTool."
    },
    {
      "type": "p",
      "content": "tools.office365.create_draft_message.O365CreateDraftMessage"
    },
    {
      "type": "p",
      "content": "Tool for creating a draft email in Office 365."
    },
    {
      "type": "p",
      "content": "tools.office365.events_search.O365SearchEvents"
    },
    {
      "type": "p",
      "content": "Search calendar events in Office 365."
    },
    {
      "type": "p",
      "content": "tools.office365.events_search.SearchEventsInput"
    },
    {
      "type": "p",
      "content": "Input for SearchEmails Tool."
    },
    {
      "type": "p",
      "content": "tools.office365.messages_search.O365SearchEmails"
    },
    {
      "type": "p",
      "content": "Search email messages in Office 365."
    },
    {
      "type": "p",
      "content": "tools.office365.messages_search.SearchEmailsInput"
    },
    {
      "type": "p",
      "content": "Input for SearchEmails Tool."
    },
    {
      "type": "p",
      "content": "tools.office365.send_event.O365SendEvent"
    },
    {
      "type": "p",
      "content": "Tool for sending calendar events in Office 365."
    },
    {
      "type": "p",
      "content": "tools.office365.send_event.SendEventSchema"
    },
    {
      "type": "p",
      "content": "Input for CreateEvent Tool."
    },
    {
      "type": "p",
      "content": "tools.office365.send_message.O365SendMessage"
    },
    {
      "type": "p",
      "content": "Send an email in Office 365."
    },
    {
      "type": "p",
      "content": "tools.office365.send_message.SendMessageSchema"
    },
    {
      "type": "p",
      "content": "Input for SendMessageTool."
    },
    {
      "type": "p",
      "content": "tools.openai_dalle_image_generation.tool.OpenAIDALLEImageGenerationTool"
    },
    {
      "type": "p",
      "content": "Tool that generates an image using OpenAI DALLE."
    },
    {
      "type": "p",
      "content": "tools.openapi.utils.api_models.APIOperation"
    },
    {
      "type": "p",
      "content": "A model for a single API operation."
    },
    {
      "type": "p",
      "content": "tools.openapi.utils.api_models.APIProperty"
    },
    {
      "type": "p",
      "content": "A model for a property in the query, path, header, or cookie params."
    },
    {
      "type": "p",
      "content": "tools.openapi.utils.api_models.APIPropertyBase"
    },
    {
      "type": "p",
      "content": "Base model for an API property."
    },
    {
      "type": "p",
      "content": "tools.openapi.utils.api_models.APIPropertyLocation(value)"
    },
    {
      "type": "p",
      "content": "The location of the property."
    },
    {
      "type": "p",
      "content": "tools.openapi.utils.api_models.APIRequestBody"
    },
    {
      "type": "p",
      "content": "A model for a request body."
    },
    {
      "type": "p",
      "content": "tools.openapi.utils.api_models.APIRequestBodyProperty"
    },
    {
      "type": "p",
      "content": "A model for a request body property."
    },
    {
      "type": "p",
      "content": "tools.openweathermap.tool.OpenWeatherMapQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that queries the OpenWeatherMap API."
    },
    {
      "type": "p",
      "content": "tools.passio_nutrition_ai.tool.NutritionAI"
    },
    {
      "type": "p",
      "content": "Tool that queries the Passio Nutrition AI API."
    },
    {
      "type": "p",
      "content": "tools.passio_nutrition_ai.tool.NutritionAIInputs"
    },
    {
      "type": "p",
      "content": "Inputs to the Passio Nutrition AI tool."
    },
    {
      "type": "p",
      "content": "tools.playwright.base.BaseBrowserTool"
    },
    {
      "type": "p",
      "content": "Base class for browser tools."
    },
    {
      "type": "p",
      "content": "tools.playwright.click.ClickTool"
    },
    {
      "type": "p",
      "content": "Tool for clicking on an element with the given CSS selector."
    },
    {
      "type": "p",
      "content": "tools.playwright.click.ClickToolInput"
    },
    {
      "type": "p",
      "content": "Input for ClickTool."
    },
    {
      "type": "p",
      "content": "tools.playwright.current_page.CurrentWebPageTool"
    },
    {
      "type": "p",
      "content": "Tool for getting the URL of the current webpage."
    },
    {
      "type": "p",
      "content": "tools.playwright.current_page.CurrentWebPageToolInput"
    },
    {
      "type": "p",
      "content": "Explicit no-args input for CurrentWebPageTool."
    },
    {
      "type": "p",
      "content": "tools.playwright.extract_hyperlinks.ExtractHyperlinksTool"
    },
    {
      "type": "p",
      "content": "Extract all hyperlinks on the page."
    },
    {
      "type": "p",
      "content": "tools.playwright.extract_hyperlinks.ExtractHyperlinksToolInput"
    },
    {
      "type": "p",
      "content": "Input for ExtractHyperlinksTool."
    },
    {
      "type": "p",
      "content": "tools.playwright.extract_text.ExtractTextTool"
    },
    {
      "type": "p",
      "content": "Tool for extracting all the text on the current webpage."
    },
    {
      "type": "p",
      "content": "tools.playwright.extract_text.ExtractTextToolInput"
    },
    {
      "type": "p",
      "content": "Explicit no-args input for ExtractTextTool."
    },
    {
      "type": "p",
      "content": "tools.playwright.get_elements.GetElementsTool"
    },
    {
      "type": "p",
      "content": "Tool for getting elements in the current web page matching a CSS selector."
    },
    {
      "type": "p",
      "content": "tools.playwright.get_elements.GetElementsToolInput"
    },
    {
      "type": "p",
      "content": "Input for GetElementsTool."
    },
    {
      "type": "p",
      "content": "tools.playwright.navigate.NavigateTool"
    },
    {
      "type": "p",
      "content": "Tool for navigating a browser to a URL."
    },
    {
      "type": "p",
      "content": "tools.playwright.navigate.NavigateToolInput"
    },
    {
      "type": "p",
      "content": "Input for NavigateToolInput."
    },
    {
      "type": "p",
      "content": "tools.playwright.navigate_back.NavigateBackTool"
    },
    {
      "type": "p",
      "content": "Navigate back to the previous page in the browser history."
    },
    {
      "type": "p",
      "content": "tools.playwright.navigate_back.NavigateBackToolInput"
    },
    {
      "type": "p",
      "content": "Explicit no-args input for NavigateBackTool."
    },
    {
      "type": "p",
      "content": "tools.plugin.AIPlugin"
    },
    {
      "type": "p",
      "content": "AI Plugin Definition."
    },
    {
      "type": "p",
      "content": "tools.plugin.AIPluginTool"
    },
    {
      "type": "p",
      "content": "Tool for getting the OpenAPI spec for an AI Plugin."
    },
    {
      "type": "p",
      "content": "tools.plugin.AIPluginToolSchema"
    },
    {
      "type": "p",
      "content": "Schema for AIPluginTool."
    },
    {
      "type": "p",
      "content": "tools.plugin.ApiConfig"
    },
    {
      "type": "p",
      "content": "API Configuration."
    },
    {
      "type": "p",
      "content": "tools.polygon.aggregates.PolygonAggregates"
    },
    {
      "type": "p",
      "content": "Tool that gets aggregate bars (stock prices) over a given date range for a given ticker from Polygon."
    },
    {
      "type": "p",
      "content": "tools.polygon.aggregates.PolygonAggregatesSchema"
    },
    {
      "type": "p",
      "content": "Input for PolygonAggregates."
    },
    {
      "type": "p",
      "content": "tools.polygon.financials.Inputs"
    },
    {
      "type": "p",
      "content": "Inputs for Polygon's Financials API"
    },
    {
      "type": "p",
      "content": "tools.polygon.financials.PolygonFinancials"
    },
    {
      "type": "p",
      "content": "Tool that gets the financials of a ticker from Polygon"
    },
    {
      "type": "p",
      "content": "tools.polygon.last_quote.Inputs"
    },
    {
      "type": "p",
      "content": "Inputs for Polygon's Last Quote API"
    },
    {
      "type": "p",
      "content": "tools.polygon.last_quote.PolygonLastQuote"
    },
    {
      "type": "p",
      "content": "Tool that gets the last quote of a ticker from Polygon"
    },
    {
      "type": "p",
      "content": "tools.polygon.ticker_news.Inputs"
    },
    {
      "type": "p",
      "content": "Inputs for Polygon's Ticker News API"
    },
    {
      "type": "p",
      "content": "tools.polygon.ticker_news.PolygonTickerNews"
    },
    {
      "type": "p",
      "content": "Tool that gets the latest news for a given ticker from Polygon"
    },
    {
      "type": "p",
      "content": "tools.powerbi.tool.InfoPowerBITool"
    },
    {
      "type": "p",
      "content": "Tool for getting metadata about a PowerBI Dataset."
    },
    {
      "type": "p",
      "content": "tools.powerbi.tool.ListPowerBITool"
    },
    {
      "type": "p",
      "content": "Tool for getting tables names."
    },
    {
      "type": "p",
      "content": "tools.powerbi.tool.QueryPowerBITool"
    },
    {
      "type": "p",
      "content": "Tool for querying a Power BI Dataset."
    },
    {
      "type": "p",
      "content": "tools.pubmed.tool.PubmedQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that searches the PubMed API."
    },
    {
      "type": "p",
      "content": "tools.reddit_search.tool.RedditSearchRun"
    },
    {
      "type": "p",
      "content": "Tool that queries for posts on a subreddit."
    },
    {
      "type": "p",
      "content": "tools.reddit_search.tool.RedditSearchSchema"
    },
    {
      "type": "p",
      "content": "Input for Reddit search."
    },
    {
      "type": "p",
      "content": "tools.requests.tool.BaseRequestsTool"
    },
    {
      "type": "p",
      "content": "Base class for requests tools."
    },
    {
      "type": "p",
      "content": "tools.requests.tool.RequestsDeleteTool"
    },
    {
      "type": "p",
      "content": "Tool for making a DELETE request to an API endpoint."
    },
    {
      "type": "p",
      "content": "tools.requests.tool.RequestsGetTool"
    },
    {
      "type": "p",
      "content": "Tool for making a GET request to an API endpoint."
    },
    {
      "type": "p",
      "content": "tools.requests.tool.RequestsPatchTool"
    },
    {
      "type": "p",
      "content": "Tool for making a PATCH request to an API endpoint."
    },
    {
      "type": "p",
      "content": "tools.requests.tool.RequestsPostTool"
    },
    {
      "type": "p",
      "content": "Tool for making a POST request to an API endpoint."
    },
    {
      "type": "p",
      "content": "tools.requests.tool.RequestsPutTool"
    },
    {
      "type": "p",
      "content": "Tool for making a PUT request to an API endpoint."
    },
    {
      "type": "p",
      "content": "tools.riza.command.ExecJavaScript"
    },
    {
      "type": "p",
      "content": "A tool implementation to execute JavaScript via Riza's Code Interpreter API."
    },
    {
      "type": "p",
      "content": "tools.riza.command.ExecJavaScriptInput"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "tools.riza.command.ExecPython"
    },
    {
      "type": "p",
      "content": "Riza Code tool."
    },
    {
      "type": "p",
      "content": "tools.riza.command.ExecPythonInput"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "tools.scenexplain.tool.SceneXplainInput"
    },
    {
      "type": "p",
      "content": "Input for SceneXplain."
    },
    {
      "type": "p",
      "content": "tools.scenexplain.tool.SceneXplainTool"
    },
    {
      "type": "p",
      "content": "Tool that explains images."
    },
    {
      "type": "p",
      "content": "tools.searchapi.tool.SearchAPIResults"
    },
    {
      "type": "p",
      "content": "Tool that queries the SearchApi.io search API and returns JSON."
    },
    {
      "type": "p",
      "content": "tools.searchapi.tool.SearchAPIRun"
    },
    {
      "type": "p",
      "content": "Tool that queries the SearchApi.io search API."
    },
    {
      "type": "p",
      "content": "tools.searx_search.tool.SearxSearchQueryInput"
    },
    {
      "type": "p",
      "content": "Input for the SearxSearch tool."
    },
    {
      "type": "p",
      "content": "tools.searx_search.tool.SearxSearchResults"
    },
    {
      "type": "p",
      "content": "Tool that queries a Searx instance and gets back json."
    },
    {
      "type": "p",
      "content": "tools.searx_search.tool.SearxSearchRun"
    },
    {
      "type": "p",
      "content": "Tool that queries a Searx instance."
    },
    {
      "type": "p",
      "content": "tools.semanticscholar.tool.SemanticScholarQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that searches the semanticscholar API."
    },
    {
      "type": "p",
      "content": "tools.semanticscholar.tool.SemantscholarInput"
    },
    {
      "type": "p",
      "content": "Input for the SemanticScholar tool."
    },
    {
      "type": "p",
      "content": "tools.shell.tool.ShellInput"
    },
    {
      "type": "p",
      "content": "Commands for the Bash Shell tool."
    },
    {
      "type": "p",
      "content": "tools.shell.tool.ShellTool"
    },
    {
      "type": "p",
      "content": "Tool to run shell commands."
    },
    {
      "type": "p",
      "content": "tools.slack.base.SlackBaseTool"
    },
    {
      "type": "p",
      "content": "Base class for Slack tools."
    },
    {
      "type": "p",
      "content": "tools.slack.get_channel.SlackGetChannel"
    },
    {
      "type": "p",
      "content": "Tool that gets Slack channel information."
    },
    {
      "type": "p",
      "content": "tools.slack.get_message.SlackGetMessage"
    },
    {
      "type": "p",
      "content": "Tool that gets Slack messages."
    },
    {
      "type": "p",
      "content": "tools.slack.get_message.SlackGetMessageSchema"
    },
    {
      "type": "p",
      "content": "Input schema for SlackGetMessages."
    },
    {
      "type": "p",
      "content": "tools.slack.schedule_message.ScheduleMessageSchema"
    },
    {
      "type": "p",
      "content": "Input for ScheduleMessageTool."
    },
    {
      "type": "p",
      "content": "tools.slack.schedule_message.SlackScheduleMessage"
    },
    {
      "type": "p",
      "content": "Tool for scheduling a message in Slack."
    },
    {
      "type": "p",
      "content": "tools.slack.send_message.SendMessageSchema"
    },
    {
      "type": "p",
      "content": "Input for SendMessageTool."
    },
    {
      "type": "p",
      "content": "tools.slack.send_message.SlackSendMessage"
    },
    {
      "type": "p",
      "content": "Tool for sending a message in Slack."
    },
    {
      "type": "p",
      "content": "tools.sleep.tool.SleepInput"
    },
    {
      "type": "p",
      "content": "Input for CopyFileTool."
    },
    {
      "type": "p",
      "content": "tools.sleep.tool.SleepTool"
    },
    {
      "type": "p",
      "content": "Tool that adds the capability to sleep."
    },
    {
      "type": "p",
      "content": "tools.spark_sql.tool.BaseSparkSQLTool"
    },
    {
      "type": "p",
      "content": "Base tool for interacting with Spark SQL."
    },
    {
      "type": "p",
      "content": "tools.spark_sql.tool.InfoSparkSQLTool"
    },
    {
      "type": "p",
      "content": "Tool for getting metadata about a Spark SQL."
    },
    {
      "type": "p",
      "content": "tools.spark_sql.tool.ListSparkSQLTool"
    },
    {
      "type": "p",
      "content": "Tool for getting tables names."
    },
    {
      "type": "p",
      "content": "tools.spark_sql.tool.QueryCheckerTool"
    },
    {
      "type": "p",
      "content": "Use an LLM to check if a query is correct."
    },
    {
      "type": "p",
      "content": "tools.spark_sql.tool.QuerySparkSQLTool"
    },
    {
      "type": "p",
      "content": "Tool for querying a Spark SQL."
    },
    {
      "type": "p",
      "content": "tools.sql_database.tool.BaseSQLDatabaseTool"
    },
    {
      "type": "p",
      "content": "Base tool for interacting with a SQL database."
    },
    {
      "type": "p",
      "content": "tools.sql_database.tool.InfoSQLDatabaseTool"
    },
    {
      "type": "p",
      "content": "Tool for getting metadata about a SQL database."
    },
    {
      "type": "p",
      "content": "tools.sql_database.tool.ListSQLDatabaseTool"
    },
    {
      "type": "p",
      "content": "Tool for getting tables names."
    },
    {
      "type": "p",
      "content": "tools.sql_database.tool.QuerySQLCheckerTool"
    },
    {
      "type": "p",
      "content": "Use an LLM to check if a query is correct."
    },
    {
      "type": "p",
      "content": "tools.sql_database.tool.QuerySQLDatabaseTool"
    },
    {
      "type": "p",
      "content": "Tool for querying a SQL database."
    },
    {
      "type": "p",
      "content": "tools.stackexchange.tool.StackExchangeTool"
    },
    {
      "type": "p",
      "content": "Tool that uses StackExchange"
    },
    {
      "type": "p",
      "content": "tools.steam.tool.SteamWebAPIQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that searches the Steam Web API."
    },
    {
      "type": "p",
      "content": "tools.steamship_image_generation.tool.ModelName(value)"
    },
    {
      "type": "p",
      "content": "Supported Image Models for generation."
    },
    {
      "type": "p",
      "content": "tools.steamship_image_generation.tool.SteamshipImageGenerationTool"
    },
    {
      "type": "p",
      "content": "Tool used to generate images from a text-prompt."
    },
    {
      "type": "p",
      "content": "tools.tavily_search.tool.TavilyInput"
    },
    {
      "type": "p",
      "content": "Input for the Tavily tool."
    },
    {
      "type": "p",
      "content": "tools.vectorstore.tool.BaseVectorStoreTool"
    },
    {
      "type": "p",
      "content": "Base class for tools that use a VectorStore."
    },
    {
      "type": "p",
      "content": "tools.vectorstore.tool.VectorStoreQATool"
    },
    {
      "type": "p",
      "content": "Tool for the VectorDBQA chain."
    },
    {
      "type": "p",
      "content": "tools.vectorstore.tool.VectorStoreQAWithSourcesTool"
    },
    {
      "type": "p",
      "content": "Tool for the VectorDBQAWithSources chain."
    },
    {
      "type": "p",
      "content": "tools.wikidata.tool.WikidataQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that searches the Wikidata API."
    },
    {
      "type": "p",
      "content": "tools.wikipedia.tool.WikipediaQueryInput"
    },
    {
      "type": "p",
      "content": "Input for the WikipediaQuery tool."
    },
    {
      "type": "p",
      "content": "tools.wikipedia.tool.WikipediaQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that searches the Wikipedia API."
    },
    {
      "type": "p",
      "content": "tools.wolfram_alpha.tool.WolframAlphaQueryRun"
    },
    {
      "type": "p",
      "content": "Tool that queries using the Wolfram Alpha SDK."
    },
    {
      "type": "p",
      "content": "tools.yahoo_finance_news.YahooFinanceNewsInput"
    },
    {
      "type": "p",
      "content": "Input for the YahooFinanceNews tool."
    },
    {
      "type": "p",
      "content": "tools.yahoo_finance_news.YahooFinanceNewsTool"
    },
    {
      "type": "p",
      "content": "Tool that searches financial news on Yahoo Finance."
    },
    {
      "type": "p",
      "content": "tools.you.tool.YouInput"
    },
    {
      "type": "p",
      "content": "Input schema for the you.com tool."
    },
    {
      "type": "p",
      "content": "tools.you.tool.YouSearchTool"
    },
    {
      "type": "p",
      "content": "Tool that searches the you.com API."
    },
    {
      "type": "p",
      "content": "tools.youtube.search.YouTubeSearchTool"
    },
    {
      "type": "p",
      "content": "Tool that queries YouTube."
    },
    {
      "type": "p",
      "content": "tools.zapier.tool.ZapierNLAListActions"
    },
    {
      "type": "p",
      "content": "Returns a list of all exposed (enabled) actions associated with current user (associated with the set api_key)."
    },
    {
      "type": "p",
      "content": "tools.zapier.tool.ZapierNLARunAction"
    },
    {
      "type": "p",
      "content": "Executes an action that is identified by action_id, must be exposed"
    },
    {
      "type": "p",
      "content": "tools.zenguard.tool.Detector(value)"
    },
    {
      "type": "p",
      "content": "tools.zenguard.tool.DetectorAPI(value)"
    },
    {
      "type": "p",
      "content": "tools.zenguard.tool.ZenGuardInput"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "tools.zenguard.tool.ZenGuardTool"
    },
    {
      "type": "p",
      "content": "Initialize the tool."
    },
    {
      "type": "p",
      "content": "tools.ainetwork.utils.authenticate([network])"
    },
    {
      "type": "p",
      "content": "Authenticate using the AIN Blockchain"
    },
    {
      "type": "p",
      "content": "tools.amadeus.utils.authenticate()"
    },
    {
      "type": "p",
      "content": "Authenticate using the Amadeus API"
    },
    {
      "type": "p",
      "content": "tools.azure_ai_services.utils.detect_file_src_type(...)"
    },
    {
      "type": "p",
      "content": "Detect if the file is local or remote."
    },
    {
      "type": "p",
      "content": "tools.azure_ai_services.utils.download_audio_from_url(...)"
    },
    {
      "type": "p",
      "content": "Download audio from url to local."
    },
    {
      "type": "p",
      "content": "tools.azure_cognitive_services.utils.detect_file_src_type(...)"
    },
    {
      "type": "p",
      "content": "Detect if the file is local or remote."
    },
    {
      "type": "p",
      "content": "tools.azure_cognitive_services.utils.download_audio_from_url(...)"
    },
    {
      "type": "p",
      "content": "Download audio from url to local."
    },
    {
      "type": "p",
      "content": "tools.bearly.tool.file_to_base64(path)"
    },
    {
      "type": "p",
      "content": "Convert a file to base64."
    },
    {
      "type": "p",
      "content": "tools.bearly.tool.head_file(path, n)"
    },
    {
      "type": "p",
      "content": "Get the first n lines of a file."
    },
    {
      "type": "p",
      "content": "tools.bearly.tool.strip_markdown_code(md_string)"
    },
    {
      "type": "p",
      "content": "Strip markdown code from a string."
    },
    {
      "type": "p",
      "content": "tools.ddg_search.tool.DuckDuckGoSearchTool(...)"
    },
    {
      "type": "p",
      "content": "Deprecated."
    },
    {
      "type": "p",
      "content": "tools.e2b_data_analysis.tool.add_last_line_print(code)"
    },
    {
      "type": "p",
      "content": "Add print statement to the last line if it's missing."
    },
    {
      "type": "p",
      "content": "tools.e2b_data_analysis.unparse.interleave(...)"
    },
    {
      "type": "p",
      "content": "Call f on each item in seq, calling inter() in between."
    },
    {
      "type": "p",
      "content": "tools.e2b_data_analysis.unparse.roundtrip(...)"
    },
    {
      "type": "p",
      "content": "Parse a file and pretty-print it to output."
    },
    {
      "type": "p",
      "content": "tools.file_management.utils.get_validated_relative_path(...)"
    },
    {
      "type": "p",
      "content": "Resolve a relative path, raising an error if not within the root directory."
    },
    {
      "type": "p",
      "content": "tools.file_management.utils.is_relative_to(...)"
    },
    {
      "type": "p",
      "content": "Check if path is relative to root."
    },
    {
      "type": "p",
      "content": "tools.gmail.utils.build_resource_service([...])"
    },
    {
      "type": "p",
      "content": "Build a Gmail service."
    },
    {
      "type": "p",
      "content": "tools.gmail.utils.clean_email_body(body)"
    },
    {
      "type": "p",
      "content": "Clean email body."
    },
    {
      "type": "p",
      "content": "tools.gmail.utils.get_gmail_credentials([...])"
    },
    {
      "type": "p",
      "content": "Get credentials."
    },
    {
      "type": "p",
      "content": "tools.gmail.utils.import_google()"
    },
    {
      "type": "p",
      "content": "Import google libraries."
    },
    {
      "type": "p",
      "content": "tools.gmail.utils.import_googleapiclient_resource_builder()"
    },
    {
      "type": "p",
      "content": "Import googleapiclient.discovery.build function."
    },
    {
      "type": "p",
      "content": "tools.gmail.utils.import_installed_app_flow()"
    },
    {
      "type": "p",
      "content": "Import InstalledAppFlow class."
    },
    {
      "type": "p",
      "content": "tools.interaction.tool.StdInInquireTool(...)"
    },
    {
      "type": "p",
      "content": "Tool for asking the user for input."
    },
    {
      "type": "p",
      "content": "tools.office365.utils.authenticate()"
    },
    {
      "type": "p",
      "content": "Authenticate using the Microsoft Graph API"
    },
    {
      "type": "p",
      "content": "tools.office365.utils.clean_body(body)"
    },
    {
      "type": "p",
      "content": "Clean body of a message or event."
    },
    {
      "type": "p",
      "content": "tools.playwright.base.lazy_import_playwright_browsers()"
    },
    {
      "type": "p",
      "content": "Lazy import playwright browsers."
    },
    {
      "type": "p",
      "content": "tools.playwright.utils.aget_current_page(browser)"
    },
    {
      "type": "p",
      "content": "Asynchronously get the current page of the browser."
    },
    {
      "type": "p",
      "content": "tools.playwright.utils.create_async_playwright_browser([...])"
    },
    {
      "type": "p",
      "content": "Create an async playwright browser."
    },
    {
      "type": "p",
      "content": "tools.playwright.utils.create_sync_playwright_browser([...])"
    },
    {
      "type": "p",
      "content": "Create a playwright browser."
    },
    {
      "type": "p",
      "content": "tools.playwright.utils.get_current_page(browser)"
    },
    {
      "type": "p",
      "content": "Get the current page of the browser."
    },
    {
      "type": "p",
      "content": "tools.playwright.utils.run_async(coro)"
    },
    {
      "type": "p",
      "content": "Run an async coroutine."
    },
    {
      "type": "p",
      "content": "tools.plugin.marshal_spec(txt)"
    },
    {
      "type": "p",
      "content": "Convert the yaml or json serialized spec to a dict."
    },
    {
      "type": "p",
      "content": "tools.slack.utils.login()"
    },
    {
      "type": "p",
      "content": "Authenticate using the Slack API."
    },
    {
      "type": "p",
      "content": "tools.steamship_image_generation.utils.make_image_public(...)"
    },
    {
      "type": "p",
      "content": "Upload a block to a signed URL and return the public URL."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "tools.databricks.tool.UCFunctionToolkit"
    },
    {
      "type": "p",
      "content": "tools.google_cloud.texttospeech.GoogleCloudTextToSpeechTool"
    },
    {
      "type": "p",
      "content": "tools.google_places.tool.GooglePlacesTool"
    },
    {
      "type": "p",
      "content": "tools.google_search.tool.GoogleSearchResults"
    },
    {
      "type": "p",
      "content": "tools.google_search.tool.GoogleSearchRun"
    },
    {
      "type": "p",
      "content": "tools.metaphor_search.tool.MetaphorSearchResults"
    },
    {
      "type": "p",
      "content": "tools.tavily_search.tool.TavilyAnswer"
    },
    {
      "type": "p",
      "content": "tools.tavily_search.tool.TavilySearchResults"
    },
    {
      "type": "p",
      "content": "utilities.alpha_vantage.AlphaVantageAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for AlphaVantage API for Currency Exchange Rate."
    },
    {
      "type": "p",
      "content": "utilities.arcee.ArceeDocument"
    },
    {
      "type": "p",
      "content": "Arcee document."
    },
    {
      "type": "p",
      "content": "utilities.arcee.ArceeDocumentAdapter()"
    },
    {
      "type": "p",
      "content": "Adapter for Arcee documents"
    },
    {
      "type": "p",
      "content": "utilities.arcee.ArceeDocumentSource"
    },
    {
      "type": "p",
      "content": "Source of an Arcee document."
    },
    {
      "type": "p",
      "content": "utilities.arcee.ArceeRoute(value)"
    },
    {
      "type": "p",
      "content": "Routes available for the Arcee API as enumerator."
    },
    {
      "type": "p",
      "content": "utilities.arcee.ArceeWrapper(arcee_api_key, ...)"
    },
    {
      "type": "p",
      "content": "Wrapper for Arcee API."
    },
    {
      "type": "p",
      "content": "utilities.arcee.DALMFilter"
    },
    {
      "type": "p",
      "content": "Filters available for a DALM retrieval and generation."
    },
    {
      "type": "p",
      "content": "utilities.arcee.DALMFilterType(value)"
    },
    {
      "type": "p",
      "content": "Filter types available for a DALM retrieval as enumerator."
    },
    {
      "type": "p",
      "content": "utilities.arxiv.ArxivAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around ArxivAPI."
    },
    {
      "type": "p",
      "content": "utilities.asknews.AskNewsAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for AskNews API."
    },
    {
      "type": "p",
      "content": "utilities.astradb.SetupMode(value)"
    },
    {
      "type": "p",
      "content": "Setup mode for AstraDBEnvironment as enumerator."
    },
    {
      "type": "p",
      "content": "utilities.awslambda.LambdaWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for AWS Lambda SDK."
    },
    {
      "type": "p",
      "content": "utilities.bibtex.BibtexparserWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around bibtexparser."
    },
    {
      "type": "p",
      "content": "utilities.bing_search.BingSearchAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Bing Web Search API."
    },
    {
      "type": "p",
      "content": "utilities.brave_search.BraveSearchWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around the Brave search engine."
    },
    {
      "type": "p",
      "content": "utilities.cassandra.SetupMode(value)"
    },
    {
      "type": "p",
      "content": "utilities.cassandra_database.CassandraDatabase([...])"
    },
    {
      "type": "p",
      "content": "Apache Cassandra® database wrapper."
    },
    {
      "type": "p",
      "content": "utilities.cassandra_database.DatabaseError(message)"
    },
    {
      "type": "p",
      "content": "Exception raised for errors in the database schema."
    },
    {
      "type": "p",
      "content": "utilities.cassandra_database.Table"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "utilities.clickup.CUList(folder_id, name[, ...])"
    },
    {
      "type": "p",
      "content": "Component class for a list."
    },
    {
      "type": "p",
      "content": "utilities.clickup.ClickupAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Clickup API."
    },
    {
      "type": "p",
      "content": "utilities.clickup.Component()"
    },
    {
      "type": "p",
      "content": "Base class for all components."
    },
    {
      "type": "p",
      "content": "utilities.clickup.Member(id, username, ...)"
    },
    {
      "type": "p",
      "content": "Component class for a member."
    },
    {
      "type": "p",
      "content": "utilities.clickup.Space(id, name, private, ...)"
    },
    {
      "type": "p",
      "content": "Component class for a space."
    },
    {
      "type": "p",
      "content": "utilities.clickup.Task(id, name, ...)"
    },
    {
      "type": "p",
      "content": "Class for a task."
    },
    {
      "type": "p",
      "content": "utilities.clickup.Team(id, name, members)"
    },
    {
      "type": "p",
      "content": "Component class for a team."
    },
    {
      "type": "p",
      "content": "utilities.dalle_image_generator.DallEAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for OpenAI's DALL-E Image Generator."
    },
    {
      "type": "p",
      "content": "utilities.dataforseo_api_search.DataForSeoAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around the DataForSeo API."
    },
    {
      "type": "p",
      "content": "utilities.dataherald.DataheraldAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Dataherald."
    },
    {
      "type": "p",
      "content": "utilities.dria_index.DriaAPIWrapper(api_key)"
    },
    {
      "type": "p",
      "content": "Wrapper around Dria API."
    },
    {
      "type": "p",
      "content": "utilities.duckduckgo_search.DuckDuckGoSearchAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for DuckDuckGo Search API."
    },
    {
      "type": "p",
      "content": "utilities.financial_datasets.FinancialDatasetsAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for financial datasets API."
    },
    {
      "type": "p",
      "content": "utilities.github.GitHubAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for GitHub API."
    },
    {
      "type": "p",
      "content": "utilities.gitlab.GitLabAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for GitLab API."
    },
    {
      "type": "p",
      "content": "utilities.golden_query.GoldenQueryAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Golden."
    },
    {
      "type": "p",
      "content": "utilities.google_books.GoogleBooksAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around Google Books API."
    },
    {
      "type": "p",
      "content": "utilities.google_finance.GoogleFinanceAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for SerpApi's Google Finance API"
    },
    {
      "type": "p",
      "content": "utilities.google_jobs.GoogleJobsAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for SerpApi's Google Scholar API"
    },
    {
      "type": "p",
      "content": "utilities.google_lens.GoogleLensAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for SerpApi's Google Lens API"
    },
    {
      "type": "p",
      "content": "utilities.google_scholar.GoogleScholarAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Google Scholar API"
    },
    {
      "type": "p",
      "content": "utilities.google_serper.GoogleSerperAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around the Serper.dev Google Search API."
    },
    {
      "type": "p",
      "content": "utilities.google_trends.GoogleTrendsAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for SerpApi's Google Scholar API"
    },
    {
      "type": "p",
      "content": "utilities.graphql.GraphQLAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around GraphQL API."
    },
    {
      "type": "p",
      "content": "utilities.infobip.InfobipAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Infobip API for messaging."
    },
    {
      "type": "p",
      "content": "utilities.jina_search.JinaSearchAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around the Jina search engine."
    },
    {
      "type": "p",
      "content": "utilities.jira.JiraAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Jira API. You can connect to Jira with either an API token or OAuth2. - with API token, you need to provide the JIRA_USERNAME and JIRA_API_TOKEN     environment variables or arguments. ex: JIRA_USERNAME=your_username JIRA_API_TOKEN=your_api_token - with OAuth2, you need to provide the JIRA_OAUTH2 environment variable or     argument as a dict having as fields \"client_id\" and \"token\" which is     a dict containing at least \"access_token\" and \"token_type\". ex: JIRA_OAUTH2='{\"client_id\": \"your_client_id\", \"token\":     {\"access_token\": \"your_access_token\",\"token_type\": \"bearer\"}}'."
    },
    {
      "type": "p",
      "content": "utilities.jira.JiraOauth2"
    },
    {
      "type": "p",
      "content": "Jira OAuth2."
    },
    {
      "type": "p",
      "content": "utilities.jira.JiraOauth2Token"
    },
    {
      "type": "p",
      "content": "Jira OAuth2 token."
    },
    {
      "type": "p",
      "content": "utilities.max_compute.MaxComputeAPIWrapper(client)"
    },
    {
      "type": "p",
      "content": "Interface for querying Alibaba Cloud MaxCompute tables."
    },
    {
      "type": "p",
      "content": "utilities.merriam_webster.MerriamWebsterAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Merriam-Webster."
    },
    {
      "type": "p",
      "content": "utilities.metaphor_search.MetaphorSearchAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Metaphor Search API."
    },
    {
      "type": "p",
      "content": "utilities.mojeek_search.MojeekSearchAPIWrapper"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "utilities.nasa.NasaAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for NASA API."
    },
    {
      "type": "p",
      "content": "utilities.nvidia_riva.ASRInputType"
    },
    {
      "type": "p",
      "content": "alias ofAudioStream"
    },
    {
      "type": "p",
      "content": "utilities.nvidia_riva.AudioStream([maxsize])"
    },
    {
      "type": "p",
      "content": "A message containing streaming audio."
    },
    {
      "type": "p",
      "content": "utilities.nvidia_riva.NVIDIARivaASR"
    },
    {
      "type": "p",
      "content": "alias ofRivaASR"
    },
    {
      "type": "p",
      "content": "utilities.nvidia_riva.NVIDIARivaStream"
    },
    {
      "type": "p",
      "content": "alias ofAudioStream"
    },
    {
      "type": "p",
      "content": "utilities.nvidia_riva.NVIDIARivaTTS"
    },
    {
      "type": "p",
      "content": "alias ofRivaTTS"
    },
    {
      "type": "p",
      "content": "utilities.nvidia_riva.RivaASR"
    },
    {
      "type": "p",
      "content": "A runnable that performs Automatic Speech Recognition (ASR) using NVIDIA Riva."
    },
    {
      "type": "p",
      "content": "utilities.nvidia_riva.RivaAudioEncoding(value)"
    },
    {
      "type": "p",
      "content": "An enum of the possible choices for Riva audio encoding."
    },
    {
      "type": "p",
      "content": "utilities.nvidia_riva.RivaAuthMixin"
    },
    {
      "type": "p",
      "content": "Configuration for the authentication to a Riva service connection."
    },
    {
      "type": "p",
      "content": "utilities.nvidia_riva.RivaCommonConfigMixin"
    },
    {
      "type": "p",
      "content": "A collection of common Riva settings."
    },
    {
      "type": "p",
      "content": "utilities.nvidia_riva.RivaTTS"
    },
    {
      "type": "p",
      "content": "A runnable that performs Text-to-Speech (TTS) with NVIDIA Riva."
    },
    {
      "type": "p",
      "content": "utilities.nvidia_riva.SentinelT()"
    },
    {
      "type": "p",
      "content": "An empty Sentinel type."
    },
    {
      "type": "p",
      "content": "utilities.openapi.HTTPVerb(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of the HTTP verbs."
    },
    {
      "type": "p",
      "content": "utilities.openapi.OpenAPISpec()"
    },
    {
      "type": "p",
      "content": "OpenAPI Model that removes mis-formatted parts of the spec."
    },
    {
      "type": "p",
      "content": "utilities.openweathermap.OpenWeatherMapAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for OpenWeatherMap API using PyOWM."
    },
    {
      "type": "p",
      "content": "utilities.oracleai.OracleSummary(conn, params)"
    },
    {
      "type": "p",
      "content": "Get Summary :param conn: Oracle Connection, :param params: Summary parameters, :param proxy: Proxy"
    },
    {
      "type": "p",
      "content": "utilities.outline.OutlineAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around OutlineAPI."
    },
    {
      "type": "p",
      "content": "utilities.passio_nutrition_ai.ManagedPassioLifeAuth(...)"
    },
    {
      "type": "p",
      "content": "Manage the token for the NutritionAI API."
    },
    {
      "type": "p",
      "content": "utilities.passio_nutrition_ai.NoDiskStorage()"
    },
    {
      "type": "p",
      "content": "Mixin to prevent storing on disk."
    },
    {
      "type": "p",
      "content": "utilities.passio_nutrition_ai.NutritionAIAPI"
    },
    {
      "type": "p",
      "content": "Wrapper for the Passio Nutrition AI API."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.App"
    },
    {
      "type": "p",
      "content": "Pebblo AI application."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.Doc"
    },
    {
      "type": "p",
      "content": "Pebblo document."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.Framework"
    },
    {
      "type": "p",
      "content": "Pebblo Framework instance."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.IndexedDocument"
    },
    {
      "type": "p",
      "content": "Pebblo Indexed Document."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.PebbloLoaderAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Pebblo Loader API."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.Routes(value)"
    },
    {
      "type": "p",
      "content": "Routes available for the Pebblo API as enumerator."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.Runtime"
    },
    {
      "type": "p",
      "content": "Pebblo Runtime."
    },
    {
      "type": "p",
      "content": "utilities.polygon.PolygonAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Polygon API."
    },
    {
      "type": "p",
      "content": "utilities.portkey.Portkey()"
    },
    {
      "type": "p",
      "content": "Portkey configuration."
    },
    {
      "type": "p",
      "content": "utilities.powerbi.PowerBIDataset"
    },
    {
      "type": "p",
      "content": "Create PowerBI engine from dataset ID and credential or token."
    },
    {
      "type": "p",
      "content": "utilities.pubmed.PubMedAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around PubMed API."
    },
    {
      "type": "p",
      "content": "utilities.reddit_search.RedditSearchAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Reddit API"
    },
    {
      "type": "p",
      "content": "utilities.redis.TokenEscaper([escape_chars_re])"
    },
    {
      "type": "p",
      "content": "Escape punctuation within an input string."
    },
    {
      "type": "p",
      "content": "utilities.rememberizer.RememberizerAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Rememberizer APIs."
    },
    {
      "type": "p",
      "content": "utilities.requests.GenericRequestsWrapper"
    },
    {
      "type": "p",
      "content": "Lightweight wrapper around requests library."
    },
    {
      "type": "p",
      "content": "utilities.requests.JsonRequestsWrapper"
    },
    {
      "type": "p",
      "content": "Lightweight wrapper around requests library, with async support."
    },
    {
      "type": "p",
      "content": "utilities.requests.Requests"
    },
    {
      "type": "p",
      "content": "Wrapper around requests to handle auth and async."
    },
    {
      "type": "p",
      "content": "utilities.requests.RequestsWrapper"
    },
    {
      "type": "p",
      "content": "alias ofTextRequestsWrapper"
    },
    {
      "type": "p",
      "content": "utilities.requests.TextRequestsWrapper"
    },
    {
      "type": "p",
      "content": "Lightweight wrapper around requests library, with async support."
    },
    {
      "type": "p",
      "content": "utilities.scenexplain.SceneXplainAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for SceneXplain API."
    },
    {
      "type": "p",
      "content": "utilities.searchapi.SearchApiAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around SearchApi API."
    },
    {
      "type": "p",
      "content": "utilities.searx_search.SearxResults(data)"
    },
    {
      "type": "p",
      "content": "Dict like wrapper around search api results."
    },
    {
      "type": "p",
      "content": "utilities.searx_search.SearxSearchWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Searx API."
    },
    {
      "type": "p",
      "content": "utilities.semanticscholar.SemanticScholarAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around semanticscholar.org API."
    },
    {
      "type": "p",
      "content": "utilities.serpapi.HiddenPrints()"
    },
    {
      "type": "p",
      "content": "Context manager to hide prints."
    },
    {
      "type": "p",
      "content": "utilities.serpapi.SerpAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around SerpAPI."
    },
    {
      "type": "p",
      "content": "utilities.spark_sql.SparkSQL([...])"
    },
    {
      "type": "p",
      "content": "SparkSQL is a utility class for interacting with Spark SQL."
    },
    {
      "type": "p",
      "content": "utilities.sql_database.SQLDatabase(engine[, ...])"
    },
    {
      "type": "p",
      "content": "SQLAlchemy wrapper around a database."
    },
    {
      "type": "p",
      "content": "utilities.stackexchange.StackExchangeAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Stack Exchange API."
    },
    {
      "type": "p",
      "content": "utilities.steam.SteamWebAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Steam API."
    },
    {
      "type": "p",
      "content": "utilities.tavily_search.TavilySearchAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Tavily Search API."
    },
    {
      "type": "p",
      "content": "utilities.tensorflow_datasets.TensorflowDatasets"
    },
    {
      "type": "p",
      "content": "Access to the TensorFlow Datasets."
    },
    {
      "type": "p",
      "content": "utilities.twilio.TwilioAPIWrapper"
    },
    {
      "type": "p",
      "content": "Messaging Client using Twilio."
    },
    {
      "type": "p",
      "content": "utilities.wikidata.WikidataAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around the Wikidata API."
    },
    {
      "type": "p",
      "content": "utilities.wikipedia.WikipediaAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper around WikipediaAPI."
    },
    {
      "type": "p",
      "content": "utilities.wolfram_alpha.WolframAlphaAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Wolfram Alpha."
    },
    {
      "type": "p",
      "content": "utilities.you.YouAPIOutput"
    },
    {
      "type": "p",
      "content": "Output from you.com API."
    },
    {
      "type": "p",
      "content": "utilities.you.YouDocument"
    },
    {
      "type": "p",
      "content": "Output of parsing one snippet."
    },
    {
      "type": "p",
      "content": "utilities.you.YouHit"
    },
    {
      "type": "p",
      "content": "A single hit from you.com, which may contain multiple snippets"
    },
    {
      "type": "p",
      "content": "utilities.you.YouHitMetadata"
    },
    {
      "type": "p",
      "content": "Metadata on a single hit from you.com"
    },
    {
      "type": "p",
      "content": "utilities.you.YouSearchAPIWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for you.com Search and News API."
    },
    {
      "type": "p",
      "content": "utilities.zapier.ZapierNLAWrapper"
    },
    {
      "type": "p",
      "content": "Wrapper for Zapier NLA."
    },
    {
      "type": "p",
      "content": "utilities.anthropic.get_num_tokens_anthropic(text)"
    },
    {
      "type": "p",
      "content": "Get the number of tokens in a string of text."
    },
    {
      "type": "p",
      "content": "utilities.anthropic.get_token_ids_anthropic(text)"
    },
    {
      "type": "p",
      "content": "Get the token ids for a string of text."
    },
    {
      "type": "p",
      "content": "utilities.cassandra.aexecute_cql(session, ...)"
    },
    {
      "type": "p",
      "content": "Execute a CQL query asynchronously."
    },
    {
      "type": "p",
      "content": "utilities.cassandra.wrapped_response_future(...)"
    },
    {
      "type": "p",
      "content": "Wrap a Cassandra response future in an asyncio future."
    },
    {
      "type": "p",
      "content": "utilities.clickup.extract_dict_elements_from_component_fields(...)"
    },
    {
      "type": "p",
      "content": "Extract elements from a dictionary."
    },
    {
      "type": "p",
      "content": "utilities.clickup.fetch_data(url, access_token)"
    },
    {
      "type": "p",
      "content": "Fetch data from a URL."
    },
    {
      "type": "p",
      "content": "utilities.clickup.fetch_first_id(data, key)"
    },
    {
      "type": "p",
      "content": "Fetch the first id from a dictionary."
    },
    {
      "type": "p",
      "content": "utilities.clickup.fetch_folder_id(space_id, ...)"
    },
    {
      "type": "p",
      "content": "Fetch the folder id."
    },
    {
      "type": "p",
      "content": "utilities.clickup.fetch_list_id(space_id, ...)"
    },
    {
      "type": "p",
      "content": "Fetch the list id."
    },
    {
      "type": "p",
      "content": "utilities.clickup.fetch_space_id(team_id, ...)"
    },
    {
      "type": "p",
      "content": "Fetch the space id."
    },
    {
      "type": "p",
      "content": "utilities.clickup.fetch_team_id(access_token)"
    },
    {
      "type": "p",
      "content": "Fetch the team id."
    },
    {
      "type": "p",
      "content": "utilities.clickup.load_query(query[, ...])"
    },
    {
      "type": "p",
      "content": "Parse a JSON string and return the parsed object."
    },
    {
      "type": "p",
      "content": "utilities.clickup.parse_dict_through_component(...)"
    },
    {
      "type": "p",
      "content": "Parse a dictionary by creating a component and then turning it back into a dictionary."
    },
    {
      "type": "p",
      "content": "utilities.opaqueprompts.desanitize(...)"
    },
    {
      "type": "p",
      "content": "Restore the original sensitive data from the sanitized text."
    },
    {
      "type": "p",
      "content": "utilities.opaqueprompts.sanitize(input)"
    },
    {
      "type": "p",
      "content": "Sanitize input string or dict of strings by replacing sensitive data with placeholders."
    },
    {
      "type": "p",
      "content": "utilities.passio_nutrition_ai.is_http_retryable(rsp)"
    },
    {
      "type": "p",
      "content": "Check if a HTTP response is retryable."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.calculate_content_size(data)"
    },
    {
      "type": "p",
      "content": "Calculate the content size in bytes: - Encode the string to bytes using a specific encoding (e.g., UTF-8) - Get the length of the encoded bytes."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.generate_size_based_batches(docs)"
    },
    {
      "type": "p",
      "content": "Generate batches of documents based on page_content size."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.get_file_owner_from_path(...)"
    },
    {
      "type": "p",
      "content": "Fetch owner of local file path."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.get_full_path(path)"
    },
    {
      "type": "p",
      "content": "Return an absolute local path for a local file/directory, for a network related path, return as is."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.get_ip()"
    },
    {
      "type": "p",
      "content": "Fetch local runtime ip address."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.get_loader_full_path(loader)"
    },
    {
      "type": "p",
      "content": "Return an absolute source path of source of loader based on the keys present in Document."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.get_loader_type(loader)"
    },
    {
      "type": "p",
      "content": "Return loader type among, file, dir or in-memory."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.get_runtime()"
    },
    {
      "type": "p",
      "content": "Fetch the current Framework and Runtime details."
    },
    {
      "type": "p",
      "content": "utilities.pebblo.get_source_size(source_path)"
    },
    {
      "type": "p",
      "content": "Fetch size of source path."
    },
    {
      "type": "p",
      "content": "utilities.powerbi.fix_table_name(table)"
    },
    {
      "type": "p",
      "content": "Add single quotes around table names that contain spaces."
    },
    {
      "type": "p",
      "content": "utilities.powerbi.json_to_md(json_contents)"
    },
    {
      "type": "p",
      "content": "Convert a JSON object to a markdown table."
    },
    {
      "type": "p",
      "content": "utilities.redis.check_redis_module_exist(...)"
    },
    {
      "type": "p",
      "content": "Check if the correct Redis modules are installed."
    },
    {
      "type": "p",
      "content": "utilities.redis.get_client(redis_url, **kwargs)"
    },
    {
      "type": "p",
      "content": "Get a redis client from the connection url given."
    },
    {
      "type": "p",
      "content": "utilities.sql_database.sanitize_schema(schema)"
    },
    {
      "type": "p",
      "content": "Sanitize a schema name to only contain letters, digits, and underscores."
    },
    {
      "type": "p",
      "content": "utilities.sql_database.truncate_word(...[, ...])"
    },
    {
      "type": "p",
      "content": "Truncate a string to a certain number of words, based on the max string length."
    },
    {
      "type": "p",
      "content": "utilities.vertexai.create_retry_decorator(llm, *)"
    },
    {
      "type": "p",
      "content": "Create a retry decorator for Vertex / Palm LLMs."
    },
    {
      "type": "p",
      "content": "utilities.vertexai.get_client_info([module])"
    },
    {
      "type": "p",
      "content": "Return a custom user agent header."
    },
    {
      "type": "p",
      "content": "utilities.vertexai.init_vertexai([project, ...])"
    },
    {
      "type": "p",
      "content": "Init Vertex AI."
    },
    {
      "type": "p",
      "content": "utilities.vertexai.load_image_from_gcs(path)"
    },
    {
      "type": "p",
      "content": "Load an image from Google Cloud Storage."
    },
    {
      "type": "p",
      "content": "utilities.vertexai.raise_vertex_import_error([...])"
    },
    {
      "type": "p",
      "content": "Raise ImportError related to Vertex SDK being not available."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "utilities.apify.ApifyWrapper"
    },
    {
      "type": "p",
      "content": "utilities.google_places_api.GooglePlacesAPIWrapper"
    },
    {
      "type": "p",
      "content": "utilities.google_search.GoogleSearchAPIWrapper"
    },
    {
      "type": "p",
      "content": "utils.ernie_functions.FunctionDescription"
    },
    {
      "type": "p",
      "content": "Representation of a callable function to the Ernie API."
    },
    {
      "type": "p",
      "content": "utils.ernie_functions.ToolDescription"
    },
    {
      "type": "p",
      "content": "Representation of a callable function to the Ernie API."
    },
    {
      "type": "p",
      "content": "utils.ernie_functions.convert_pydantic_to_ernie_function(...)"
    },
    {
      "type": "p",
      "content": "Convert a Pydantic model to a function description for the Ernie API."
    },
    {
      "type": "p",
      "content": "utils.ernie_functions.convert_pydantic_to_ernie_tool(...)"
    },
    {
      "type": "p",
      "content": "Convert a Pydantic model to a function description for the Ernie API."
    },
    {
      "type": "p",
      "content": "utils.google.get_client_info([module])"
    },
    {
      "type": "p",
      "content": "Return a custom user agent header."
    },
    {
      "type": "p",
      "content": "utils.math.cosine_similarity(X, Y)"
    },
    {
      "type": "p",
      "content": "Row-wise cosine similarity between two equal-width matrices."
    },
    {
      "type": "p",
      "content": "utils.math.cosine_similarity_top_k(X, Y[, ...])"
    },
    {
      "type": "p",
      "content": "Row-wise cosine similarity with optional top-k and score threshold filtering."
    },
    {
      "type": "p",
      "content": "utils.user_agent.get_user_agent()"
    },
    {
      "type": "p",
      "content": "Get user agent from environment variable."
    },
    {
      "type": "h2",
      "content": "vectorstores#"
    },
    {
      "type": "p",
      "content": "vectorstores.aerospike.Aerospike(client, ...)"
    },
    {
      "type": "p",
      "content": "Aerospikevector store."
    },
    {
      "type": "p",
      "content": "vectorstores.alibabacloud_opensearch.AlibabaCloudOpenSearch(...)"
    },
    {
      "type": "p",
      "content": "Alibaba Cloud OpenSearchvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.alibabacloud_opensearch.AlibabaCloudOpenSearchSettings(...)"
    },
    {
      "type": "p",
      "content": "Alibaba Cloud Opensearch` client configuration."
    },
    {
      "type": "p",
      "content": "vectorstores.analyticdb.AnalyticDB(...[, ...])"
    },
    {
      "type": "p",
      "content": "AnalyticDB(distributed PostgreSQL) vector store."
    },
    {
      "type": "p",
      "content": "vectorstores.annoy.Annoy(embedding_function, ...)"
    },
    {
      "type": "p",
      "content": "Annoyvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.apache_doris.ApacheDoris(...[, ...])"
    },
    {
      "type": "p",
      "content": "Apache Dorisvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.apache_doris.ApacheDorisSettings"
    },
    {
      "type": "p",
      "content": "Apache Doris client configuration."
    },
    {
      "type": "p",
      "content": "vectorstores.apache_doris.QueryResult"
    },
    {
      "type": "p",
      "content": "vectorstores.aperturedb.ApertureDB(embeddings)"
    },
    {
      "type": "p",
      "content": "Create a vectorstore backed by ApertureDB"
    },
    {
      "type": "p",
      "content": "vectorstores.atlas.AtlasDB(name[, ...])"
    },
    {
      "type": "p",
      "content": "Atlasvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.awadb.AwaDB([table_name, ...])"
    },
    {
      "type": "p",
      "content": "AwaDBvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.azure_cosmos_db.AzureCosmosDBVectorSearch(...)"
    },
    {
      "type": "p",
      "content": "Azure Cosmos DB for MongoDB vCorevector store."
    },
    {
      "type": "p",
      "content": "vectorstores.azure_cosmos_db.CosmosDBSimilarityType(value)"
    },
    {
      "type": "p",
      "content": "Cosmos DB Similarity Type as enumerator."
    },
    {
      "type": "p",
      "content": "vectorstores.azure_cosmos_db.CosmosDBVectorSearchType(value)"
    },
    {
      "type": "p",
      "content": "Cosmos DB Vector Search Type as enumerator."
    },
    {
      "type": "p",
      "content": "vectorstores.azure_cosmos_db_no_sql.Condition"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "vectorstores.azure_cosmos_db_no_sql.CosmosDBQueryType(value)"
    },
    {
      "type": "p",
      "content": "CosmosDB Query Type"
    },
    {
      "type": "p",
      "content": "vectorstores.azure_cosmos_db_no_sql.PreFilter"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "vectorstores.azuresearch.AzureSearch(...[, ...])"
    },
    {
      "type": "p",
      "content": "Azure Cognitive Searchvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.azuresearch.AzureSearchVectorStoreRetriever"
    },
    {
      "type": "p",
      "content": "Retriever that usesAzure Cognitive Search."
    },
    {
      "type": "p",
      "content": "vectorstores.bagel.Bagel([cluster_name, ...])"
    },
    {
      "type": "p",
      "content": "Bagel.netInference platform."
    },
    {
      "type": "p",
      "content": "vectorstores.baiducloud_vector_search.BESVectorStore(...)"
    },
    {
      "type": "p",
      "content": "Baidu Elasticsearchvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.baiduvectordb.BaiduVectorDB(...)"
    },
    {
      "type": "p",
      "content": "Baidu VectorDB as a vector store."
    },
    {
      "type": "p",
      "content": "vectorstores.baiduvectordb.ConnectionParams(...)"
    },
    {
      "type": "p",
      "content": "Baidu VectorDB Connection params."
    },
    {
      "type": "p",
      "content": "vectorstores.baiduvectordb.TableParams(dimension)"
    },
    {
      "type": "p",
      "content": "Baidu VectorDB table params."
    },
    {
      "type": "p",
      "content": "vectorstores.cassandra.Cassandra(embedding)"
    },
    {
      "type": "p",
      "content": "Apache Cassandra(R) for vector-store workloads."
    },
    {
      "type": "p",
      "content": "vectorstores.clarifai.Clarifai([user_id, ...])"
    },
    {
      "type": "p",
      "content": "Clarifai AIvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.clickhouse.Clickhouse(embedding)"
    },
    {
      "type": "p",
      "content": "ClickHouse vector store integration."
    },
    {
      "type": "p",
      "content": "vectorstores.clickhouse.ClickhouseSettings"
    },
    {
      "type": "p",
      "content": "ClickHouseclient configuration."
    },
    {
      "type": "p",
      "content": "vectorstores.dashvector.DashVector(...)"
    },
    {
      "type": "p",
      "content": "DashVectorvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.dingo.Dingo(embedding, text_key, *)"
    },
    {
      "type": "p",
      "content": "Dingovector store."
    },
    {
      "type": "p",
      "content": "vectorstores.docarray.base.DocArrayIndex(...)"
    },
    {
      "type": "p",
      "content": "Base class forDocArraybased vector stores."
    },
    {
      "type": "p",
      "content": "vectorstores.docarray.hnsw.DocArrayHnswSearch(...)"
    },
    {
      "type": "p",
      "content": "HnswLibstorage usingDocArraypackage."
    },
    {
      "type": "p",
      "content": "vectorstores.docarray.in_memory.DocArrayInMemorySearch(...)"
    },
    {
      "type": "p",
      "content": "In-memoryDocArraystorage for exact search."
    },
    {
      "type": "p",
      "content": "vectorstores.documentdb.DocumentDBSimilarityType(value)"
    },
    {
      "type": "p",
      "content": "DocumentDB Similarity Type as enumerator."
    },
    {
      "type": "p",
      "content": "vectorstores.documentdb.DocumentDBVectorSearch(...)"
    },
    {
      "type": "p",
      "content": "Amazon DocumentDB (with MongoDB compatibility)vector store."
    },
    {
      "type": "p",
      "content": "vectorstores.duckdb.DuckDB(*[, connection, ...])"
    },
    {
      "type": "p",
      "content": "DuckDBvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.ecloud_vector_search.EcloudESVectorStore(...)"
    },
    {
      "type": "p",
      "content": "ecloud Elasticsearchvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.elasticsearch.BaseRetrievalStrategy()"
    },
    {
      "type": "p",
      "content": "Base class forElasticsearchretrieval strategies."
    },
    {
      "type": "p",
      "content": "vectorstores.epsilla.Epsilla(client, embeddings)"
    },
    {
      "type": "p",
      "content": "Wrapper around Epsilla vector database."
    },
    {
      "type": "p",
      "content": "vectorstores.faiss.FAISS(embedding_function, ...)"
    },
    {
      "type": "p",
      "content": "FAISS vector store integration."
    },
    {
      "type": "p",
      "content": "vectorstores.falkordb_vector.FalkorDBVector(...)"
    },
    {
      "type": "p",
      "content": "FalkorDBvector index."
    },
    {
      "type": "p",
      "content": "vectorstores.falkordb_vector.IndexType(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of the index types."
    },
    {
      "type": "p",
      "content": "vectorstores.falkordb_vector.SearchType(value)"
    },
    {
      "type": "p",
      "content": "Enumerator for different search strategies in FalkorDB VectorStore."
    },
    {
      "type": "p",
      "content": "vectorstores.hippo.Hippo(embedding_function)"
    },
    {
      "type": "p",
      "content": "Hippovector store."
    },
    {
      "type": "p",
      "content": "vectorstores.hologres.Hologres(...[, ndims, ...])"
    },
    {
      "type": "p",
      "content": "Hologres APIvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.infinispanvs.Infinispan([...])"
    },
    {
      "type": "p",
      "content": "Helper class forInfinispanREST interface."
    },
    {
      "type": "p",
      "content": "vectorstores.infinispanvs.InfinispanVS([...])"
    },
    {
      "type": "p",
      "content": "InfinispanVectorStore interface."
    },
    {
      "type": "p",
      "content": "vectorstores.jaguar.Jaguar(pod, store, ...)"
    },
    {
      "type": "p",
      "content": "Jaguar APIvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.kdbai.KDBAI(table, embedding[, ...])"
    },
    {
      "type": "p",
      "content": "KDB.AIvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.kinetica.Dimension(value)"
    },
    {
      "type": "p",
      "content": "Some default dimensions for known embeddings."
    },
    {
      "type": "p",
      "content": "vectorstores.kinetica.DistanceStrategy(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of the Distance strategies."
    },
    {
      "type": "p",
      "content": "vectorstores.kinetica.Kinetica(config, ...)"
    },
    {
      "type": "p",
      "content": "Kineticavector store."
    },
    {
      "type": "p",
      "content": "vectorstores.kinetica.KineticaSettings"
    },
    {
      "type": "p",
      "content": "Kineticaclient configuration."
    },
    {
      "type": "p",
      "content": "vectorstores.lancedb.LanceDB([connection, ...])"
    },
    {
      "type": "p",
      "content": "LanceDBvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.lantern.BaseEmbeddingStore()"
    },
    {
      "type": "p",
      "content": "Base class for the Lantern embedding store."
    },
    {
      "type": "p",
      "content": "vectorstores.lantern.DistanceStrategy(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of the Distance strategies."
    },
    {
      "type": "p",
      "content": "vectorstores.lantern.Lantern(...[, ...])"
    },
    {
      "type": "p",
      "content": "Postgreswith thelanternextension as a vector store."
    },
    {
      "type": "p",
      "content": "vectorstores.lantern.QueryResult()"
    },
    {
      "type": "p",
      "content": "Result from a query."
    },
    {
      "type": "p",
      "content": "vectorstores.llm_rails.LLMRails([...])"
    },
    {
      "type": "p",
      "content": "Implementation of Vector Store using LLMRails."
    },
    {
      "type": "p",
      "content": "vectorstores.llm_rails.LLMRailsRetriever"
    },
    {
      "type": "p",
      "content": "Retriever for LLMRails."
    },
    {
      "type": "p",
      "content": "vectorstores.manticore_search.ManticoreSearch(...)"
    },
    {
      "type": "p",
      "content": "ManticoreSearch Enginevector store."
    },
    {
      "type": "p",
      "content": "vectorstores.manticore_search.ManticoreSearchSettings"
    },
    {
      "type": "p",
      "content": "Create a new model by parsing and validating input data from keyword arguments."
    },
    {
      "type": "p",
      "content": "vectorstores.marqo.Marqo(client, index_name)"
    },
    {
      "type": "p",
      "content": "Marqovector store."
    },
    {
      "type": "p",
      "content": "vectorstores.meilisearch.Meilisearch(embedding)"
    },
    {
      "type": "p",
      "content": "Meilisearchvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.momento_vector_index.MomentoVectorIndex(...)"
    },
    {
      "type": "p",
      "content": "Momento Vector Index(MVI) vector store."
    },
    {
      "type": "p",
      "content": "vectorstores.myscale.MyScale(embedding[, config])"
    },
    {
      "type": "p",
      "content": "MyScalevector store."
    },
    {
      "type": "p",
      "content": "vectorstores.myscale.MyScaleSettings"
    },
    {
      "type": "p",
      "content": "MyScale client configuration."
    },
    {
      "type": "p",
      "content": "vectorstores.myscale.MyScaleWithoutJSON(...)"
    },
    {
      "type": "p",
      "content": "MyScale vector store without metadata column"
    },
    {
      "type": "p",
      "content": "vectorstores.nucliadb.NucliaDB(...[, ...])"
    },
    {
      "type": "p",
      "content": "NucliaDB vector store."
    },
    {
      "type": "p",
      "content": "vectorstores.opensearch_vector_search.OpenSearchVectorSearch(...)"
    },
    {
      "type": "p",
      "content": "Amazon OpenSearch Vector Enginevector store."
    },
    {
      "type": "p",
      "content": "vectorstores.oraclevs.OracleVS(client, ...)"
    },
    {
      "type": "p",
      "content": "OracleVSvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.pathway.PathwayVectorClient([...])"
    },
    {
      "type": "p",
      "content": "VectorStore connecting to Pathway Vector Store."
    },
    {
      "type": "p",
      "content": "vectorstores.pgembedding.BaseModel(**kwargs)"
    },
    {
      "type": "p",
      "content": "Base model for all SQL stores."
    },
    {
      "type": "p",
      "content": "vectorstores.pgembedding.CollectionStore(...)"
    },
    {
      "type": "p",
      "content": "Collection store."
    },
    {
      "type": "p",
      "content": "vectorstores.pgembedding.EmbeddingStore(**kwargs)"
    },
    {
      "type": "p",
      "content": "Embedding store."
    },
    {
      "type": "p",
      "content": "vectorstores.pgembedding.PGEmbedding(...[, ...])"
    },
    {
      "type": "p",
      "content": "Postgreswith thepg_embeddingextension as a vector store."
    },
    {
      "type": "p",
      "content": "vectorstores.pgembedding.QueryResult()"
    },
    {
      "type": "p",
      "content": "Result from a query."
    },
    {
      "type": "p",
      "content": "vectorstores.pgvecto_rs.PGVecto_rs(...[, ...])"
    },
    {
      "type": "p",
      "content": "VectorStore backed by pgvecto_rs."
    },
    {
      "type": "p",
      "content": "vectorstores.pgvector.BaseModel(**kwargs)"
    },
    {
      "type": "p",
      "content": "Base model for the SQL stores."
    },
    {
      "type": "p",
      "content": "vectorstores.pgvector.DistanceStrategy(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of the Distance strategies."
    },
    {
      "type": "p",
      "content": "vectorstores.qdrant.QdrantException"
    },
    {
      "type": "p",
      "content": "Qdrantrelated exceptions."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.base.RedisVectorStoreRetriever"
    },
    {
      "type": "p",
      "content": "Retriever for Redis VectorStore."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.filters.RedisFilter()"
    },
    {
      "type": "p",
      "content": "Collection of RedisFilterFields."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.filters.RedisFilterExpression([...])"
    },
    {
      "type": "p",
      "content": "Logical expression of RedisFilterFields."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.filters.RedisFilterField(field)"
    },
    {
      "type": "p",
      "content": "Base class for RedisFilterFields."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.filters.RedisFilterOperator(value)"
    },
    {
      "type": "p",
      "content": "RedisFilterOperator enumerator is used to create RedisFilterExpressions."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.filters.RedisNum(field)"
    },
    {
      "type": "p",
      "content": "RedisFilterField representing a numeric field in a Redis index."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.filters.RedisTag(field)"
    },
    {
      "type": "p",
      "content": "RedisFilterField representing a tag in a Redis index."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.filters.RedisText(field)"
    },
    {
      "type": "p",
      "content": "RedisFilterField representing a text field in a Redis index."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.schema.FlatVectorField"
    },
    {
      "type": "p",
      "content": "Schema for flat vector fields in Redis."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.schema.HNSWVectorField"
    },
    {
      "type": "p",
      "content": "Schema for HNSW vector fields in Redis."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.schema.NumericFieldSchema"
    },
    {
      "type": "p",
      "content": "Schema for numeric fields in Redis."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.schema.RedisDistanceMetric(value)"
    },
    {
      "type": "p",
      "content": "Distance metrics for Redis vector fields."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.schema.RedisField"
    },
    {
      "type": "p",
      "content": "Base class for Redis fields."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.schema.RedisModel"
    },
    {
      "type": "p",
      "content": "Schema for Redis index."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.schema.RedisVectorField"
    },
    {
      "type": "p",
      "content": "Base class for Redis vector fields."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.schema.TagFieldSchema"
    },
    {
      "type": "p",
      "content": "Schema for tag fields in Redis."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.schema.TextFieldSchema"
    },
    {
      "type": "p",
      "content": "Schema for text fields in Redis."
    },
    {
      "type": "p",
      "content": "vectorstores.relyt.Relyt(connection_string, ...)"
    },
    {
      "type": "p",
      "content": "Relyt(distributed PostgreSQL) vector store."
    },
    {
      "type": "p",
      "content": "vectorstores.rocksetdb.Rockset(client, ...)"
    },
    {
      "type": "p",
      "content": "Rocksetvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.scann.ScaNN(embedding, index, ...)"
    },
    {
      "type": "p",
      "content": "ScaNNvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.semadb.SemaDB(collection_name, ...)"
    },
    {
      "type": "p",
      "content": "SemaDBvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.sklearn.BaseSerializer(persist_path)"
    },
    {
      "type": "p",
      "content": "Base class for serializing data."
    },
    {
      "type": "p",
      "content": "vectorstores.sklearn.BsonSerializer(persist_path)"
    },
    {
      "type": "p",
      "content": "Serialize data in Binary JSON using thebsonpython package."
    },
    {
      "type": "p",
      "content": "vectorstores.sklearn.JsonSerializer(persist_path)"
    },
    {
      "type": "p",
      "content": "Serialize data in JSON using the json package from python standard library."
    },
    {
      "type": "p",
      "content": "vectorstores.sklearn.ParquetSerializer(...)"
    },
    {
      "type": "p",
      "content": "Serialize data inApache Parquetformat using thepyarrowpackage."
    },
    {
      "type": "p",
      "content": "vectorstores.sklearn.SKLearnVectorStore(...)"
    },
    {
      "type": "p",
      "content": "Simple in-memory vector store based on thescikit-learnlibraryNearestNeighbors."
    },
    {
      "type": "p",
      "content": "vectorstores.sklearn.SKLearnVectorStoreException"
    },
    {
      "type": "p",
      "content": "Exception raised by SKLearnVectorStore."
    },
    {
      "type": "p",
      "content": "vectorstores.sqlitevec.SQLiteVec(table, ...)"
    },
    {
      "type": "p",
      "content": "SQLite with Vec extension as a vector database."
    },
    {
      "type": "p",
      "content": "vectorstores.sqlitevss.SQLiteVSS(table, ...)"
    },
    {
      "type": "p",
      "content": "SQLite with VSS extension as a vector database."
    },
    {
      "type": "p",
      "content": "vectorstores.starrocks.QueryResult"
    },
    {
      "type": "p",
      "content": "vectorstores.starrocks.StarRocks(embedding)"
    },
    {
      "type": "p",
      "content": "StarRocksvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.starrocks.StarRocksSettings"
    },
    {
      "type": "p",
      "content": "StarRocks client configuration."
    },
    {
      "type": "p",
      "content": "vectorstores.supabase.SupabaseVectorStore(...)"
    },
    {
      "type": "p",
      "content": "Supabase Postgresvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.surrealdb.SurrealDBStore(...)"
    },
    {
      "type": "p",
      "content": "SurrealDB as Vector Store."
    },
    {
      "type": "p",
      "content": "vectorstores.tablestore.TablestoreVectorStore(...)"
    },
    {
      "type": "p",
      "content": "Tablestorevector store."
    },
    {
      "type": "p",
      "content": "vectorstores.tair.Tair(embedding_function, ...)"
    },
    {
      "type": "p",
      "content": "Tairvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.tencentvectordb.ConnectionParams(...)"
    },
    {
      "type": "p",
      "content": "Tencent vector DB Connection params."
    },
    {
      "type": "p",
      "content": "vectorstores.tencentvectordb.IndexParams(...)"
    },
    {
      "type": "p",
      "content": "Tencent vector DB Index params."
    },
    {
      "type": "p",
      "content": "vectorstores.tencentvectordb.MetaField"
    },
    {
      "type": "p",
      "content": "MetaData Field for Tencent vector DB."
    },
    {
      "type": "p",
      "content": "vectorstores.tencentvectordb.TencentVectorDB(...)"
    },
    {
      "type": "p",
      "content": "Tencent VectorDB as a vector store."
    },
    {
      "type": "p",
      "content": "vectorstores.thirdai_neuraldb.NeuralDBClientVectorStore(db)"
    },
    {
      "type": "p",
      "content": "Vectorstore that uses ThirdAI's NeuralDB Enterprise Python Client for NeuralDBs."
    },
    {
      "type": "p",
      "content": "vectorstores.thirdai_neuraldb.NeuralDBVectorStore(db)"
    },
    {
      "type": "p",
      "content": "Vectorstore that uses ThirdAI's NeuralDB."
    },
    {
      "type": "p",
      "content": "vectorstores.tidb_vector.TiDBVectorStore(...)"
    },
    {
      "type": "p",
      "content": "TiDB Vector Store."
    },
    {
      "type": "p",
      "content": "vectorstores.tigris.Tigris(client, ...)"
    },
    {
      "type": "p",
      "content": "Tigrisvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.tiledb.TileDB(embedding, ...[, ...])"
    },
    {
      "type": "p",
      "content": "TileDB vector store."
    },
    {
      "type": "p",
      "content": "vectorstores.timescalevector.TimescaleVector(...)"
    },
    {
      "type": "p",
      "content": "Timescale Postgres vector store"
    },
    {
      "type": "p",
      "content": "vectorstores.typesense.Typesense(...[, ...])"
    },
    {
      "type": "p",
      "content": "Typesensevector store."
    },
    {
      "type": "p",
      "content": "vectorstores.upstash.UpstashVectorStore([...])"
    },
    {
      "type": "p",
      "content": "Upstash Vector vector store"
    },
    {
      "type": "p",
      "content": "vectorstores.usearch.USearch(embedding, ...)"
    },
    {
      "type": "p",
      "content": "USearchvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.utils.DistanceStrategy(value)"
    },
    {
      "type": "p",
      "content": "Enumerator of the Distance strategies for calculating distances between vectors."
    },
    {
      "type": "p",
      "content": "vectorstores.vald.Vald(embedding[, host, ...])"
    },
    {
      "type": "p",
      "content": "Vald vector database."
    },
    {
      "type": "p",
      "content": "vectorstores.vearch.Vearch(embedding_function)"
    },
    {
      "type": "p",
      "content": "Initialize vearch vector store flag 1 for cluster,0 for standalone"
    },
    {
      "type": "p",
      "content": "vectorstores.vectara.MMRConfig([is_enabled, ...])"
    },
    {
      "type": "p",
      "content": "Configuration for Maximal Marginal Relevance (MMR) search."
    },
    {
      "type": "p",
      "content": "vectorstores.vectara.RerankConfig([...])"
    },
    {
      "type": "p",
      "content": "Configuration for Reranker."
    },
    {
      "type": "p",
      "content": "vectorstores.vectara.SummaryConfig([...])"
    },
    {
      "type": "p",
      "content": "Configuration for summary generation."
    },
    {
      "type": "p",
      "content": "vectorstores.vectara.Vectara([...])"
    },
    {
      "type": "p",
      "content": "Vectara APIvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.vectara.VectaraQueryConfig([k, ...])"
    },
    {
      "type": "p",
      "content": "Configuration for Vectara query."
    },
    {
      "type": "p",
      "content": "vectorstores.vectara.VectaraRAG(vectara, config)"
    },
    {
      "type": "p",
      "content": "Vectara RAG runnable."
    },
    {
      "type": "p",
      "content": "vectorstores.vectara.VectaraRetriever"
    },
    {
      "type": "p",
      "content": "Vectara Retriever class."
    },
    {
      "type": "p",
      "content": "vectorstores.vespa.VespaStore(app[, ...])"
    },
    {
      "type": "p",
      "content": "Vespavector store."
    },
    {
      "type": "p",
      "content": "vectorstores.vikingdb.VikingDB(...[, ...])"
    },
    {
      "type": "p",
      "content": "vikingdb as a vector store"
    },
    {
      "type": "p",
      "content": "vectorstores.vikingdb.VikingDBConfig([host, ...])"
    },
    {
      "type": "p",
      "content": "vikingdb connection config"
    },
    {
      "type": "p",
      "content": "vectorstores.vlite.VLite(embedding_function)"
    },
    {
      "type": "p",
      "content": "VLite is a simple and fast vector database for semantic search."
    },
    {
      "type": "p",
      "content": "vectorstores.xata.XataVectorStore(api_key, ...)"
    },
    {
      "type": "p",
      "content": "Xatavector store."
    },
    {
      "type": "p",
      "content": "vectorstores.yellowbrick.Yellowbrick(...[, ...])"
    },
    {
      "type": "p",
      "content": "Yellowbrick as a vector database."
    },
    {
      "type": "p",
      "content": "vectorstores.zep.CollectionConfig(name, ...)"
    },
    {
      "type": "p",
      "content": "Configuration for aZep Collection."
    },
    {
      "type": "p",
      "content": "vectorstores.zep.ZepVectorStore(...[, ...])"
    },
    {
      "type": "p",
      "content": "Zepvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.zep_cloud.ZepCloudVectorStore(...)"
    },
    {
      "type": "p",
      "content": "Zepvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.zilliz.Zilliz(embedding_function)"
    },
    {
      "type": "p",
      "content": "Zillizvector store."
    },
    {
      "type": "p",
      "content": "vectorstores.alibabacloud_opensearch.create_metadata(fields)"
    },
    {
      "type": "p",
      "content": "Create metadata from fields."
    },
    {
      "type": "p",
      "content": "vectorstores.annoy.dependable_annoy_import()"
    },
    {
      "type": "p",
      "content": "Import annoy if available, otherwise raise error."
    },
    {
      "type": "p",
      "content": "vectorstores.clickhouse.has_mul_sub_str(s, *args)"
    },
    {
      "type": "p",
      "content": "Check if a string contains multiple substrings."
    },
    {
      "type": "p",
      "content": "vectorstores.faiss.dependable_faiss_import([...])"
    },
    {
      "type": "p",
      "content": "Import faiss if available, otherwise raise error."
    },
    {
      "type": "p",
      "content": "vectorstores.falkordb_vector.construct_metadata_filter([...])"
    },
    {
      "type": "p",
      "content": "Construct a metadata filter by directly injecting the filter values into the query."
    },
    {
      "type": "p",
      "content": "vectorstores.falkordb_vector.dict_to_yaml_str(...)"
    },
    {
      "type": "p",
      "content": "Convert a dictionary to a YAML-like string without using external libraries."
    },
    {
      "type": "p",
      "content": "vectorstores.falkordb_vector.generate_random_string(length)"
    },
    {
      "type": "p",
      "content": "vectorstores.falkordb_vector.process_index_data(data)"
    },
    {
      "type": "p",
      "content": "Processes a nested list of entity data to extract information about  labels, entity types, properties, index types, and index details (if applicable)."
    },
    {
      "type": "p",
      "content": "vectorstores.lancedb.import_lancedb()"
    },
    {
      "type": "p",
      "content": "Import lancedb package."
    },
    {
      "type": "p",
      "content": "vectorstores.lancedb.to_lance_filter(filter)"
    },
    {
      "type": "p",
      "content": "Converts a dict filter to a LanceDB filter string."
    },
    {
      "type": "p",
      "content": "vectorstores.lantern.get_embedding_store(...)"
    },
    {
      "type": "p",
      "content": "Get the embedding store class."
    },
    {
      "type": "p",
      "content": "vectorstores.myscale.has_mul_sub_str(s, *args)"
    },
    {
      "type": "p",
      "content": "Check if a string contains multiple substrings."
    },
    {
      "type": "p",
      "content": "vectorstores.oraclevs.create_index(client, ...)"
    },
    {
      "type": "p",
      "content": "vectorstores.oraclevs.drop_index_if_exists(...)"
    },
    {
      "type": "p",
      "content": "Drop an index if it exists."
    },
    {
      "type": "p",
      "content": "vectorstores.oraclevs.drop_table_purge(...)"
    },
    {
      "type": "p",
      "content": "Drop a table and purge it from the database."
    },
    {
      "type": "p",
      "content": "vectorstores.qdrant.sync_call_fallback(method)"
    },
    {
      "type": "p",
      "content": "Decorator to call the synchronous method of the class if the async method is not implemented."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.base.check_index_exists(...)"
    },
    {
      "type": "p",
      "content": "Check if Redis index exists."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.filters.check_operator_misuse(func)"
    },
    {
      "type": "p",
      "content": "Decorator to check for misuse of equality operators."
    },
    {
      "type": "p",
      "content": "vectorstores.redis.schema.read_schema(...)"
    },
    {
      "type": "p",
      "content": "Read in the index schema from a dict or yaml file."
    },
    {
      "type": "p",
      "content": "vectorstores.scann.dependable_scann_import()"
    },
    {
      "type": "p",
      "content": "Importscannif available, otherwise raise error."
    },
    {
      "type": "p",
      "content": "vectorstores.scann.normalize(x)"
    },
    {
      "type": "p",
      "content": "Normalize vectors to unit length."
    },
    {
      "type": "p",
      "content": "vectorstores.sqlitevec.serialize_f32(vector)"
    },
    {
      "type": "p",
      "content": "Serializes a list of floats into a compact \"raw bytes\" format"
    },
    {
      "type": "p",
      "content": "vectorstores.starrocks.debug_output(s)"
    },
    {
      "type": "p",
      "content": "Print a debug message if DEBUG is True."
    },
    {
      "type": "p",
      "content": "vectorstores.starrocks.get_named_result(...)"
    },
    {
      "type": "p",
      "content": "Get a named result from a query."
    },
    {
      "type": "p",
      "content": "vectorstores.starrocks.has_mul_sub_str(s, *args)"
    },
    {
      "type": "p",
      "content": "Check if a string has multiple substrings."
    },
    {
      "type": "p",
      "content": "vectorstores.tencentvectordb.translate_filter(...)"
    },
    {
      "type": "p",
      "content": "Translate LangChain filter to Tencent VectorDB filter."
    },
    {
      "type": "p",
      "content": "vectorstores.tiledb.dependable_tiledb_import()"
    },
    {
      "type": "p",
      "content": "Import tiledb-vector-search if available, otherwise raise error."
    },
    {
      "type": "p",
      "content": "vectorstores.tiledb.get_documents_array_uri(uri)"
    },
    {
      "type": "p",
      "content": "Get the URI of the documents array."
    },
    {
      "type": "p",
      "content": "vectorstores.tiledb.get_documents_array_uri_from_group(group)"
    },
    {
      "type": "p",
      "content": "Get the URI of the documents array from group."
    },
    {
      "type": "p",
      "content": "vectorstores.tiledb.get_vector_index_uri(uri)"
    },
    {
      "type": "p",
      "content": "Get the URI of the vector index."
    },
    {
      "type": "p",
      "content": "vectorstores.tiledb.get_vector_index_uri_from_group(group)"
    },
    {
      "type": "p",
      "content": "Get the URI of the vector index."
    },
    {
      "type": "p",
      "content": "vectorstores.usearch.dependable_usearch_import()"
    },
    {
      "type": "p",
      "content": "Import usearch if available, otherwise raise error."
    },
    {
      "type": "p",
      "content": "vectorstores.utils.filter_complex_metadata(...)"
    },
    {
      "type": "p",
      "content": "Filter out metadata types that are not supported for a vector store."
    },
    {
      "type": "p",
      "content": "vectorstores.utils.maximal_marginal_relevance(...)"
    },
    {
      "type": "p",
      "content": "Calculate maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "vectorstores.vdms.VDMS_Client([host, port])"
    },
    {
      "type": "p",
      "content": "VDMS client for the VDMS server."
    },
    {
      "type": "p",
      "content": "vectorstores.vdms.embedding2bytes(embedding)"
    },
    {
      "type": "p",
      "content": "Convert embedding to bytes."
    },
    {
      "type": "p",
      "content": "Deprecated classes"
    },
    {
      "type": "p",
      "content": "vectorstores.astradb.AstraDB(*, embedding, ...)"
    },
    {
      "type": "p",
      "content": "vectorstores.azure_cosmos_db_no_sql.AzureCosmosDBNoSqlVectorSearch(*, ...)"
    },
    {
      "type": "p",
      "content": "vectorstores.bigquery_vector_search.BigQueryVectorSearch(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.chroma.Chroma([...])"
    },
    {
      "type": "p",
      "content": "vectorstores.couchbase.CouchbaseVectorStore(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.databricks_vector_search.DatabricksVectorSearch(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.deeplake.DeepLake([...])"
    },
    {
      "type": "p",
      "content": "vectorstores.elastic_vector_search.ElasticKnnSearch(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.elastic_vector_search.ElasticVectorSearch(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.elasticsearch.ApproxRetrievalStrategy([...])"
    },
    {
      "type": "p",
      "content": "vectorstores.elasticsearch.ElasticsearchStore(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.elasticsearch.ExactRetrievalStrategy(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.elasticsearch.SparseRetrievalStrategy([...])"
    },
    {
      "type": "p",
      "content": "vectorstores.hanavector.HanaDB(connection, ...)"
    },
    {
      "type": "p",
      "content": "vectorstores.matching_engine.MatchingEngine(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.milvus.Milvus(embedding_function)"
    },
    {
      "type": "p",
      "content": "vectorstores.mongodb_atlas.MongoDBAtlasVectorSearch(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.neo4j_vector.IndexType(value)"
    },
    {
      "type": "p",
      "content": "vectorstores.neo4j_vector.Neo4jVector(...[, ...])"
    },
    {
      "type": "p",
      "content": "vectorstores.neo4j_vector.SearchType(value)"
    },
    {
      "type": "p",
      "content": "vectorstores.pgvector.PGVector(...[, ...])"
    },
    {
      "type": "p",
      "content": "vectorstores.pinecone.Pinecone(index, ...[, ...])"
    },
    {
      "type": "p",
      "content": "vectorstores.qdrant.Qdrant(client, ...[, ...])"
    },
    {
      "type": "p",
      "content": "vectorstores.redis.base.Redis(redis_url, ...)"
    },
    {
      "type": "p",
      "content": "vectorstores.singlestoredb.SingleStoreDB(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.vdms.VDMS(client, *[, ...])"
    },
    {
      "type": "p",
      "content": "vectorstores.weaviate.Weaviate(client, ...)"
    },
    {
      "type": "p",
      "content": "Deprecated functions"
    },
    {
      "type": "p",
      "content": "vectorstores.neo4j_vector.check_if_not_null(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.neo4j_vector.collect_params(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.neo4j_vector.combine_queries(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.neo4j_vector.construct_metadata_filter(filter)"
    },
    {
      "type": "p",
      "content": "vectorstores.neo4j_vector.dict_to_yaml_str(...)"
    },
    {
      "type": "p",
      "content": "vectorstores.neo4j_vector.remove_lucene_chars(text)"
    },
    {
      "type": "p",
      "content": "vectorstores.neo4j_vector.sort_by_index_name(...)"
    }
  ],
  "code_examples": [
    "adapters.openai.Chat",
    "adapters.openai.ChatCompletion",
    "adapters.openai.ChatCompletionChunk",
    "adapters.openai.ChatCompletions",
    "adapters.openai.Choice",
    "adapters.openai.ChoiceChunk",
    "adapters.openai.Completions",
    "adapters.openai.IndexableBaseModel",
    "adapters.openai.aenumerate",
    "adapters.openai.convert_dict_to_message",
    "adapters.openai.convert_message_to_dict",
    "adapters.openai.convert_messages_for_finetuning",
    "adapters.openai.convert_openai_messages",
    "agent_toolkits.ainetwork.toolkit.AINetworkToolkit",
    "agent_toolkits.amadeus.toolkit.AmadeusToolkit",
    "agent_toolkits.azure_ai_services.AzureAiServicesToolkit",
    "agent_toolkits.azure_cognitive_services.AzureCognitiveServicesToolkit",
    "agent_toolkits.cassandra_database.toolkit.CassandraDatabaseToolkit",
    "agent_toolkits.clickup.toolkit.ClickupToolkit",
    "agent_toolkits.cogniswitch.toolkit.CogniswitchToolkit",
    "agent_toolkits.connery.toolkit.ConneryToolkit",
    "agent_toolkits.file_management.toolkit.FileManagementToolkit",
    "agent_toolkits.financial_datasets.toolkit.FinancialDatasetsToolkit",
    "agent_toolkits.github.toolkit.BranchName",
    "agent_toolkits.github.toolkit.CommentOnIssue",
    "agent_toolkits.github.toolkit.CreateFile",
    "agent_toolkits.github.toolkit.CreatePR",
    "agent_toolkits.github.toolkit.CreateReviewRequest",
    "agent_toolkits.github.toolkit.DeleteFile",
    "agent_toolkits.github.toolkit.DirectoryPath",
    "agent_toolkits.github.toolkit.GetIssue",
    "agent_toolkits.github.toolkit.GetPR",
    "agent_toolkits.github.toolkit.GitHubToolkit",
    "agent_toolkits.github.toolkit.NoInput",
    "agent_toolkits.github.toolkit.ReadFile",
    "agent_toolkits.github.toolkit.SearchCode",
    "agent_toolkits.github.toolkit.SearchIssuesAndPRs",
    "agent_toolkits.github.toolkit.TagName",
    "agent_toolkits.github.toolkit.UpdateFile",
    "agent_toolkits.gitlab.toolkit.GitLabToolkit",
    "agent_toolkits.gmail.toolkit.GmailToolkit",
    "agent_toolkits.jira.toolkit.JiraToolkit",
    "agent_toolkits.json.toolkit.JsonToolkit",
    "agent_toolkits.multion.toolkit.MultionToolkit",
    "agent_toolkits.nasa.toolkit.NasaToolkit",
    "agent_toolkits.nla.tool.NLATool",
    "agent_toolkits.nla.toolkit.NLAToolkit",
    "agent_toolkits.office365.toolkit.O365Toolkit",
    "agent_toolkits.openapi.planner.RequestsDeleteToolWithParsing",
    "agent_toolkits.openapi.planner.RequestsGetToolWithParsing",
    "agent_toolkits.openapi.planner.RequestsPatchToolWithParsing",
    "agent_toolkits.openapi.planner.RequestsPostToolWithParsing",
    "agent_toolkits.openapi.planner.RequestsPutToolWithParsing",
    "agent_toolkits.openapi.spec.ReducedOpenAPISpec",
    "agent_toolkits.openapi.toolkit.OpenAPIToolkit",
    "agent_toolkits.openapi.toolkit.RequestsToolkit",
    "agent_toolkits.playwright.toolkit.PlayWrightBrowserToolkit",
    "agent_toolkits.polygon.toolkit.PolygonToolkit",
    "agent_toolkits.powerbi.toolkit.PowerBIToolkit",
    "agent_toolkits.slack.toolkit.SlackToolkit",
    "agent_toolkits.spark_sql.toolkit.SparkSQLToolkit",
    "agent_toolkits.sql.toolkit.SQLDatabaseToolkit",
    "agent_toolkits.steam.toolkit.SteamToolkit",
    "agent_toolkits.zapier.toolkit.ZapierToolkit",
    "agent_toolkits.json.base.create_json_agent",
    "agent_toolkits.load_tools.get_all_tool_names",
    "agent_toolkits.load_tools.load_huggingface_tool",
    "agent_toolkits.load_tools.load_tools",
    "agent_toolkits.load_tools.raise_dangerous_tools_exception",
    "agent_toolkits.openapi.base.create_openapi_agent",
    "agent_toolkits.openapi.planner.create_openapi_agent",
    "agent_toolkits.openapi.spec.reduce_openapi_spec",
    "agent_toolkits.powerbi.base.create_pbi_agent",
    "agent_toolkits.powerbi.chat_base.create_pbi_chat_agent",
    "agent_toolkits.spark_sql.base.create_spark_sql_agent",
    "agent_toolkits.sql.base.create_sql_agent",
    "agents.openai_assistant.base.OpenAIAssistantV2Runnable",
    "cache.AsyncRedisCache",
    "cache.AzureCosmosDBNoSqlSemanticCache",
    "cache.AzureCosmosDBSemanticCache",
    "cache.CassandraCache",
    "cache.CassandraSemanticCache",
    "cache.FullLLMCache",
    "cache.FullMd5LLMCache",
    "cache.GPTCache",
    "cache.InMemoryCache",
    "cache.MemcachedCache",
    "cache.MomentoCache",
    "cache.OpenSearchSemanticCache",
    "cache.RedisCache",
    "cache.RedisSemanticCache",
    "cache.SQLAlchemyCache",
    "cache.SQLAlchemyMd5Cache",
    "cache.SQLiteCache",
    "cache.UpstashRedisCache",
    "cache.AstraDBCache",
    "cache.AstraDBSemanticCache",
    "cache.SingleStoreDBSemanticCache",
    "callbacks.aim_callback.AimCallbackHandler",
    "callbacks.aim_callback.BaseMetadataCallbackHandler",
    "callbacks.argilla_callback.ArgillaCallbackHandler",
    "callbacks.arize_callback.ArizeCallbackHandler",
    "callbacks.arthur_callback.ArthurCallbackHandler",
    "callbacks.bedrock_anthropic_callback.BedrockAnthropicTokenUsageCallbackHandler",
    "callbacks.clearml_callback.ClearMLCallbackHandler",
    "callbacks.comet_ml_callback.CometCallbackHandler",
    "callbacks.confident_callback.DeepEvalCallbackHandler",
    "callbacks.context_callback.ContextCallbackHandler",
    "callbacks.fiddler_callback.FiddlerCallbackHandler",
    "callbacks.flyte_callback.FlyteCallbackHandler",
    "callbacks.human.AsyncHumanApprovalCallbackHandler",
    "callbacks.human.HumanApprovalCallbackHandler",
    "callbacks.human.HumanRejectedException",
    "callbacks.infino_callback.InfinoCallbackHandler",
    "callbacks.labelstudio_callback.LabelStudioCallbackHandler",
    "callbacks.labelstudio_callback.LabelStudioMode",
    "callbacks.llmonitor_callback.LLMonitorCallbackHandler",
    "callbacks.llmonitor_callback.UserContextManager",
    "callbacks.mlflow_callback.MlflowCallbackHandler",
    "callbacks.mlflow_callback.MlflowLogger",
    "callbacks.openai_info.OpenAICallbackHandler",
    "callbacks.openai_info.TokenType",
    "callbacks.promptlayer_callback.PromptLayerCallbackHandler",
    "callbacks.sagemaker_callback.SageMakerCallbackHandler",
    "callbacks.streamlit.mutable_expander.ChildRecord",
    "callbacks.streamlit.mutable_expander.ChildType",
    "callbacks.streamlit.mutable_expander.MutableExpander",
    "callbacks.streamlit.streamlit_callback_handler.LLMThought",
    "callbacks.streamlit.streamlit_callback_handler.LLMThoughtLabeler",
    "callbacks.streamlit.streamlit_callback_handler.LLMThoughtState",
    "callbacks.streamlit.streamlit_callback_handler.StreamlitCallbackHandler",
    "callbacks.streamlit.streamlit_callback_handler.ToolRecord",
    "callbacks.tracers.comet.CometTracer",
    "callbacks.tracers.wandb.WandbRunArgs",
    "callbacks.tracers.wandb.WandbTracer",
    "callbacks.trubrics_callback.TrubricsCallbackHandler",
    "callbacks.upstash_ratelimit_callback.UpstashRatelimitError",
    "callbacks.upstash_ratelimit_callback.UpstashRatelimitHandler",
    "callbacks.uptrain_callback.UpTrainCallbackHandler",
    "callbacks.uptrain_callback.UpTrainDataSchema",
    "callbacks.utils.BaseMetadataCallbackHandler",
    "callbacks.wandb_callback.WandbCallbackHandler",
    "callbacks.whylabs_callback.WhyLabsCallbackHandler",
    "callbacks.aim_callback.import_aim",
    "callbacks.clearml_callback.import_clearml",
    "callbacks.comet_ml_callback.import_comet_ml",
    "callbacks.context_callback.import_context",
    "callbacks.fiddler_callback.import_fiddler",
    "callbacks.flyte_callback.analyze_text",
    "callbacks.flyte_callback.import_flytekit",
    "callbacks.infino_callback.get_num_tokens",
    "callbacks.infino_callback.import_infino",
    "callbacks.infino_callback.import_tiktoken",
    "callbacks.labelstudio_callback.get_default_label_configs",
    "callbacks.llmonitor_callback.identify",
    "callbacks.manager.get_bedrock_anthropic_callback",
    "callbacks.manager.get_openai_callback",
    "callbacks.manager.wandb_tracing_enabled",
    "callbacks.mlflow_callback.analyze_text",
    "callbacks.mlflow_callback.construct_html_from_prompt_and_generation",
    "callbacks.mlflow_callback.get_text_complexity_metrics",
    "callbacks.mlflow_callback.import_mlflow",
    "callbacks.mlflow_callback.mlflow_callback_metrics",
    "callbacks.openai_info.get_openai_token_cost_for_model",
    "callbacks.openai_info.standardize_model_name",
    "callbacks.sagemaker_callback.save_json",
    "callbacks.tracers.comet.import_comet_llm_api",
    "callbacks.tracers.wandb.build_tree",
    "callbacks.tracers.wandb.flatten_run",
    "callbacks.tracers.wandb.modify_serialized_iterative",
    "callbacks.tracers.wandb.truncate_run_iterative",
    "callbacks.uptrain_callback.import_uptrain",
    "callbacks.utils.flatten_dict",
    "callbacks.utils.hash_string",
    "callbacks.utils.import_pandas",
    "callbacks.utils.import_spacy",
    "callbacks.utils.import_textstat",
    "callbacks.utils.load_json",
    "callbacks.wandb_callback.analyze_text",
    "callbacks.wandb_callback.construct_html_from_prompt_and_generation",
    "callbacks.wandb_callback.import_wandb",
    "callbacks.wandb_callback.load_json_to_dict",
    "callbacks.whylabs_callback.import_langkit",
    "chains.graph_qa.arangodb.ArangoGraphQAChain",
    "chains.graph_qa.base.GraphQAChain",
    "chains.graph_qa.cypher_utils.Schema",
    "chains.graph_qa.falkordb.FalkorDBQAChain",
    "chains.graph_qa.gremlin.GremlinQAChain",
    "chains.graph_qa.hugegraph.HugeGraphQAChain",
    "chains.graph_qa.kuzu.KuzuQAChain",
    "chains.graph_qa.memgraph.MemgraphQAChain",
    "chains.graph_qa.nebulagraph.NebulaGraphQAChain",
    "chains.graph_qa.ontotext_graphdb.OntotextGraphDBQAChain",
    "chains.graph_qa.sparql.GraphSparqlQAChain",
    "chains.llm_requests.LLMRequestsChain",
    "chains.openapi.chain.OpenAPIEndpointChain",
    "chains.openapi.requests_chain.APIRequesterChain",
    "chains.openapi.requests_chain.APIRequesterOutputParser",
    "chains.openapi.response_chain.APIResponderChain",
    "chains.openapi.response_chain.APIResponderOutputParser",
    "chains.pebblo_retrieval.base.PebbloRetrievalQA",
    "chains.pebblo_retrieval.models.App",
    "chains.pebblo_retrieval.models.AuthContext",
    "chains.pebblo_retrieval.models.ChainInfo",
    "chains.pebblo_retrieval.models.ChainInput",
    "chains.pebblo_retrieval.models.Context",
    "chains.pebblo_retrieval.models.Framework",
    "chains.pebblo_retrieval.models.Model",
    "chains.pebblo_retrieval.models.PkgInfo",
    "chains.pebblo_retrieval.models.Prompt",
    "chains.pebblo_retrieval.models.Qa",
    "chains.pebblo_retrieval.models.Runtime",
    "chains.pebblo_retrieval.models.SemanticContext",
    "chains.pebblo_retrieval.models.SemanticEntities",
    "chains.pebblo_retrieval.models.SemanticTopics",
    "chains.pebblo_retrieval.models.VectorDB",
    "chains.pebblo_retrieval.utilities.PebbloRetrievalAPIWrapper",
    "chains.pebblo_retrieval.utilities.Routes",
    "chains.ernie_functions.base.convert_python_function_to_ernie_function",
    "chains.ernie_functions.base.convert_to_ernie_function",
    "chains.ernie_functions.base.create_ernie_fn_chain",
    "chains.ernie_functions.base.create_ernie_fn_runnable",
    "chains.ernie_functions.base.create_structured_output_chain",
    "chains.ernie_functions.base.create_structured_output_runnable",
    "chains.ernie_functions.base.get_ernie_output_parser",
    "chains.graph_qa.falkordb.extract_cypher",
    "chains.graph_qa.gremlin.extract_gremlin",
    "chains.graph_qa.kuzu.extract_cypher",
    "chains.graph_qa.kuzu.remove_prefix",
    "chains.graph_qa.memgraph.extract_cypher",
    "chains.graph_qa.memgraph.get_function_response",
    "chains.graph_qa.neptune_cypher.extract_cypher",
    "chains.graph_qa.neptune_cypher.trim_query",
    "chains.graph_qa.neptune_cypher.use_simple_prompt",
    "chains.graph_qa.neptune_sparql.extract_sparql",
    "chains.pebblo_retrieval.enforcement_filters.clear_enforcement_filters",
    "chains.pebblo_retrieval.enforcement_filters.set_enforcement_filters",
    "chains.pebblo_retrieval.utilities.get_ip",
    "chains.pebblo_retrieval.utilities.get_runtime",
    "chains.graph_qa.cypher.GraphCypherQAChain",
    "chains.graph_qa.cypher_utils.CypherQueryCorrector",
    "chains.graph_qa.neptune_cypher.NeptuneOpenCypherQAChain",
    "chains.graph_qa.neptune_sparql.NeptuneSparqlQAChain",
    "chains.graph_qa.cypher.construct_schema",
    "chains.graph_qa.cypher.extract_cypher",
    "chains.graph_qa.cypher.get_function_response",
    "chat_loaders.facebook_messenger.FolderFacebookMessengerChatLoader",
    "chat_loaders.facebook_messenger.SingleFileFacebookMessengerChatLoader",
    "chat_loaders.imessage.IMessageChatLoader",
    "chat_loaders.langsmith.LangSmithDatasetChatLoader",
    "chat_loaders.langsmith.LangSmithRunChatLoader",
    "chat_loaders.slack.SlackChatLoader",
    "chat_loaders.telegram.TelegramChatLoader",
    "chat_loaders.whatsapp.WhatsAppChatLoader",
    "chat_loaders.imessage.nanoseconds_from_2001_to_datetime",
    "chat_loaders.utils.map_ai_messages",
    "chat_loaders.utils.map_ai_messages_in_session",
    "chat_loaders.utils.merge_chat_runs",
    "chat_loaders.utils.merge_chat_runs_in_session",
    "chat_loaders.gmail.GMailLoader",
    "chat_message_histories.cassandra.CassandraChatMessageHistory",
    "chat_message_histories.cosmos_db.CosmosDBChatMessageHistory",
    "chat_message_histories.dynamodb.DynamoDBChatMessageHistory",
    "chat_message_histories.file.FileChatMessageHistory",
    "chat_message_histories.firestore.FirestoreChatMessageHistory",
    "chat_message_histories.kafka.ConsumeStartPosition",
    "chat_message_histories.kafka.KafkaChatMessageHistory",
    "chat_message_histories.momento.MomentoChatMessageHistory",
    "chat_message_histories.redis.RedisChatMessageHistory",
    "chat_message_histories.rocksetdb.RocksetChatMessageHistory",
    "chat_message_histories.sql.BaseMessageConverter",
    "chat_message_histories.sql.DefaultMessageConverter",
    "chat_message_histories.sql.SQLChatMessageHistory",
    "chat_message_histories.streamlit.StreamlitChatMessageHistory",
    "chat_message_histories.tidb.TiDBChatMessageHistory",
    "chat_message_histories.upstash_redis.UpstashRedisChatMessageHistory",
    "chat_message_histories.xata.XataChatMessageHistory",
    "chat_message_histories.zep.SearchScope",
    "chat_message_histories.zep.SearchType",
    "chat_message_histories.zep.ZepChatMessageHistory",
    "chat_message_histories.zep_cloud.ZepCloudChatMessageHistory",
    "chat_message_histories.dynamodb.convert_messages",
    "chat_message_histories.kafka.ensure_topic_exists",
    "chat_message_histories.sql.create_message_model",
    "chat_message_histories.zep_cloud.condense_zep_memory_into_human_message",
    "chat_message_histories.zep_cloud.get_zep_message_role_type",
    "chat_message_histories.astradb.AstraDBChatMessageHistory",
    "chat_message_histories.elasticsearch.ElasticsearchChatMessageHistory",
    "chat_message_histories.mongodb.MongoDBChatMessageHistory",
    "chat_message_histories.neo4j.Neo4jChatMessageHistory",
    "chat_message_histories.postgres.PostgresChatMessageHistory",
    "chat_message_histories.singlestoredb.SingleStoreDBChatMessageHistory",
    "chat_models.anyscale.ChatAnyscale",
    "chat_models.azureml_endpoint.AzureMLChatOnlineEndpoint",
    "chat_models.azureml_endpoint.CustomOpenAIChatContentFormatter",
    "chat_models.azureml_endpoint.LlamaChatContentFormatter",
    "chat_models.azureml_endpoint.LlamaContentFormatter",
    "chat_models.azureml_endpoint.MistralChatContentFormatter",
    "chat_models.baichuan.ChatBaichuan",
    "chat_models.baidu_qianfan_endpoint.QianfanChatEndpoint",
    "chat_models.bedrock.ChatPromptAdapter",
    "chat_models.coze.ChatCoze",
    "chat_models.dappier.ChatDappierAI",
    "chat_models.deepinfra.ChatDeepInfra",
    "chat_models.deepinfra.ChatDeepInfraException",
    "chat_models.edenai.ChatEdenAI",
    "chat_models.everlyai.ChatEverlyAI",
    "chat_models.fake.FakeListChatModel",
    "chat_models.fake.FakeMessagesListChatModel",
    "chat_models.friendli.ChatFriendli",
    "chat_models.google_palm.ChatGooglePalm",
    "chat_models.google_palm.ChatGooglePalmError",
    "chat_models.gpt_router.GPTRouter",
    "chat_models.gpt_router.GPTRouterException",
    "chat_models.gpt_router.GPTRouterModel",
    "chat_models.human.HumanInputChatModel",
    "chat_models.hunyuan.ChatHunyuan",
    "chat_models.javelin_ai_gateway.ChatJavelinAIGateway",
    "chat_models.javelin_ai_gateway.ChatParams",
    "chat_models.jinachat.JinaChat",
    "chat_models.kinetica.ChatKinetica",
    "chat_models.kinetica.KineticaSqlOutputParser",
    "chat_models.kinetica.KineticaSqlResponse",
    "chat_models.kinetica.KineticaUtil",
    "chat_models.konko.ChatKonko",
    "chat_models.litellm.ChatLiteLLMException",
    "chat_models.llama_edge.LlamaEdgeChatService",
    "chat_models.llamacpp.ChatLlamaCpp",
    "chat_models.maritalk.ChatMaritalk",
    "chat_models.maritalk.MaritalkHTTPError",
    "chat_models.minimax.MiniMaxChat",
    "chat_models.mlflow.ChatMlflow",
    "chat_models.mlflow_ai_gateway.ChatMLflowAIGateway",
    "chat_models.mlflow_ai_gateway.ChatParams",
    "chat_models.mlx.ChatMLX",
    "chat_models.moonshot.MoonshotChat",
    "chat_models.naver.ChatClovaX",
    "chat_models.oci_data_science.ChatOCIModelDeployment",
    "chat_models.oci_data_science.ChatOCIModelDeploymentTGI",
    "chat_models.oci_data_science.ChatOCIModelDeploymentVLLM",
    "chat_models.oci_generative_ai.ChatOCIGenAI",
    "chat_models.oci_generative_ai.CohereProvider",
    "chat_models.oci_generative_ai.MetaProvider",
    "chat_models.oci_generative_ai.Provider",
    "chat_models.octoai.ChatOctoAI",
    "chat_models.outlines.ChatOutlines",
    "chat_models.pai_eas_endpoint.PaiEasChatEndpoint",
    "chat_models.premai.ChatPremAI",
    "chat_models.premai.ChatPremAPIError",
    "chat_models.promptlayer_openai.PromptLayerChatOpenAI",
    "chat_models.reka.ChatReka",
    "chat_models.snowflake.ChatSnowflakeCortex",
    "chat_models.snowflake.ChatSnowflakeCortexError",
    "chat_models.sparkllm.ChatSparkLLM",
    "chat_models.symblai_nebula.ChatNebula",
    "chat_models.tongyi.ChatTongyi",
    "chat_models.volcengine_maas.VolcEngineMaasChat",
    "chat_models.writer.ChatWriter",
    "chat_models.yandex.ChatYandexGPT",
    "chat_models.yi.ChatYi",
    "chat_models.yuan2.ChatYuan2",
    "chat_models.zhipuai.ChatZhipuAI",
    "chat_models.anthropic.convert_messages_to_prompt_anthropic",
    "chat_models.baichuan.aconnect_httpx_sse",
    "chat_models.baidu_qianfan_endpoint.convert_message_to_dict",
    "chat_models.bedrock.convert_messages_to_prompt_mistral",
    "chat_models.cohere.get_cohere_chat_request",
    "chat_models.cohere.get_role",
    "chat_models.fireworks.acompletion_with_retry",
    "chat_models.fireworks.acompletion_with_retry_streaming",
    "chat_models.fireworks.completion_with_retry",
    "chat_models.fireworks.conditional_decorator",
    "chat_models.fireworks.convert_dict_to_message",
    "chat_models.friendli.get_chat_request",
    "chat_models.friendli.get_role",
    "chat_models.google_palm.achat_with_retry",
    "chat_models.google_palm.chat_with_retry",
    "chat_models.gpt_router.acompletion_with_retry",
    "chat_models.gpt_router.completion_with_retry",
    "chat_models.gpt_router.get_ordered_generation_requests",
    "chat_models.jinachat.acompletion_with_retry",
    "chat_models.litellm.acompletion_with_retry",
    "chat_models.litellm_router.get_llm_output",
    "chat_models.meta.convert_messages_to_prompt_llama",
    "chat_models.minimax.aconnect_httpx_sse",
    "chat_models.minimax.connect_httpx_sse",
    "chat_models.openai.acompletion_with_retry",
    "chat_models.premai.chat_with_retry",
    "chat_models.premai.create_prem_retry_decorator",
    "chat_models.reka.convert_to_reka_messages",
    "chat_models.reka.process_content",
    "chat_models.reka.process_content_item",
    "chat_models.sparkllm.convert_dict_to_message",
    "chat_models.sparkllm.convert_message_to_dict",
    "chat_models.tongyi.convert_dict_to_message",
    "chat_models.tongyi.convert_message_chunk_to_message",
    "chat_models.tongyi.convert_message_to_dict",
    "chat_models.volcengine_maas.convert_dict_to_message",
    "chat_models.yandex.acompletion_with_retry",
    "chat_models.yandex.completion_with_retry",
    "chat_models.yi.aconnect_httpx_sse",
    "chat_models.yuan2.acompletion_with_retry",
    "chat_models.zhipuai.aconnect_sse",
    "chat_models.zhipuai.connect_sse",
    "chat_models.anthropic.ChatAnthropic",
    "chat_models.azure_openai.AzureChatOpenAI",
    "chat_models.bedrock.BedrockChat",
    "chat_models.cloudflare_workersai.ChatCloudflareWorkersAI",
    "chat_models.cohere.ChatCohere",
    "chat_models.databricks.ChatDatabricks",
    "chat_models.ernie.ErnieBotChat",
    "chat_models.fireworks.ChatFireworks",
    "chat_models.gigachat.GigaChat",
    "chat_models.huggingface.ChatHuggingFace",
    "chat_models.litellm.ChatLiteLLM",
    "chat_models.litellm_router.ChatLiteLLMRouter",
    "chat_models.ollama.ChatOllama",
    "chat_models.openai.ChatOpenAI",
    "chat_models.perplexity.ChatPerplexity",
    "chat_models.sambanova.ChatSambaNovaCloud",
    "chat_models.sambanova.ChatSambaStudio",
    "chat_models.solar.SolarChat",
    "chat_models.vertexai.ChatVertexAI",
    "cross_encoders.fake.FakeCrossEncoder",
    "cross_encoders.huggingface.HuggingFaceCrossEncoder",
    "cross_encoders.sagemaker_endpoint.CrossEncoderContentHandler",
    "cross_encoders.sagemaker_endpoint.SagemakerEndpointCrossEncoder",
    "docstore.arbitrary_fn.DocstoreFn",
    "docstore.base.AddableMixin",
    "docstore.base.Docstore",
    "docstore.in_memory.InMemoryDocstore",
    "docstore.wikipedia.Wikipedia",
    "document_compressors.dashscope_rerank.DashScopeRerank",
    "document_compressors.flashrank_rerank.FlashrankRerank",
    "document_compressors.infinity_rerank.InfinityRerank",
    "document_compressors.jina_rerank.JinaRerank",
    "document_compressors.llmlingua_filter.LLMLinguaCompressor",
    "document_compressors.openvino_rerank.OpenVINOReranker",
    "document_compressors.openvino_rerank.RerankRequest",
    "document_compressors.rankllm_rerank.ModelType",
    "document_compressors.rankllm_rerank.RankLLMRerank",
    "document_compressors.volcengine_rerank.VolcengineRerank",
    "document_loaders.acreom.AcreomLoader",
    "document_loaders.airbyte.AirbyteCDKLoader",
    "document_loaders.airbyte.AirbyteGongLoader",
    "document_loaders.airbyte.AirbyteHubspotLoader",
    "document_loaders.airbyte.AirbyteSalesforceLoader",
    "document_loaders.airbyte.AirbyteShopifyLoader",
    "document_loaders.airbyte.AirbyteStripeLoader",
    "document_loaders.airbyte.AirbyteTypeformLoader",
    "document_loaders.airbyte.AirbyteZendeskSupportLoader",
    "document_loaders.airbyte_json.AirbyteJSONLoader",
    "document_loaders.airtable.AirtableLoader",
    "document_loaders.arcgis_loader.ArcGISLoader",
    "document_loaders.arxiv.ArxivLoader",
    "document_loaders.assemblyai.AssemblyAIAudioLoaderById",
    "document_loaders.assemblyai.AssemblyAIAudioTranscriptLoader",
    "document_loaders.assemblyai.TranscriptFormat",
    "document_loaders.async_html.AsyncHtmlLoader",
    "document_loaders.athena.AthenaLoader",
    "document_loaders.azlyrics.AZLyricsLoader",
    "document_loaders.azure_ai_data.AzureAIDataLoader",
    "document_loaders.azure_blob_storage_container.AzureBlobStorageContainerLoader",
    "document_loaders.azure_blob_storage_file.AzureBlobStorageFileLoader",
    "document_loaders.baiducloud_bos_directory.BaiduBOSDirectoryLoader",
    "document_loaders.baiducloud_bos_file.BaiduBOSFileLoader",
    "document_loaders.base_o365.O365BaseLoader",
    "document_loaders.bibtex.BibtexLoader",
    "document_loaders.bilibili.BiliBiliLoader",
    "document_loaders.blackboard.BlackboardLoader",
    "document_loaders.blob_loaders.cloud_blob_loader.CloudBlobLoader",
    "document_loaders.blob_loaders.file_system.FileSystemBlobLoader",
    "document_loaders.blob_loaders.youtube_audio.YoutubeAudioLoader",
    "document_loaders.blockchain.BlockchainDocumentLoader",
    "document_loaders.blockchain.BlockchainType",
    "document_loaders.brave_search.BraveSearchLoader",
    "document_loaders.browserbase.BrowserbaseLoader",
    "document_loaders.browserless.BrowserlessLoader",
    "document_loaders.cassandra.CassandraLoader",
    "document_loaders.chatgpt.ChatGPTLoader",
    "document_loaders.chm.CHMParser",
    "document_loaders.chm.UnstructuredCHMLoader",
    "document_loaders.chromium.AsyncChromiumLoader",
    "document_loaders.college_confidential.CollegeConfidentialLoader",
    "document_loaders.concurrent.ConcurrentLoader",
    "document_loaders.confluence.ConfluenceLoader",
    "document_loaders.confluence.ContentFormat",
    "document_loaders.conllu.CoNLLULoader",
    "document_loaders.couchbase.CouchbaseLoader",
    "document_loaders.csv_loader.CSVLoader",
    "document_loaders.csv_loader.UnstructuredCSVLoader",
    "document_loaders.cube_semantic.CubeSemanticLoader",
    "document_loaders.datadog_logs.DatadogLogsLoader",
    "document_loaders.dataframe.BaseDataFrameLoader",
    "document_loaders.dataframe.DataFrameLoader",
    "document_loaders.dedoc.DedocAPIFileLoader",
    "document_loaders.dedoc.DedocBaseLoader",
    "document_loaders.dedoc.DedocFileLoader",
    "document_loaders.diffbot.DiffbotLoader",
    "document_loaders.directory.DirectoryLoader",
    "document_loaders.discord.DiscordChatLoader",
    "document_loaders.doc_intelligence.AzureAIDocumentIntelligenceLoader",
    "document_loaders.docusaurus.DocusaurusLoader",
    "document_loaders.dropbox.DropboxLoader",
    "document_loaders.duckdb_loader.DuckDBLoader",
    "document_loaders.email.OutlookMessageLoader",
    "document_loaders.email.UnstructuredEmailLoader",
    "document_loaders.epub.UnstructuredEPubLoader",
    "document_loaders.etherscan.EtherscanLoader",
    "document_loaders.evernote.EverNoteLoader",
    "document_loaders.excel.UnstructuredExcelLoader",
    "document_loaders.facebook_chat.FacebookChatLoader",
    "document_loaders.fauna.FaunaLoader",
    "document_loaders.figma.FigmaFileLoader",
    "document_loaders.firecrawl.FireCrawlLoader",
    "document_loaders.generic.GenericLoader",
    "document_loaders.geodataframe.GeoDataFrameLoader",
    "document_loaders.git.GitLoader",
    "document_loaders.gitbook.GitbookLoader",
    "document_loaders.github.BaseGitHubLoader",
    "document_loaders.github.GitHubIssuesLoader",
    "document_loaders.github.GithubFileLoader",
    "document_loaders.glue_catalog.GlueCatalogLoader",
    "document_loaders.gutenberg.GutenbergLoader",
    "document_loaders.helpers.FileEncoding",
    "document_loaders.hn.HNLoader",
    "document_loaders.html.UnstructuredHTMLLoader",
    "document_loaders.html_bs.BSHTMLLoader",
    "document_loaders.hugging_face_dataset.HuggingFaceDatasetLoader",
    "document_loaders.hugging_face_model.HuggingFaceModelLoader",
    "document_loaders.ifixit.IFixitLoader",
    "document_loaders.image.UnstructuredImageLoader",
    "document_loaders.image_captions.ImageCaptionLoader",
    "document_loaders.imsdb.IMSDbLoader",
    "document_loaders.iugu.IuguLoader",
    "document_loaders.joplin.JoplinLoader",
    "document_loaders.json_loader.JSONLoader",
    "document_loaders.kinetica_loader.KineticaLoader",
    "document_loaders.lakefs.LakeFSClient",
    "document_loaders.lakefs.LakeFSLoader",
    "document_loaders.lakefs.UnstructuredLakeFSLoader",
    "document_loaders.larksuite.LarkSuiteDocLoader",
    "document_loaders.larksuite.LarkSuiteWikiLoader",
    "document_loaders.llmsherpa.LLMSherpaFileLoader",
    "document_loaders.markdown.UnstructuredMarkdownLoader",
    "document_loaders.mastodon.MastodonTootsLoader",
    "document_loaders.max_compute.MaxComputeLoader",
    "document_loaders.mediawikidump.MWDumpLoader",
    "document_loaders.merge.MergedDataLoader",
    "document_loaders.mhtml.MHTMLLoader",
    "document_loaders.mintbase.MintbaseDocumentLoader",
    "document_loaders.modern_treasury.ModernTreasuryLoader",
    "document_loaders.mongodb.MongodbLoader",
    "document_loaders.needle.NeedleLoader",
    "document_loaders.news.NewsURLLoader",
    "document_loaders.notebook.NotebookLoader",
    "document_loaders.notion.NotionDirectoryLoader",
    "document_loaders.notiondb.NotionDBLoader",
    "document_loaders.nuclia.NucliaLoader",
    "document_loaders.obs_directory.OBSDirectoryLoader",
    "document_loaders.obs_file.OBSFileLoader",
    "document_loaders.obsidian.ObsidianLoader",
    "document_loaders.odt.UnstructuredODTLoader",
    "document_loaders.onedrive.OneDriveLoader",
    "document_loaders.onedrive_file.OneDriveFileLoader",
    "document_loaders.onenote.OneNoteLoader",
    "document_loaders.open_city_data.OpenCityDataLoader",
    "document_loaders.oracleadb_loader.OracleAutonomousDatabaseLoader",
    "document_loaders.oracleai.OracleDocLoader",
    "document_loaders.oracleai.OracleDocReader",
    "document_loaders.oracleai.OracleTextSplitter",
    "document_loaders.oracleai.ParseOracleDocMetadata",
    "document_loaders.org_mode.UnstructuredOrgModeLoader",
    "document_loaders.parsers.audio.AzureOpenAIWhisperParser",
    "document_loaders.parsers.audio.FasterWhisperParser",
    "document_loaders.parsers.audio.OpenAIWhisperParser",
    "document_loaders.parsers.audio.OpenAIWhisperParserLocal",
    "document_loaders.parsers.audio.YandexSTTParser",
    "document_loaders.parsers.doc_intelligence.AzureAIDocumentIntelligenceParser",
    "document_loaders.parsers.docai.DocAIParsingResults",
    "document_loaders.parsers.documentloader_adapter.DocumentLoaderAsParser",
    "document_loaders.parsers.generic.MimeTypeBasedParser",
    "document_loaders.parsers.grobid.GrobidParser",
    "document_loaders.parsers.grobid.ServerUnavailableException",
    "document_loaders.parsers.html.bs4.BS4HTMLParser",
    "document_loaders.parsers.images.BaseImageBlobParser",
    "document_loaders.parsers.images.LLMImageBlobParser",
    "document_loaders.parsers.images.RapidOCRBlobParser",
    "document_loaders.parsers.images.TesseractBlobParser",
    "document_loaders.parsers.language.c.CSegmenter",
    "document_loaders.parsers.language.cobol.CobolSegmenter",
    "document_loaders.parsers.language.code_segmenter.CodeSegmenter",
    "document_loaders.parsers.language.cpp.CPPSegmenter",
    "document_loaders.parsers.language.csharp.CSharpSegmenter",
    "document_loaders.parsers.language.elixir.ElixirSegmenter",
    "document_loaders.parsers.language.go.GoSegmenter",
    "document_loaders.parsers.language.java.JavaSegmenter",
    "document_loaders.parsers.language.javascript.JavaScriptSegmenter",
    "document_loaders.parsers.language.kotlin.KotlinSegmenter",
    "document_loaders.parsers.language.language_parser.LanguageParser",
    "document_loaders.parsers.language.lua.LuaSegmenter",
    "document_loaders.parsers.language.perl.PerlSegmenter",
    "document_loaders.parsers.language.php.PHPSegmenter",
    "document_loaders.parsers.language.python.PythonSegmenter",
    "document_loaders.parsers.language.ruby.RubySegmenter",
    "document_loaders.parsers.language.rust.RustSegmenter",
    "document_loaders.parsers.language.scala.ScalaSegmenter",
    "document_loaders.parsers.language.sql.SQLSegmenter",
    "document_loaders.parsers.language.tree_sitter_segmenter.TreeSitterSegmenter",
    "document_loaders.parsers.language.typescript.TypeScriptSegmenter",
    "document_loaders.parsers.msword.MsWordParser",
    "document_loaders.parsers.pdf.AmazonTextractPDFParser",
    "document_loaders.parsers.pdf.DocumentIntelligenceParser",
    "document_loaders.parsers.pdf.PDFMinerParser",
    "document_loaders.parsers.pdf.PDFPlumberParser",
    "document_loaders.parsers.pdf.PyMuPDFParser",
    "document_loaders.parsers.pdf.PyPDFParser",
    "document_loaders.parsers.pdf.PyPDFium2Parser",
    "document_loaders.parsers.txt.TextParser",
    "document_loaders.parsers.vsdx.VsdxParser",
    "document_loaders.pdf.AmazonTextractPDFLoader",
    "document_loaders.pdf.BasePDFLoader",
    "document_loaders.pdf.DedocPDFLoader",
    "document_loaders.pdf.DocumentIntelligenceLoader",
    "document_loaders.pdf.MathpixPDFLoader",
    "document_loaders.pdf.OnlinePDFLoader",
    "document_loaders.pdf.PDFMinerLoader",
    "document_loaders.pdf.PDFMinerPDFasHTMLLoader",
    "document_loaders.pdf.PDFPlumberLoader",
    "document_loaders.pdf.PagedPDFSplitter",
    "PyPDFLoader",
    "document_loaders.pdf.PyMuPDFLoader",
    "document_loaders.pdf.PyPDFDirectoryLoader",
    "document_loaders.pdf.PyPDFLoader",
    "document_loaders.pdf.PyPDFium2Loader",
    "document_loaders.pdf.UnstructuredPDFLoader",
    "document_loaders.pdf.ZeroxPDFLoader",
    "document_loaders.pebblo.PebbloSafeLoader",
    "document_loaders.pebblo.PebbloTextLoader",
    "document_loaders.polars_dataframe.PolarsDataFrameLoader",
    "document_loaders.powerpoint.UnstructuredPowerPointLoader",
    "document_loaders.psychic.PsychicLoader",
    "document_loaders.pubmed.PubMedLoader",
    "document_loaders.pyspark_dataframe.PySparkDataFrameLoader",
    "document_loaders.python.PythonLoader",
    "document_loaders.quip.QuipLoader",
    "document_loaders.readthedocs.ReadTheDocsLoader",
    "document_loaders.recursive_url_loader.RecursiveUrlLoader",
    "document_loaders.reddit.RedditPostsLoader",
    "document_loaders.roam.RoamLoader",
    "document_loaders.rocksetdb.ColumnNotFoundError",
    "document_loaders.rocksetdb.RocksetLoader",
    "document_loaders.rspace.RSpaceLoader",
    "document_loaders.rss.RSSFeedLoader",
    "document_loaders.rst.UnstructuredRSTLoader",
    "document_loaders.rtf.UnstructuredRTFLoader",
    "document_loaders.s3_directory.S3DirectoryLoader",
    "document_loaders.s3_file.S3FileLoader",
    "document_loaders.scrapfly.ScrapflyLoader",
    "document_loaders.scrapingant.ScrapingAntLoader",
    "document_loaders.sharepoint.SharePointLoader",
    "document_loaders.sitemap.SitemapLoader",
    "document_loaders.slack_directory.SlackDirectoryLoader",
    "document_loaders.snowflake_loader.SnowflakeLoader",
    "document_loaders.spider.SpiderLoader",
    "document_loaders.spreedly.SpreedlyLoader",
    "document_loaders.sql_database.SQLDatabaseLoader",
    "document_loaders.srt.SRTLoader",
    "document_loaders.stripe.StripeLoader",
    "document_loaders.surrealdb.SurrealDBLoader",
    "document_loaders.telegram.TelegramChatApiLoader",
    "document_loaders.telegram.TelegramChatFileLoader",
    "document_loaders.telegram.TelegramChatLoader",
    "TelegramChatFileLoader",
    "document_loaders.tencent_cos_directory.TencentCOSDirectoryLoader",
    "document_loaders.tencent_cos_file.TencentCOSFileLoader",
    "document_loaders.tensorflow_datasets.TensorflowDatasetLoader",
    "document_loaders.text.TextLoader",
    "document_loaders.tidb.TiDBLoader",
    "document_loaders.tomarkdown.ToMarkdownLoader",
    "document_loaders.toml.TomlLoader",
    "document_loaders.trello.TrelloLoader",
    "document_loaders.tsv.UnstructuredTSVLoader",
    "document_loaders.twitter.TwitterTweetLoader",
    "document_loaders.unstructured.UnstructuredBaseLoader",
    "document_loaders.url.UnstructuredURLLoader",
    "document_loaders.url_playwright.PlaywrightEvaluator",
    "document_loaders.url_playwright.PlaywrightURLLoader",
    "document_loaders.url_playwright.UnstructuredHtmlEvaluator",
    "document_loaders.url_selenium.SeleniumURLLoader",
    "document_loaders.vsdx.VsdxLoader",
    "document_loaders.weather.WeatherDataLoader",
    "document_loaders.web_base.WebBaseLoader",
    "document_loaders.whatsapp_chat.WhatsAppChatLoader",
    "document_loaders.wikipedia.WikipediaLoader",
    "document_loaders.word_document.Docx2txtLoader",
    "document_loaders.word_document.UnstructuredWordDocumentLoader",
    "document_loaders.xml.UnstructuredXMLLoader",
    "document_loaders.xorbits.XorbitsLoader",
    "document_loaders.youtube.GoogleApiClient",
    "document_loaders.youtube.GoogleApiYoutubeLoader",
    "document_loaders.youtube.TranscriptFormat",
    "document_loaders.youtube.YoutubeLoader",
    "document_loaders.yuque.YuqueLoader",
    "document_loaders.base_o365.fetch_extensions",
    "document_loaders.base_o365.fetch_mime_types",
    "document_loaders.chatgpt.concatenate_rows",
    "document_loaders.facebook_chat.concatenate_rows",
    "document_loaders.helpers.detect_file_encodings",
    "document_loaders.notebook.concatenate_cells",
    "document_loaders.notebook.remove_newlines",
    "document_loaders.parsers.pdf.extract_from_images_with_rapidocr",
    "document_loaders.parsers.registry.get_parser",
    "document_loaders.rocksetdb.default_joiner",
    "document_loaders.telegram.concatenate_rows",
    "document_loaders.telegram.text_to_docs",
    "document_loaders.unstructured.get_elements_from_api",
    "document_loaders.unstructured.satisfies_min_unstructured_version",
    "document_loaders.unstructured.validate_unstructured_version",
    "document_loaders.whatsapp_chat.concatenate_rows",
    "document_loaders.apify_dataset.ApifyDatasetLoader",
    "document_loaders.astradb.AstraDBLoader",
    "document_loaders.bigquery.BigQueryLoader",
    "document_loaders.docugami.DocugamiLoader",
    "document_loaders.gcs_directory.GCSDirectoryLoader",
    "document_loaders.gcs_file.GCSFileLoader",
    "document_loaders.google_speech_to_text.GoogleSpeechToTextLoader",
    "document_loaders.googledrive.GoogleDriveLoader",
    "document_loaders.parsers.docai.DocAIParser",
    "document_loaders.unstructured.UnstructuredAPIFileIOLoader",
    "document_loaders.unstructured.UnstructuredAPIFileLoader",
    "document_loaders.unstructured.UnstructuredFileIOLoader",
    "document_loaders.unstructured.UnstructuredFileLoader",
    "document_transformers.beautiful_soup_transformer.BeautifulSoupTransformer",
    "document_transformers.doctran_text_extract.DoctranPropertyExtractor",
    "document_transformers.doctran_text_qa.DoctranQATransformer",
    "document_transformers.doctran_text_translate.DoctranTextTranslator",
    "document_transformers.embeddings_redundant_filter.EmbeddingsClusteringFilter",
    "document_transformers.embeddings_redundant_filter.EmbeddingsRedundantFilter",
    "document_transformers.html2text.Html2TextTransformer",
    "document_transformers.long_context_reorder.LongContextReorder",
    "document_transformers.markdownify.MarkdownifyTransformer",
    "document_transformers.nuclia_text_transform.NucliaTextTransformer",
    "document_transformers.openai_functions.OpenAIMetadataTagger",
    "document_transformers.beautiful_soup_transformer.get_navigable_strings",
    "document_transformers.embeddings_redundant_filter.get_stateful_documents",
    "document_transformers.openai_functions.create_metadata_tagger",
    "document_transformers.google_translate.GoogleTranslateTransformer",
    "embeddings.aleph_alpha.AlephAlphaAsymmetricSemanticEmbedding",
    "embeddings.aleph_alpha.AlephAlphaSymmetricSemanticEmbedding",
    "embeddings.anyscale.AnyscaleEmbeddings",
    "embeddings.ascend.AscendEmbeddings",
    "embeddings.awa.AwaEmbeddings",
    "embeddings.baichuan.BaichuanTextEmbeddings",
    "embeddings.baidu_qianfan_endpoint.QianfanEmbeddingsEndpoint",
    "embeddings.bookend.BookendEmbeddings",
    "embeddings.clarifai.ClarifaiEmbeddings",
    "embeddings.dashscope.DashScopeEmbeddings",
    "embeddings.deepinfra.DeepInfraEmbeddings",
    "embeddings.edenai.EdenAiEmbeddings",
    "embeddings.embaas.EmbaasEmbeddings",
    "embeddings.embaas.EmbaasEmbeddingsPayload",
    "embeddings.fake.DeterministicFakeEmbedding",
    "embeddings.fake.FakeEmbeddings",
    "embeddings.fastembed.FastEmbedEmbeddings",
    "embeddings.google_palm.GooglePalmEmbeddings",
    "embeddings.gpt4all.GPT4AllEmbeddings",
    "embeddings.gradient_ai.GradientEmbeddings",
    "embeddings.gradient_ai.TinyAsyncGradientEmbeddingClient",
    "embeddings.hunyuan.HunyuanEmbeddings",
    "embeddings.infinity.InfinityEmbeddings",
    "embeddings.infinity.TinyAsyncOpenAIInfinityEmbeddingClient",
    "embeddings.infinity_local.InfinityEmbeddingsLocal",
    "embeddings.ipex_llm.IpexLLMBgeEmbeddings",
    "embeddings.itrex.QuantizedBgeEmbeddings",
    "embeddings.javelin_ai_gateway.JavelinAIGatewayEmbeddings",
    "embeddings.jina.JinaEmbeddings",
    "embeddings.johnsnowlabs.JohnSnowLabsEmbeddings",
    "embeddings.laser.LaserEmbeddings",
    "embeddings.llamacpp.LlamaCppEmbeddings",
    "embeddings.llamafile.LlamafileEmbeddings",
    "embeddings.llm_rails.LLMRailsEmbeddings",
    "embeddings.localai.LocalAIEmbeddings",
    "embeddings.minimax.MiniMaxEmbeddings",
    "embeddings.mlflow.MlflowCohereEmbeddings",
    "embeddings.mlflow.MlflowEmbeddings",
    "embeddings.mlflow_gateway.MlflowAIGatewayEmbeddings",
    "embeddings.model2vec.Model2vecEmbeddings",
    "embeddings.modelscope_hub.ModelScopeEmbeddings",
    "embeddings.mosaicml.MosaicMLInstructorEmbeddings",
    "embeddings.naver.ClovaXEmbeddings",
    "embeddings.nlpcloud.NLPCloudEmbeddings",
    "embeddings.oci_generative_ai.OCIAuthType",
    "embeddings.oci_generative_ai.OCIGenAIEmbeddings",
    "embeddings.octoai_embeddings.OctoAIEmbeddings",
    "embeddings.openvino.OpenVINOBgeEmbeddings",
    "embeddings.openvino.OpenVINOEmbeddings",
    "embeddings.optimum_intel.QuantizedBiEncoderEmbeddings",
    "embeddings.oracleai.OracleEmbeddings",
    "embeddings.ovhcloud.OVHCloudEmbeddings",
    "embeddings.premai.PremAIEmbeddings",
    "embeddings.sagemaker_endpoint.EmbeddingsContentHandler",
    "embeddings.sagemaker_endpoint.SagemakerEndpointEmbeddings",
    "embeddings.self_hosted.SelfHostedEmbeddings",
    "embeddings.self_hosted_hugging_face.SelfHostedHuggingFaceEmbeddings",
    "embeddings.self_hosted_hugging_face.SelfHostedHuggingFaceInstructEmbeddings",
    "embeddings.spacy_embeddings.SpacyEmbeddings",
    "embeddings.sparkllm.AssembleHeaderException",
    "embeddings.sparkllm.SparkLLMTextEmbeddings",
    "embeddings.sparkllm.Url",
    "embeddings.tensorflow_hub.TensorflowHubEmbeddings",
    "embeddings.text2vec.Text2vecEmbeddings",
    "embeddings.textembed.AsyncOpenAITextEmbedEmbeddingClient",
    "embeddings.textembed.TextEmbedEmbeddings",
    "embeddings.titan_takeoff.Device",
    "embeddings.titan_takeoff.MissingConsumerGroup",
    "embeddings.titan_takeoff.ReaderConfig",
    "embeddings.titan_takeoff.TakeoffEmbeddingException",
    "embeddings.titan_takeoff.TitanTakeoffEmbed",
    "embeddings.volcengine.VolcanoEmbeddings",
    "embeddings.xinference.XinferenceEmbeddings",
    "embeddings.yandex.YandexGPTEmbeddings",
    "embeddings.zhipuai.ZhipuAIEmbeddings",
    "embeddings.dashscope.embed_with_retry",
    "embeddings.google_palm.embed_with_retry",
    "embeddings.jina.get_bytes_str",
    "embeddings.jina.is_local",
    "embeddings.localai.async_embed_with_retry",
    "embeddings.localai.embed_with_retry",
    "embeddings.minimax.embed_with_retry",
    "embeddings.nemo.is_endpoint_live",
    "embeddings.openai.async_embed_with_retry",
    "embeddings.openai.embed_with_retry",
    "embeddings.premai.create_prem_retry_decorator",
    "embeddings.premai.embed_with_retry",
    "embeddings.self_hosted_hugging_face.load_embedding_model",
    "embeddings.solar.embed_with_retry",
    "embeddings.voyageai.embed_with_retry",
    "embeddings.azure_openai.AzureOpenAIEmbeddings",
    "embeddings.bedrock.BedrockEmbeddings",
    "embeddings.cloudflare_workersai.CloudflareWorkersAIEmbeddings",
    "embeddings.clova.ClovaEmbeddings",
    "embeddings.cohere.CohereEmbeddings",
    "embeddings.databricks.DatabricksEmbeddings",
    "embeddings.elasticsearch.ElasticsearchEmbeddings",
    "embeddings.ernie.ErnieEmbeddings",
    "embeddings.gigachat.GigaChatEmbeddings",
    "embeddings.huggingface.HuggingFaceBgeEmbeddings",
    "embeddings.huggingface.HuggingFaceEmbeddings",
    "embeddings.huggingface.HuggingFaceInferenceAPIEmbeddings",
    "embeddings.huggingface.HuggingFaceInstructEmbeddings",
    "embeddings.huggingface_hub.HuggingFaceHubEmbeddings",
    "embeddings.nemo.NeMoEmbeddings",
    "embeddings.ollama.OllamaEmbeddings",
    "embeddings.openai.OpenAIEmbeddings",
    "embeddings.sambanova.SambaStudioEmbeddings",
    "embeddings.solar.SolarEmbeddings",
    "embeddings.vertexai.VertexAIEmbeddings",
    "embeddings.voyageai.VoyageEmbeddings",
    "example_selectors.ngram_overlap.NGramOverlapExampleSelector",
    "example_selectors.ngram_overlap.ngram_overlap_score",
    "graph_vectorstores.cassandra.AdjacentNode",
    "graph_vectorstores.cassandra.CassandraGraphVectorStore",
    "graph_vectorstores.extractors.gliner_link_extractor.GLiNERLinkExtractor",
    "graph_vectorstores.extractors.hierarchy_link_extractor.HierarchyLinkExtractor",
    "graph_vectorstores.extractors.html_link_extractor.HtmlInput",
    "graph_vectorstores.extractors.html_link_extractor.HtmlLinkExtractor",
    "graph_vectorstores.extractors.keybert_link_extractor.KeybertLinkExtractor",
    "graph_vectorstores.extractors.link_extractor.LinkExtractor",
    "graph_vectorstores.extractors.link_extractor_adapter.LinkExtractorAdapter",
    "graph_vectorstores.extractors.link_extractor_transformer.LinkExtractorTransformer",
    "graph_vectorstores.links.Link",
    "graph_vectorstores.mmr_helper.MmrHelper",
    "graph_vectorstores.links.add_links",
    "graph_vectorstores.links.copy_with_links",
    "graph_vectorstores.links.get_links",
    "graph_vectorstores.networkx.documents_to_networkx",
    "graph_vectorstores.visualize.render_graphviz",
    "graph_vectorstores.base.GraphVectorStore",
    "graph_vectorstores.base.GraphVectorStoreRetriever",
    "graph_vectorstores.base.Node",
    "graph_vectorstores.base.nodes_to_documents",
    "graphs.age_graph.AGEGraph",
    "graphs.age_graph.AGEQueryException",
    "graphs.arangodb_graph.ArangoGraph",
    "graphs.falkordb_graph.FalkorDBGraph",
    "graphs.graph_document.GraphDocument",
    "graphs.graph_document.Node",
    "graphs.graph_document.Relationship",
    "graphs.graph_store.GraphStore",
    "graphs.gremlin_graph.GremlinGraph",
    "graphs.hugegraph.HugeGraph",
    "graphs.index_creator.GraphIndexCreator",
    "graphs.kuzu_graph.KuzuGraph",
    "graphs.memgraph_graph.MemgraphGraph",
    "graphs.nebula_graph.NebulaGraph",
    "graphs.neptune_graph.BaseNeptuneGraph",
    "graphs.neptune_graph.NeptuneQueryException",
    "graphs.networkx_graph.KnowledgeTriple",
    "graphs.networkx_graph.NetworkxEntityGraph",
    "graphs.ontotext_graphdb_graph.OntotextGraphDBGraph",
    "graphs.rdf_graph.RdfGraph",
    "graphs.tigergraph_graph.TigerGraph",
    "graphs.arangodb_graph.get_arangodb_client",
    "graphs.memgraph_graph.get_reformated_schema",
    "graphs.memgraph_graph.get_schema_subset",
    "graphs.memgraph_graph.transform_schema_to_text",
    "graphs.networkx_graph.get_entities",
    "graphs.networkx_graph.parse_triples",
    "graphs.neo4j_graph.Neo4jGraph",
    "graphs.neptune_graph.NeptuneAnalyticsGraph",
    "graphs.neptune_graph.NeptuneGraph",
    "graphs.neptune_rdf_graph.NeptuneRdfGraph",
    "graphs.neo4j_graph.clean_string_values",
    "graphs.neo4j_graph.value_sanitize",
    "indexes.base.RecordManager",
    "llms.ai21.AI21",
    "llms.ai21.AI21PenaltyData",
    "llms.aleph_alpha.AlephAlpha",
    "llms.amazon_api_gateway.AmazonAPIGateway",
    "llms.amazon_api_gateway.ContentHandlerAmazonAPIGateway",
    "llms.anyscale.Anyscale",
    "llms.aphrodite.Aphrodite",
    "llms.arcee.Arcee",
    "llms.aviary.Aviary",
    "llms.aviary.AviaryBackend",
    "llms.azureml_endpoint.AzureMLBaseEndpoint",
    "llms.azureml_endpoint.AzureMLEndpointApiType",
    "llms.azureml_endpoint.AzureMLEndpointClient",
    "llms.azureml_endpoint.AzureMLOnlineEndpoint",
    "llms.azureml_endpoint.ContentFormatterBase",
    "llms.azureml_endpoint.CustomOpenAIContentFormatter",
    "llms.azureml_endpoint.DollyContentFormatter",
    "llms.azureml_endpoint.GPT2ContentFormatter",
    "llms.azureml_endpoint.HFContentFormatter",
    "llms.azureml_endpoint.LlamaContentFormatter",
    "llms.azureml_endpoint.OSSContentFormatter",
    "llms.baichuan.BaichuanLLM",
    "llms.baidu_qianfan_endpoint.QianfanLLMEndpoint",
    "llms.bananadev.Banana",
    "llms.baseten.Baseten",
    "llms.beam.Beam",
    "llms.bedrock.BedrockBase",
    "llms.bedrock.LLMInputOutputAdapter",
    "llms.bigdl_llm.BigdlLLM",
    "llms.bittensor.NIBittensorLLM",
    "llms.cerebriumai.CerebriumAI",
    "llms.chatglm.ChatGLM",
    "llms.chatglm3.ChatGLM3",
    "llms.clarifai.Clarifai",
    "llms.cloudflare_workersai.CloudflareWorkersAI",
    "llms.ctransformers.CTransformers",
    "llms.ctranslate2.CTranslate2",
    "llms.deepinfra.DeepInfra",
    "llms.deepsparse.DeepSparse",
    "llms.edenai.EdenAI",
    "llms.exllamav2.ExLlamaV2",
    "llms.fake.FakeListLLM",
    "llms.fake.FakeStreamingListLLM",
    "llms.forefrontai.ForefrontAI",
    "llms.friendli.BaseFriendli",
    "llms.friendli.Friendli",
    "llms.gigachat.GigaChat",
    "llms.gooseai.GooseAI",
    "llms.gpt4all.GPT4All",
    "llms.gradient_ai.GradientLLM",
    "llms.gradient_ai.TrainResult",
    "llms.human.HumanInputLLM",
    "llms.ipex_llm.IpexLLM",
    "llms.javelin_ai_gateway.JavelinAIGateway",
    "llms.javelin_ai_gateway.Params",
    "llms.koboldai.KoboldApiLLM",
    "llms.konko.Konko",
    "llms.layerup_security.LayerupSecurity",
    "llms.llamacpp.LlamaCpp",
    "llms.llamafile.Llamafile",
    "llms.manifest.ManifestWrapper",
    "llms.minimax.Minimax",
    "llms.minimax.MinimaxCommon",
    "llms.mlflow.Mlflow",
    "llms.mlflow_ai_gateway.MlflowAIGateway",
    "llms.mlflow_ai_gateway.Params",
    "llms.mlx_pipeline.MLXPipeline",
    "llms.modal.Modal",
    "llms.moonshot.Moonshot",
    "llms.moonshot.MoonshotCommon",
    "llms.mosaicml.MosaicML",
    "llms.nlpcloud.NLPCloud",
    "llms.oci_data_science_model_deployment_endpoint.BaseOCIModelDeployment",
    "llms.oci_data_science_model_deployment_endpoint.OCIModelDeploymentLLM",
    "llms.oci_data_science_model_deployment_endpoint.OCIModelDeploymentTGI",
    "llms.oci_data_science_model_deployment_endpoint.OCIModelDeploymentVLLM",
    "llms.oci_data_science_model_deployment_endpoint.ServerError",
    "llms.oci_data_science_model_deployment_endpoint.TokenExpiredError",
    "llms.oci_generative_ai.CohereProvider",
    "llms.oci_generative_ai.MetaProvider",
    "llms.oci_generative_ai.OCIAuthType",
    "llms.oci_generative_ai.OCIGenAI",
    "llms.oci_generative_ai.OCIGenAIBase",
    "llms.oci_generative_ai.Provider",
    "llms.octoai_endpoint.OctoAIEndpoint",
    "llms.ollama.OllamaEndpointNotFoundError",
    "llms.opaqueprompts.OpaquePrompts",
    "llms.openai.BaseOpenAI",
    "llms.openllm.OpenLLM",
    "llms.openlm.OpenLM",
    "llms.outlines.Outlines",
    "llms.pai_eas_endpoint.PaiEasEndpoint",
    "llms.petals.Petals",
    "llms.pipelineai.PipelineAI",
    "llms.predibase.Predibase",
    "llms.promptlayer_openai.PromptLayerOpenAI",
    "llms.promptlayer_openai.PromptLayerOpenAIChat",
    "llms.replicate.Replicate",
    "llms.rwkv.RWKV",
    "llms.sagemaker_endpoint.ContentHandlerBase",
    "llms.sagemaker_endpoint.LLMContentHandler",
    "llms.sagemaker_endpoint.LineIterator",
    "llms.sambanova.SambaNovaCloud",
    "llms.sambanova.SambaStudio",
    "llms.self_hosted.SelfHostedPipeline",
    "llms.self_hosted_hugging_face.SelfHostedHuggingFaceLLM",
    "llms.solar.Solar",
    "llms.solar.SolarCommon",
    "llms.sparkllm.SparkLLM",
    "llms.stochasticai.StochasticAI",
    "llms.symblai_nebula.Nebula",
    "llms.textgen.TextGen",
    "llms.titan_takeoff.Device",
    "llms.titan_takeoff.ReaderConfig",
    "llms.titan_takeoff.TitanTakeoff",
    "llms.tongyi.Tongyi",
    "llms.vllm.VLLM",
    "llms.vllm.VLLMOpenAI",
    "llms.volcengine_maas.VolcEngineMaasBase",
    "llms.volcengine_maas.VolcEngineMaasLLM",
    "llms.weight_only_quantization.WeightOnlyQuantPipeline",
    "llms.writer.Writer",
    "llms.xinference.Xinference",
    "llms.yandex.YandexGPT",
    "llms.yi.YiLLM",
    "llms.you.You",
    "llms.yuan2.Yuan2",
    "llms.anyscale.create_llm_result",
    "llms.anyscale.update_token_usage",
    "llms.aviary.get_completions",
    "llms.aviary.get_models",
    "llms.cohere.acompletion_with_retry",
    "llms.cohere.completion_with_retry",
    "llms.databricks.get_default_api_token",
    "llms.databricks.get_default_host",
    "llms.databricks.get_repl_context",
    "llms.fireworks.acompletion_with_retry",
    "llms.fireworks.acompletion_with_retry_batching",
    "llms.fireworks.acompletion_with_retry_streaming",
    "llms.fireworks.completion_with_retry",
    "llms.fireworks.completion_with_retry_batching",
    "llms.fireworks.conditional_decorator",
    "llms.google_palm.completion_with_retry",
    "llms.koboldai.clean_url",
    "llms.layerup_security.default_guardrail_violation_handler",
    "llms.loading.load_llm",
    "llms.loading.load_llm_from_config",
    "llms.openai.acompletion_with_retry",
    "llms.openai.completion_with_retry",
    "llms.openai.update_token_usage",
    "llms.symblai_nebula.completion_with_retry",
    "llms.symblai_nebula.make_request",
    "llms.tongyi.agenerate_with_last_element_mark",
    "llms.tongyi.astream_generate_with_retry",
    "llms.tongyi.check_response",
    "llms.tongyi.generate_with_last_element_mark",
    "llms.tongyi.generate_with_retry",
    "llms.tongyi.stream_generate_with_retry",
    "llms.utils.enforce_stop_tokens",
    "llms.vertexai.acompletion_with_retry",
    "llms.vertexai.completion_with_retry",
    "llms.vertexai.is_codey_model",
    "llms.vertexai.is_gemini_model",
    "llms.yandex.acompletion_with_retry",
    "llms.yandex.completion_with_retry",
    "llms.anthropic.Anthropic",
    "llms.bedrock.Bedrock",
    "llms.cohere.BaseCohere",
    "llms.cohere.Cohere",
    "llms.databricks.Databricks",
    "llms.fireworks.Fireworks",
    "llms.google_palm.GooglePalm",
    "llms.huggingface_endpoint.HuggingFaceEndpoint",
    "llms.huggingface_hub.HuggingFaceHub",
    "llms.huggingface_pipeline.HuggingFacePipeline",
    "llms.huggingface_text_gen_inference.HuggingFaceTextGenInference",
    "llms.ollama.Ollama",
    "llms.openai.AzureOpenAI",
    "llms.openai.OpenAI",
    "llms.openai.OpenAIChat",
    "llms.predictionguard.PredictionGuard",
    "llms.sagemaker_endpoint.SagemakerEndpoint",
    "llms.together.Together",
    "llms.vertexai.VertexAI",
    "llms.vertexai.VertexAIModelGarden",
    "llms.watsonxllm.WatsonxLLM",
    "memory.kg.ConversationKGMemory",
    "memory.motorhead_memory.MotorheadMemory",
    "memory.zep_cloud_memory.ZepCloudMemory",
    "memory.zep_memory.ZepMemory",
    "output_parsers.ernie_functions.JsonKeyOutputFunctionsParser",
    "output_parsers.ernie_functions.JsonOutputFunctionsParser",
    "output_parsers.ernie_functions.OutputFunctionsParser",
    "output_parsers.ernie_functions.PydanticAttrOutputFunctionsParser",
    "output_parsers.ernie_functions.PydanticOutputFunctionsParser",
    "output_parsers.rail_parser.GuardrailsOutputParser",
    "query_constructors.astradb.AstraDBTranslator",
    "query_constructors.chroma.ChromaTranslator",
    "query_constructors.dashvector.DashvectorTranslator",
    "query_constructors.databricks_vector_search.DatabricksVectorSearchTranslator",
    "query_constructors.deeplake.DeepLakeTranslator",
    "query_constructors.dingo.DingoDBTranslator",
    "query_constructors.elasticsearch.ElasticsearchTranslator",
    "query_constructors.milvus.MilvusTranslator",
    "query_constructors.mongodb_atlas.MongoDBAtlasTranslator",
    "query_constructors.myscale.MyScaleTranslator",
    "query_constructors.opensearch.OpenSearchTranslator",
    "query_constructors.pgvector.PGVectorTranslator",
    "query_constructors.pinecone.PineconeTranslator",
    "query_constructors.qdrant.QdrantTranslator",
    "query_constructors.redis.RedisTranslator",
    "query_constructors.supabase.SupabaseVectorTranslator",
    "query_constructors.tencentvectordb.TencentVectorDBTranslator",
    "query_constructors.timescalevector.TimescaleVectorTranslator",
    "query_constructors.vectara.VectaraTranslator",
    "query_constructors.weaviate.WeaviateTranslator",
    "query_constructors.deeplake.can_cast_to_float",
    "query_constructors.milvus.process_value",
    "query_constructors.vectara.process_value",
    "query_constructors.hanavector.HanaTranslator",
    "query_constructors.neo4j.Neo4jTranslator",
    "retrievers.arcee.ArceeRetriever",
    "retrievers.arxiv.ArxivRetriever",
    "retrievers.asknews.AskNewsRetriever",
    "retrievers.azure_ai_search.AzureAISearchRetriever",
    "retrievers.azure_ai_search.AzureCognitiveSearchRetriever",
    "retrievers.bedrock.RetrievalConfig",
    "retrievers.bedrock.VectorSearchConfig",
    "retrievers.bm25.BM25Retriever",
    "retrievers.breebs.BreebsRetriever",
    "retrievers.chaindesk.ChaindeskRetriever",
    "retrievers.chatgpt_plugin_retriever.ChatGPTPluginRetriever",
    "retrievers.databerry.DataberryRetriever",
    "retrievers.docarray.DocArrayRetriever",
    "retrievers.docarray.SearchType",
    "retrievers.dria_index.DriaRetriever",
    "retrievers.elastic_search_bm25.ElasticSearchBM25Retriever",
    "retrievers.embedchain.EmbedchainRetriever",
    "retrievers.google_vertex_ai_search.GoogleCloudEnterpriseSearchRetriever",
    "retrievers.kay.KayAiRetriever",
    "retrievers.kendra.AdditionalResultAttribute",
    "retrievers.kendra.AdditionalResultAttributeValue",
    "retrievers.kendra.DocumentAttribute",
    "retrievers.kendra.DocumentAttributeValue",
    "retrievers.kendra.Highlight",
    "retrievers.kendra.QueryResult",
    "retrievers.kendra.QueryResultItem",
    "retrievers.kendra.ResultItem",
    "retrievers.kendra.RetrieveResult",
    "retrievers.kendra.RetrieveResultItem",
    "retrievers.kendra.TextWithHighLights",
    "retrievers.knn.KNNRetriever",
    "retrievers.llama_index.LlamaIndexGraphRetriever",
    "retrievers.llama_index.LlamaIndexRetriever",
    "retrievers.metal.MetalRetriever",
    "retrievers.milvus.MilvusRetriever",
    "retrievers.nanopq.NanoPQRetriever",
    "retrievers.needle.NeedleRetriever",
    "retrievers.outline.OutlineRetriever",
    "retrievers.pinecone_hybrid_search.PineconeHybridSearchRetriever",
    "retrievers.pubmed.PubMedRetriever",
    "retrievers.rememberizer.RememberizerRetriever",
    "retrievers.remote_retriever.RemoteLangChainRetriever",
    "retrievers.svm.SVMRetriever",
    "retrievers.tavily_search_api.SearchDepth",
    "retrievers.tavily_search_api.TavilySearchAPIRetriever",
    "retrievers.tfidf.TFIDFRetriever",
    "retrievers.thirdai_neuraldb.NeuralDBRetriever",
    "retrievers.vespa_retriever.VespaRetriever",
    "retrievers.web_research.QuestionListOutputParser",
    "retrievers.web_research.SearchQueries",
    "retrievers.web_research.WebResearchRetriever",
    "retrievers.wikipedia.WikipediaRetriever",
    "retrievers.you.YouRetriever",
    "retrievers.zep.SearchScope",
    "retrievers.zep.SearchType",
    "retrievers.zep.ZepRetriever",
    "retrievers.zep_cloud.ZepCloudRetriever",
    "retrievers.zilliz.ZillizRetriever",
    "retrievers.bm25.default_preprocessing_func",
    "retrievers.kendra.clean_excerpt",
    "retrievers.kendra.combined_text",
    "retrievers.knn.create_index",
    "retrievers.milvus.MilvusRetreiver",
    "retrievers.nanopq.create_index",
    "retrievers.pinecone_hybrid_search.create_index",
    "retrievers.pinecone_hybrid_search.hash_text",
    "retrievers.svm.create_index",
    "retrievers.zilliz.ZillizRetreiver",
    "retrievers.bedrock.AmazonKnowledgeBasesRetriever",
    "retrievers.cohere_rag_retriever.CohereRagRetriever",
    "retrievers.google_cloud_documentai_warehouse.GoogleDocumentAIWarehouseRetriever",
    "retrievers.google_vertex_ai_search.GoogleVertexAIMultiTurnSearchRetriever",
    "retrievers.google_vertex_ai_search.GoogleVertexAISearchRetriever",
    "retrievers.kendra.AmazonKendraRetriever",
    "retrievers.qdrant_sparse_vector_retriever.QdrantSparseVectorRetriever",
    "retrievers.weaviate_hybrid_search.WeaviateHybridSearchRetriever",
    "storage.astradb.AstraDBBaseStore",
    "storage.cassandra.CassandraByteStore",
    "storage.mongodb.MongoDBByteStore",
    "storage.mongodb.MongoDBStore",
    "storage.redis.RedisStore",
    "storage.sql.LangchainKeyValueStores",
    "storage.sql.SQLStore",
    "storage.upstash_redis.UpstashRedisByteStore",
    "storage.sql.items_equal",
    "storage.astradb.AstraDBByteStore",
    "storage.astradb.AstraDBStore",
    "storage.upstash_redis.UpstashRedisStore",
    "tools.ainetwork.app.AINAppOps",
    "tools.ainetwork.app.AppOperationType",
    "tools.ainetwork.app.AppSchema",
    "tools.ainetwork.base.AINBaseTool",
    "tools.ainetwork.base.OperationType",
    "tools.ainetwork.owner.AINOwnerOps",
    "tools.ainetwork.owner.RuleSchema",
    "tools.ainetwork.rule.AINRuleOps",
    "tools.ainetwork.rule.RuleSchema",
    "tools.ainetwork.transfer.AINTransfer",
    "tools.ainetwork.transfer.TransferSchema",
    "tools.ainetwork.value.AINValueOps",
    "tools.ainetwork.value.ValueSchema",
    "tools.amadeus.base.AmadeusBaseTool",
    "tools.amadeus.closest_airport.AmadeusClosestAirport",
    "tools.amadeus.closest_airport.ClosestAirportSchema",
    "tools.amadeus.flight_search.AmadeusFlightSearch",
    "tools.amadeus.flight_search.FlightSearchSchema",
    "tools.arxiv.tool.ArxivInput",
    "tools.arxiv.tool.ArxivQueryRun",
    "tools.asknews.tool.AskNewsSearch",
    "tools.asknews.tool.SearchInput",
    "tools.audio.huggingface_text_to_speech_inference.HuggingFaceTextToSpeechModelInference",
    "tools.azure_ai_services.document_intelligence.AzureAiServicesDocumentIntelligenceTool",
    "tools.azure_ai_services.image_analysis.AzureAiServicesImageAnalysisTool",
    "tools.azure_ai_services.speech_to_text.AzureAiServicesSpeechToTextTool",
    "tools.azure_ai_services.text_analytics_for_health.AzureAiServicesTextAnalyticsForHealthTool",
    "tools.azure_ai_services.text_to_speech.AzureAiServicesTextToSpeechTool",
    "tools.azure_cognitive_services.form_recognizer.AzureCogsFormRecognizerTool",
    "tools.azure_cognitive_services.image_analysis.AzureCogsImageAnalysisTool",
    "tools.azure_cognitive_services.speech2text.AzureCogsSpeech2TextTool",
    "tools.azure_cognitive_services.text2speech.AzureCogsText2SpeechTool",
    "tools.azure_cognitive_services.text_analytics_health.AzureCogsTextAnalyticsHealthTool",
    "tools.bearly.tool.BearlyInterpreterTool",
    "tools.bearly.tool.BearlyInterpreterToolArguments",
    "tools.bearly.tool.FileInfo",
    "tools.bing_search.tool.BingSearchResults",
    "tools.bing_search.tool.BingSearchRun",
    "tools.brave_search.tool.BraveSearch",
    "tools.cassandra_database.tool.BaseCassandraDatabaseTool",
    "tools.cassandra_database.tool.GetSchemaCassandraDatabaseTool",
    "tools.cassandra_database.tool.GetTableDataCassandraDatabaseTool",
    "tools.cassandra_database.tool.QueryCassandraDatabaseTool",
    "tools.clickup.tool.ClickupAction",
    "tools.cogniswitch.tool.CogniswitchKnowledgeRequest",
    "tools.cogniswitch.tool.CogniswitchKnowledgeSourceFile",
    "tools.cogniswitch.tool.CogniswitchKnowledgeSourceURL",
    "tools.cogniswitch.tool.CogniswitchKnowledgeStatus",
    "tools.connery.models.Action",
    "tools.connery.models.Parameter",
    "tools.connery.models.Validation",
    "tools.connery.service.ConneryService",
    "tools.connery.tool.ConneryAction",
    "tools.dataforseo_api_search.tool.DataForSeoAPISearchResults",
    "tools.dataforseo_api_search.tool.DataForSeoAPISearchRun",
    "tools.dataherald.tool.DataheraldTextToSQL",
    "tools.dataherald.tool.DataheraldTextToSQLInput",
    "tools.ddg_search.tool.DDGInput",
    "tools.ddg_search.tool.DuckDuckGoSearchResults",
    "tools.ddg_search.tool.DuckDuckGoSearchRun",
    "tools.e2b_data_analysis.tool.E2BDataAnalysisTool",
    "tools.e2b_data_analysis.tool.E2BDataAnalysisToolArguments",
    "tools.e2b_data_analysis.tool.UploadedFile",
    "tools.e2b_data_analysis.unparse.Unparser",
    "tools.edenai.audio_speech_to_text.EdenAiSpeechToTextTool",
    "tools.edenai.audio_speech_to_text.SpeechToTextInput",
    "tools.edenai.audio_text_to_speech.EdenAiTextToSpeechTool",
    "tools.edenai.audio_text_to_speech.TextToSpeechInput",
    "tools.edenai.edenai_base_tool.EdenaiTool",
    "tools.edenai.image_explicitcontent.EdenAiExplicitImageTool",
    "tools.edenai.image_explicitcontent.ExplicitImageInput",
    "tools.edenai.image_objectdetection.EdenAiObjectDetectionTool",
    "tools.edenai.image_objectdetection.ObjectDetectionInput",
    "tools.edenai.ocr_identityparser.EdenAiParsingIDTool",
    "tools.edenai.ocr_identityparser.IDParsingInput",
    "tools.edenai.ocr_invoiceparser.EdenAiParsingInvoiceTool",
    "tools.edenai.ocr_invoiceparser.InvoiceParsingInput",
    "tools.edenai.text_moderation.EdenAiTextModerationTool",
    "tools.edenai.text_moderation.TextModerationInput",
    "tools.eleven_labs.models.ElevenLabsModel",
    "tools.eleven_labs.text2speech.ElevenLabsModel",
    "tools.eleven_labs.text2speech.ElevenLabsText2SpeechTool",
    "tools.few_shot.tool.FewShotSQLTool",
    "tools.file_management.copy.CopyFileTool",
    "tools.file_management.copy.FileCopyInput",
    "tools.file_management.delete.DeleteFileTool",
    "tools.file_management.delete.FileDeleteInput",
    "tools.file_management.file_search.FileSearchInput",
    "tools.file_management.file_search.FileSearchTool",
    "tools.file_management.list_dir.DirectoryListingInput",
    "tools.file_management.list_dir.ListDirectoryTool",
    "tools.file_management.move.FileMoveInput",
    "tools.file_management.move.MoveFileTool",
    "tools.file_management.read.ReadFileInput",
    "tools.file_management.read.ReadFileTool",
    "tools.file_management.utils.BaseFileToolMixin",
    "tools.file_management.utils.FileValidationError",
    "tools.file_management.write.WriteFileInput",
    "tools.file_management.write.WriteFileTool",
    "tools.financial_datasets.balance_sheets.BalanceSheets",
    "tools.financial_datasets.balance_sheets.BalanceSheetsSchema",
    "tools.financial_datasets.cash_flow_statements.CashFlowStatements",
    "tools.financial_datasets.cash_flow_statements.CashFlowStatementsSchema",
    "tools.financial_datasets.income_statements.IncomeStatements",
    "tools.financial_datasets.income_statements.IncomeStatementsSchema",
    "tools.github.tool.GitHubAction",
    "tools.gitlab.tool.GitLabAction",
    "tools.gmail.base.GmailBaseTool",
    "tools.gmail.create_draft.CreateDraftSchema",
    "tools.gmail.create_draft.GmailCreateDraft",
    "tools.gmail.get_message.GmailGetMessage",
    "tools.gmail.get_message.SearchArgsSchema",
    "tools.gmail.get_thread.GetThreadSchema",
    "tools.gmail.get_thread.GmailGetThread",
    "tools.gmail.search.GmailSearch",
    "tools.gmail.search.Resource",
    "tools.gmail.search.SearchArgsSchema",
    "tools.gmail.send_message.GmailSendMessage",
    "tools.gmail.send_message.SendMessageSchema",
    "tools.golden_query.tool.GoldenQueryRun",
    "tools.google_books.GoogleBooksQueryInput",
    "tools.google_books.GoogleBooksQueryRun",
    "tools.google_finance.tool.GoogleFinanceQueryRun",
    "tools.google_jobs.tool.GoogleJobsQueryRun",
    "tools.google_lens.tool.GoogleLensQueryRun",
    "tools.google_places.tool.GooglePlacesSchema",
    "tools.google_scholar.tool.GoogleScholarQueryRun",
    "tools.google_serper.tool.GoogleSerperResults",
    "tools.google_serper.tool.GoogleSerperRun",
    "tools.google_trends.tool.GoogleTrendsQueryRun",
    "tools.graphql.tool.BaseGraphQLTool",
    "tools.human.tool.HumanInputRun",
    "tools.ifttt.IFTTTWebhook",
    "tools.jina_search.tool.JinaInput",
    "tools.jina_search.tool.JinaSearch",
    "tools.jira.tool.JiraAction",
    "tools.json.tool.JsonGetValueTool",
    "tools.json.tool.JsonListKeysTool",
    "tools.json.tool.JsonSpec",
    "tools.memorize.tool.Memorize",
    "tools.memorize.tool.TrainableLLM",
    "tools.merriam_webster.tool.MerriamWebsterQueryRun",
    "tools.mojeek_search.tool.MojeekSearch",
    "tools.multion.close_session.CloseSessionSchema",
    "tools.multion.close_session.MultionCloseSession",
    "tools.multion.create_session.CreateSessionSchema",
    "tools.multion.create_session.MultionCreateSession",
    "tools.multion.update_session.MultionUpdateSession",
    "tools.multion.update_session.UpdateSessionSchema",
    "tools.nasa.tool.NasaAction",
    "tools.nuclia.tool.NUASchema",
    "tools.nuclia.tool.NucliaUnderstandingAPI",
    "tools.office365.base.O365BaseTool",
    "tools.office365.create_draft_message.CreateDraftMessageSchema",
    "tools.office365.create_draft_message.O365CreateDraftMessage",
    "tools.office365.events_search.O365SearchEvents",
    "tools.office365.events_search.SearchEventsInput",
    "tools.office365.messages_search.O365SearchEmails",
    "tools.office365.messages_search.SearchEmailsInput",
    "tools.office365.send_event.O365SendEvent",
    "tools.office365.send_event.SendEventSchema",
    "tools.office365.send_message.O365SendMessage",
    "tools.office365.send_message.SendMessageSchema",
    "tools.openai_dalle_image_generation.tool.OpenAIDALLEImageGenerationTool",
    "tools.openapi.utils.api_models.APIOperation",
    "tools.openapi.utils.api_models.APIProperty",
    "tools.openapi.utils.api_models.APIPropertyBase",
    "tools.openapi.utils.api_models.APIPropertyLocation",
    "tools.openapi.utils.api_models.APIRequestBody",
    "tools.openapi.utils.api_models.APIRequestBodyProperty",
    "tools.openweathermap.tool.OpenWeatherMapQueryRun",
    "tools.passio_nutrition_ai.tool.NutritionAI",
    "tools.passio_nutrition_ai.tool.NutritionAIInputs",
    "tools.playwright.base.BaseBrowserTool",
    "tools.playwright.click.ClickTool",
    "tools.playwright.click.ClickToolInput",
    "tools.playwright.current_page.CurrentWebPageTool",
    "tools.playwright.current_page.CurrentWebPageToolInput",
    "tools.playwright.extract_hyperlinks.ExtractHyperlinksTool",
    "tools.playwright.extract_hyperlinks.ExtractHyperlinksToolInput",
    "tools.playwright.extract_text.ExtractTextTool",
    "tools.playwright.extract_text.ExtractTextToolInput",
    "tools.playwright.get_elements.GetElementsTool",
    "tools.playwright.get_elements.GetElementsToolInput",
    "tools.playwright.navigate.NavigateTool",
    "tools.playwright.navigate.NavigateToolInput",
    "tools.playwright.navigate_back.NavigateBackTool",
    "tools.playwright.navigate_back.NavigateBackToolInput",
    "tools.plugin.AIPlugin",
    "tools.plugin.AIPluginTool",
    "tools.plugin.AIPluginToolSchema",
    "tools.plugin.ApiConfig",
    "tools.polygon.aggregates.PolygonAggregates",
    "tools.polygon.aggregates.PolygonAggregatesSchema",
    "tools.polygon.financials.Inputs",
    "tools.polygon.financials.PolygonFinancials",
    "tools.polygon.last_quote.Inputs",
    "tools.polygon.last_quote.PolygonLastQuote",
    "tools.polygon.ticker_news.Inputs",
    "tools.polygon.ticker_news.PolygonTickerNews",
    "tools.powerbi.tool.InfoPowerBITool",
    "tools.powerbi.tool.ListPowerBITool",
    "tools.powerbi.tool.QueryPowerBITool",
    "tools.pubmed.tool.PubmedQueryRun",
    "tools.reddit_search.tool.RedditSearchRun",
    "tools.reddit_search.tool.RedditSearchSchema",
    "tools.requests.tool.BaseRequestsTool",
    "tools.requests.tool.RequestsDeleteTool",
    "tools.requests.tool.RequestsGetTool",
    "tools.requests.tool.RequestsPatchTool",
    "tools.requests.tool.RequestsPostTool",
    "tools.requests.tool.RequestsPutTool",
    "tools.riza.command.ExecJavaScript",
    "tools.riza.command.ExecJavaScriptInput",
    "tools.riza.command.ExecPython",
    "tools.riza.command.ExecPythonInput",
    "tools.scenexplain.tool.SceneXplainInput",
    "tools.scenexplain.tool.SceneXplainTool",
    "tools.searchapi.tool.SearchAPIResults",
    "tools.searchapi.tool.SearchAPIRun",
    "tools.searx_search.tool.SearxSearchQueryInput",
    "tools.searx_search.tool.SearxSearchResults",
    "tools.searx_search.tool.SearxSearchRun",
    "tools.semanticscholar.tool.SemanticScholarQueryRun",
    "tools.semanticscholar.tool.SemantscholarInput",
    "tools.shell.tool.ShellInput",
    "tools.shell.tool.ShellTool",
    "tools.slack.base.SlackBaseTool",
    "tools.slack.get_channel.SlackGetChannel",
    "tools.slack.get_message.SlackGetMessage",
    "tools.slack.get_message.SlackGetMessageSchema",
    "tools.slack.schedule_message.ScheduleMessageSchema",
    "tools.slack.schedule_message.SlackScheduleMessage",
    "tools.slack.send_message.SendMessageSchema",
    "tools.slack.send_message.SlackSendMessage",
    "tools.sleep.tool.SleepInput",
    "tools.sleep.tool.SleepTool",
    "tools.spark_sql.tool.BaseSparkSQLTool",
    "tools.spark_sql.tool.InfoSparkSQLTool",
    "tools.spark_sql.tool.ListSparkSQLTool",
    "tools.spark_sql.tool.QueryCheckerTool",
    "tools.spark_sql.tool.QuerySparkSQLTool",
    "tools.sql_database.tool.BaseSQLDatabaseTool",
    "tools.sql_database.tool.InfoSQLDatabaseTool",
    "tools.sql_database.tool.ListSQLDatabaseTool",
    "tools.sql_database.tool.QuerySQLCheckerTool",
    "tools.sql_database.tool.QuerySQLDatabaseTool",
    "tools.stackexchange.tool.StackExchangeTool",
    "tools.steam.tool.SteamWebAPIQueryRun",
    "tools.steamship_image_generation.tool.ModelName",
    "tools.steamship_image_generation.tool.SteamshipImageGenerationTool",
    "tools.tavily_search.tool.TavilyInput",
    "tools.vectorstore.tool.BaseVectorStoreTool",
    "tools.vectorstore.tool.VectorStoreQATool",
    "tools.vectorstore.tool.VectorStoreQAWithSourcesTool",
    "tools.wikidata.tool.WikidataQueryRun",
    "tools.wikipedia.tool.WikipediaQueryInput",
    "tools.wikipedia.tool.WikipediaQueryRun",
    "tools.wolfram_alpha.tool.WolframAlphaQueryRun",
    "tools.yahoo_finance_news.YahooFinanceNewsInput",
    "tools.yahoo_finance_news.YahooFinanceNewsTool",
    "tools.you.tool.YouInput",
    "tools.you.tool.YouSearchTool",
    "tools.youtube.search.YouTubeSearchTool",
    "tools.zapier.tool.ZapierNLAListActions",
    "tools.zapier.tool.ZapierNLARunAction",
    "tools.zenguard.tool.Detector",
    "tools.zenguard.tool.DetectorAPI",
    "tools.zenguard.tool.ZenGuardInput",
    "tools.zenguard.tool.ZenGuardTool",
    "tools.ainetwork.utils.authenticate",
    "tools.amadeus.utils.authenticate",
    "tools.azure_ai_services.utils.detect_file_src_type",
    "tools.azure_ai_services.utils.download_audio_from_url",
    "tools.azure_cognitive_services.utils.detect_file_src_type",
    "tools.azure_cognitive_services.utils.download_audio_from_url",
    "tools.bearly.tool.file_to_base64",
    "tools.bearly.tool.head_file",
    "tools.bearly.tool.strip_markdown_code",
    "tools.ddg_search.tool.DuckDuckGoSearchTool",
    "tools.e2b_data_analysis.tool.add_last_line_print",
    "tools.e2b_data_analysis.unparse.interleave",
    "tools.e2b_data_analysis.unparse.roundtrip",
    "tools.file_management.utils.get_validated_relative_path",
    "tools.file_management.utils.is_relative_to",
    "tools.gmail.utils.build_resource_service",
    "tools.gmail.utils.clean_email_body",
    "tools.gmail.utils.get_gmail_credentials",
    "tools.gmail.utils.import_google",
    "tools.gmail.utils.import_googleapiclient_resource_builder",
    "tools.gmail.utils.import_installed_app_flow",
    "tools.interaction.tool.StdInInquireTool",
    "tools.office365.utils.authenticate",
    "tools.office365.utils.clean_body",
    "tools.playwright.base.lazy_import_playwright_browsers",
    "tools.playwright.utils.aget_current_page",
    "tools.playwright.utils.create_async_playwright_browser",
    "tools.playwright.utils.create_sync_playwright_browser",
    "tools.playwright.utils.get_current_page",
    "tools.playwright.utils.run_async",
    "tools.plugin.marshal_spec",
    "tools.slack.utils.login",
    "tools.steamship_image_generation.utils.make_image_public",
    "tools.databricks.tool.UCFunctionToolkit",
    "tools.google_cloud.texttospeech.GoogleCloudTextToSpeechTool",
    "tools.google_places.tool.GooglePlacesTool",
    "tools.google_search.tool.GoogleSearchResults",
    "tools.google_search.tool.GoogleSearchRun",
    "tools.metaphor_search.tool.MetaphorSearchResults",
    "tools.tavily_search.tool.TavilyAnswer",
    "tools.tavily_search.tool.TavilySearchResults",
    "utilities.alpha_vantage.AlphaVantageAPIWrapper",
    "utilities.arcee.ArceeDocument",
    "utilities.arcee.ArceeDocumentAdapter",
    "utilities.arcee.ArceeDocumentSource",
    "utilities.arcee.ArceeRoute",
    "utilities.arcee.ArceeWrapper",
    "utilities.arcee.DALMFilter",
    "utilities.arcee.DALMFilterType",
    "utilities.arxiv.ArxivAPIWrapper",
    "utilities.asknews.AskNewsAPIWrapper",
    "utilities.astradb.SetupMode",
    "utilities.awslambda.LambdaWrapper",
    "utilities.bibtex.BibtexparserWrapper",
    "utilities.bing_search.BingSearchAPIWrapper",
    "utilities.brave_search.BraveSearchWrapper",
    "utilities.cassandra.SetupMode",
    "utilities.cassandra_database.CassandraDatabase",
    "utilities.cassandra_database.DatabaseError",
    "utilities.cassandra_database.Table",
    "utilities.clickup.CUList",
    "utilities.clickup.ClickupAPIWrapper",
    "utilities.clickup.Component",
    "utilities.clickup.Member",
    "utilities.clickup.Space",
    "utilities.clickup.Task",
    "utilities.clickup.Team",
    "utilities.dalle_image_generator.DallEAPIWrapper",
    "utilities.dataforseo_api_search.DataForSeoAPIWrapper",
    "utilities.dataherald.DataheraldAPIWrapper",
    "utilities.dria_index.DriaAPIWrapper",
    "utilities.duckduckgo_search.DuckDuckGoSearchAPIWrapper",
    "utilities.financial_datasets.FinancialDatasetsAPIWrapper",
    "utilities.github.GitHubAPIWrapper",
    "utilities.gitlab.GitLabAPIWrapper",
    "utilities.golden_query.GoldenQueryAPIWrapper",
    "utilities.google_books.GoogleBooksAPIWrapper",
    "utilities.google_finance.GoogleFinanceAPIWrapper",
    "utilities.google_jobs.GoogleJobsAPIWrapper",
    "utilities.google_lens.GoogleLensAPIWrapper",
    "utilities.google_scholar.GoogleScholarAPIWrapper",
    "utilities.google_serper.GoogleSerperAPIWrapper",
    "utilities.google_trends.GoogleTrendsAPIWrapper",
    "utilities.graphql.GraphQLAPIWrapper",
    "utilities.infobip.InfobipAPIWrapper",
    "utilities.jina_search.JinaSearchAPIWrapper",
    "utilities.jira.JiraAPIWrapper",
    "utilities.jira.JiraOauth2",
    "utilities.jira.JiraOauth2Token",
    "utilities.max_compute.MaxComputeAPIWrapper",
    "utilities.merriam_webster.MerriamWebsterAPIWrapper",
    "utilities.metaphor_search.MetaphorSearchAPIWrapper",
    "utilities.mojeek_search.MojeekSearchAPIWrapper",
    "utilities.nasa.NasaAPIWrapper",
    "utilities.nvidia_riva.ASRInputType",
    "AudioStream",
    "utilities.nvidia_riva.AudioStream",
    "utilities.nvidia_riva.NVIDIARivaASR",
    "RivaASR",
    "utilities.nvidia_riva.NVIDIARivaStream",
    "AudioStream",
    "utilities.nvidia_riva.NVIDIARivaTTS",
    "RivaTTS",
    "utilities.nvidia_riva.RivaASR",
    "utilities.nvidia_riva.RivaAudioEncoding",
    "utilities.nvidia_riva.RivaAuthMixin",
    "utilities.nvidia_riva.RivaCommonConfigMixin",
    "utilities.nvidia_riva.RivaTTS",
    "utilities.nvidia_riva.SentinelT",
    "utilities.openapi.HTTPVerb",
    "utilities.openapi.OpenAPISpec",
    "utilities.openweathermap.OpenWeatherMapAPIWrapper",
    "utilities.oracleai.OracleSummary",
    "utilities.outline.OutlineAPIWrapper",
    "utilities.passio_nutrition_ai.ManagedPassioLifeAuth",
    "utilities.passio_nutrition_ai.NoDiskStorage",
    "utilities.passio_nutrition_ai.NutritionAIAPI",
    "utilities.pebblo.App",
    "utilities.pebblo.Doc",
    "utilities.pebblo.Framework",
    "utilities.pebblo.IndexedDocument",
    "utilities.pebblo.PebbloLoaderAPIWrapper",
    "utilities.pebblo.Routes",
    "utilities.pebblo.Runtime",
    "utilities.polygon.PolygonAPIWrapper",
    "utilities.portkey.Portkey",
    "utilities.powerbi.PowerBIDataset",
    "utilities.pubmed.PubMedAPIWrapper",
    "utilities.reddit_search.RedditSearchAPIWrapper",
    "utilities.redis.TokenEscaper",
    "utilities.rememberizer.RememberizerAPIWrapper",
    "utilities.requests.GenericRequestsWrapper",
    "utilities.requests.JsonRequestsWrapper",
    "utilities.requests.Requests",
    "utilities.requests.RequestsWrapper",
    "TextRequestsWrapper",
    "utilities.requests.TextRequestsWrapper",
    "utilities.scenexplain.SceneXplainAPIWrapper",
    "utilities.searchapi.SearchApiAPIWrapper",
    "utilities.searx_search.SearxResults",
    "utilities.searx_search.SearxSearchWrapper",
    "utilities.semanticscholar.SemanticScholarAPIWrapper",
    "utilities.serpapi.HiddenPrints",
    "utilities.serpapi.SerpAPIWrapper",
    "utilities.spark_sql.SparkSQL",
    "utilities.sql_database.SQLDatabase",
    "utilities.stackexchange.StackExchangeAPIWrapper",
    "utilities.steam.SteamWebAPIWrapper",
    "utilities.tavily_search.TavilySearchAPIWrapper",
    "utilities.tensorflow_datasets.TensorflowDatasets",
    "utilities.twilio.TwilioAPIWrapper",
    "utilities.wikidata.WikidataAPIWrapper",
    "utilities.wikipedia.WikipediaAPIWrapper",
    "utilities.wolfram_alpha.WolframAlphaAPIWrapper",
    "utilities.you.YouAPIOutput",
    "utilities.you.YouDocument",
    "utilities.you.YouHit",
    "utilities.you.YouHitMetadata",
    "utilities.you.YouSearchAPIWrapper",
    "utilities.zapier.ZapierNLAWrapper",
    "utilities.anthropic.get_num_tokens_anthropic",
    "utilities.anthropic.get_token_ids_anthropic",
    "utilities.cassandra.aexecute_cql",
    "utilities.cassandra.wrapped_response_future",
    "utilities.clickup.extract_dict_elements_from_component_fields",
    "utilities.clickup.fetch_data",
    "utilities.clickup.fetch_first_id",
    "utilities.clickup.fetch_folder_id",
    "utilities.clickup.fetch_list_id",
    "utilities.clickup.fetch_space_id",
    "utilities.clickup.fetch_team_id",
    "utilities.clickup.load_query",
    "utilities.clickup.parse_dict_through_component",
    "utilities.opaqueprompts.desanitize",
    "utilities.opaqueprompts.sanitize",
    "utilities.passio_nutrition_ai.is_http_retryable",
    "utilities.pebblo.calculate_content_size",
    "utilities.pebblo.generate_size_based_batches",
    "utilities.pebblo.get_file_owner_from_path",
    "utilities.pebblo.get_full_path",
    "utilities.pebblo.get_ip",
    "utilities.pebblo.get_loader_full_path",
    "utilities.pebblo.get_loader_type",
    "utilities.pebblo.get_runtime",
    "utilities.pebblo.get_source_size",
    "utilities.powerbi.fix_table_name",
    "utilities.powerbi.json_to_md",
    "utilities.redis.check_redis_module_exist",
    "utilities.redis.get_client",
    "utilities.sql_database.sanitize_schema",
    "utilities.sql_database.truncate_word",
    "utilities.vertexai.create_retry_decorator",
    "utilities.vertexai.get_client_info",
    "utilities.vertexai.init_vertexai",
    "utilities.vertexai.load_image_from_gcs",
    "utilities.vertexai.raise_vertex_import_error",
    "utilities.apify.ApifyWrapper",
    "utilities.google_places_api.GooglePlacesAPIWrapper",
    "utilities.google_search.GoogleSearchAPIWrapper",
    "utils.ernie_functions.FunctionDescription",
    "utils.ernie_functions.ToolDescription",
    "utils.ernie_functions.convert_pydantic_to_ernie_function",
    "utils.ernie_functions.convert_pydantic_to_ernie_tool",
    "utils.google.get_client_info",
    "utils.math.cosine_similarity",
    "utils.math.cosine_similarity_top_k",
    "utils.user_agent.get_user_agent",
    "vectorstores.aerospike.Aerospike",
    "vectorstores.alibabacloud_opensearch.AlibabaCloudOpenSearch",
    "vectorstores.alibabacloud_opensearch.AlibabaCloudOpenSearchSettings",
    "vectorstores.analyticdb.AnalyticDB",
    "vectorstores.annoy.Annoy",
    "vectorstores.apache_doris.ApacheDoris",
    "vectorstores.apache_doris.ApacheDorisSettings",
    "vectorstores.apache_doris.QueryResult",
    "vectorstores.aperturedb.ApertureDB",
    "vectorstores.atlas.AtlasDB",
    "vectorstores.awadb.AwaDB",
    "vectorstores.azure_cosmos_db.AzureCosmosDBVectorSearch",
    "vectorstores.azure_cosmos_db.CosmosDBSimilarityType",
    "vectorstores.azure_cosmos_db.CosmosDBVectorSearchType",
    "vectorstores.azure_cosmos_db_no_sql.Condition",
    "vectorstores.azure_cosmos_db_no_sql.CosmosDBQueryType",
    "vectorstores.azure_cosmos_db_no_sql.PreFilter",
    "vectorstores.azuresearch.AzureSearch",
    "vectorstores.azuresearch.AzureSearchVectorStoreRetriever",
    "vectorstores.bagel.Bagel",
    "Bagel.net",
    "vectorstores.baiducloud_vector_search.BESVectorStore",
    "vectorstores.baiduvectordb.BaiduVectorDB",
    "vectorstores.baiduvectordb.ConnectionParams",
    "vectorstores.baiduvectordb.TableParams",
    "vectorstores.cassandra.Cassandra",
    "vectorstores.clarifai.Clarifai",
    "vectorstores.clickhouse.Clickhouse",
    "vectorstores.clickhouse.ClickhouseSettings",
    "vectorstores.dashvector.DashVector",
    "vectorstores.dingo.Dingo",
    "vectorstores.docarray.base.DocArrayIndex",
    "vectorstores.docarray.hnsw.DocArrayHnswSearch",
    "vectorstores.docarray.in_memory.DocArrayInMemorySearch",
    "vectorstores.documentdb.DocumentDBSimilarityType",
    "vectorstores.documentdb.DocumentDBVectorSearch",
    "vectorstores.duckdb.DuckDB",
    "vectorstores.ecloud_vector_search.EcloudESVectorStore",
    "vectorstores.elasticsearch.BaseRetrievalStrategy",
    "vectorstores.epsilla.Epsilla",
    "vectorstores.faiss.FAISS",
    "vectorstores.falkordb_vector.FalkorDBVector",
    "vectorstores.falkordb_vector.IndexType",
    "vectorstores.falkordb_vector.SearchType",
    "vectorstores.hippo.Hippo",
    "vectorstores.hologres.Hologres",
    "vectorstores.infinispanvs.Infinispan",
    "vectorstores.infinispanvs.InfinispanVS",
    "vectorstores.jaguar.Jaguar",
    "vectorstores.kdbai.KDBAI",
    "vectorstores.kinetica.Dimension",
    "vectorstores.kinetica.DistanceStrategy",
    "vectorstores.kinetica.Kinetica",
    "vectorstores.kinetica.KineticaSettings",
    "vectorstores.lancedb.LanceDB",
    "vectorstores.lantern.BaseEmbeddingStore",
    "vectorstores.lantern.DistanceStrategy",
    "vectorstores.lantern.Lantern",
    "vectorstores.lantern.QueryResult",
    "vectorstores.llm_rails.LLMRails",
    "vectorstores.llm_rails.LLMRailsRetriever",
    "vectorstores.manticore_search.ManticoreSearch",
    "vectorstores.manticore_search.ManticoreSearchSettings",
    "vectorstores.marqo.Marqo",
    "vectorstores.meilisearch.Meilisearch",
    "vectorstores.momento_vector_index.MomentoVectorIndex",
    "vectorstores.myscale.MyScale",
    "vectorstores.myscale.MyScaleSettings",
    "vectorstores.myscale.MyScaleWithoutJSON",
    "vectorstores.nucliadb.NucliaDB",
    "vectorstores.opensearch_vector_search.OpenSearchVectorSearch",
    "vectorstores.oraclevs.OracleVS",
    "vectorstores.pathway.PathwayVectorClient",
    "vectorstores.pgembedding.BaseModel",
    "vectorstores.pgembedding.CollectionStore",
    "vectorstores.pgembedding.EmbeddingStore",
    "vectorstores.pgembedding.PGEmbedding",
    "vectorstores.pgembedding.QueryResult",
    "vectorstores.pgvecto_rs.PGVecto_rs",
    "vectorstores.pgvector.BaseModel",
    "vectorstores.pgvector.DistanceStrategy",
    "vectorstores.qdrant.QdrantException",
    "vectorstores.redis.base.RedisVectorStoreRetriever",
    "vectorstores.redis.filters.RedisFilter",
    "vectorstores.redis.filters.RedisFilterExpression",
    "vectorstores.redis.filters.RedisFilterField",
    "vectorstores.redis.filters.RedisFilterOperator",
    "vectorstores.redis.filters.RedisNum",
    "vectorstores.redis.filters.RedisTag",
    "vectorstores.redis.filters.RedisText",
    "vectorstores.redis.schema.FlatVectorField",
    "vectorstores.redis.schema.HNSWVectorField",
    "vectorstores.redis.schema.NumericFieldSchema",
    "vectorstores.redis.schema.RedisDistanceMetric",
    "vectorstores.redis.schema.RedisField",
    "vectorstores.redis.schema.RedisModel",
    "vectorstores.redis.schema.RedisVectorField",
    "vectorstores.redis.schema.TagFieldSchema",
    "vectorstores.redis.schema.TextFieldSchema",
    "vectorstores.relyt.Relyt",
    "vectorstores.rocksetdb.Rockset",
    "vectorstores.scann.ScaNN",
    "vectorstores.semadb.SemaDB",
    "vectorstores.sklearn.BaseSerializer",
    "vectorstores.sklearn.BsonSerializer",
    "vectorstores.sklearn.JsonSerializer",
    "vectorstores.sklearn.ParquetSerializer",
    "vectorstores.sklearn.SKLearnVectorStore",
    "vectorstores.sklearn.SKLearnVectorStoreException",
    "vectorstores.sqlitevec.SQLiteVec",
    "vectorstores.sqlitevss.SQLiteVSS",
    "vectorstores.starrocks.QueryResult",
    "vectorstores.starrocks.StarRocks",
    "vectorstores.starrocks.StarRocksSettings",
    "vectorstores.supabase.SupabaseVectorStore",
    "vectorstores.surrealdb.SurrealDBStore",
    "vectorstores.tablestore.TablestoreVectorStore",
    "vectorstores.tair.Tair",
    "vectorstores.tencentvectordb.ConnectionParams",
    "vectorstores.tencentvectordb.IndexParams",
    "vectorstores.tencentvectordb.MetaField",
    "vectorstores.tencentvectordb.TencentVectorDB",
    "vectorstores.thirdai_neuraldb.NeuralDBClientVectorStore",
    "vectorstores.thirdai_neuraldb.NeuralDBVectorStore",
    "vectorstores.tidb_vector.TiDBVectorStore",
    "vectorstores.tigris.Tigris",
    "vectorstores.tiledb.TileDB",
    "vectorstores.timescalevector.TimescaleVector",
    "vectorstores.typesense.Typesense",
    "vectorstores.upstash.UpstashVectorStore",
    "vectorstores.usearch.USearch",
    "vectorstores.utils.DistanceStrategy",
    "vectorstores.vald.Vald",
    "vectorstores.vearch.Vearch",
    "vectorstores.vectara.MMRConfig",
    "vectorstores.vectara.RerankConfig",
    "vectorstores.vectara.SummaryConfig",
    "vectorstores.vectara.Vectara",
    "vectorstores.vectara.VectaraQueryConfig",
    "vectorstores.vectara.VectaraRAG",
    "vectorstores.vectara.VectaraRetriever",
    "vectorstores.vespa.VespaStore",
    "vectorstores.vikingdb.VikingDB",
    "vectorstores.vikingdb.VikingDBConfig",
    "vectorstores.vlite.VLite",
    "vectorstores.xata.XataVectorStore",
    "vectorstores.yellowbrick.Yellowbrick",
    "vectorstores.zep.CollectionConfig",
    "vectorstores.zep.ZepVectorStore",
    "vectorstores.zep_cloud.ZepCloudVectorStore",
    "vectorstores.zilliz.Zilliz",
    "vectorstores.alibabacloud_opensearch.create_metadata",
    "vectorstores.annoy.dependable_annoy_import",
    "vectorstores.clickhouse.has_mul_sub_str",
    "vectorstores.faiss.dependable_faiss_import",
    "vectorstores.falkordb_vector.construct_metadata_filter",
    "vectorstores.falkordb_vector.dict_to_yaml_str",
    "vectorstores.falkordb_vector.generate_random_string",
    "vectorstores.falkordb_vector.process_index_data",
    "vectorstores.lancedb.import_lancedb",
    "vectorstores.lancedb.to_lance_filter",
    "vectorstores.lantern.get_embedding_store",
    "vectorstores.myscale.has_mul_sub_str",
    "vectorstores.oraclevs.create_index",
    "vectorstores.oraclevs.drop_index_if_exists",
    "vectorstores.oraclevs.drop_table_purge",
    "vectorstores.qdrant.sync_call_fallback",
    "vectorstores.redis.base.check_index_exists",
    "vectorstores.redis.filters.check_operator_misuse",
    "vectorstores.redis.schema.read_schema",
    "vectorstores.scann.dependable_scann_import",
    "vectorstores.scann.normalize",
    "vectorstores.sqlitevec.serialize_f32",
    "vectorstores.starrocks.debug_output",
    "vectorstores.starrocks.get_named_result",
    "vectorstores.starrocks.has_mul_sub_str",
    "vectorstores.tencentvectordb.translate_filter",
    "vectorstores.tiledb.dependable_tiledb_import",
    "vectorstores.tiledb.get_documents_array_uri",
    "vectorstores.tiledb.get_documents_array_uri_from_group",
    "vectorstores.tiledb.get_vector_index_uri",
    "vectorstores.tiledb.get_vector_index_uri_from_group",
    "vectorstores.usearch.dependable_usearch_import",
    "vectorstores.utils.filter_complex_metadata",
    "vectorstores.utils.maximal_marginal_relevance",
    "vectorstores.vdms.VDMS_Client",
    "vectorstores.vdms.embedding2bytes",
    "vectorstores.astradb.AstraDB",
    "vectorstores.azure_cosmos_db_no_sql.AzureCosmosDBNoSqlVectorSearch",
    "vectorstores.bigquery_vector_search.BigQueryVectorSearch",
    "vectorstores.chroma.Chroma",
    "vectorstores.couchbase.CouchbaseVectorStore",
    "vectorstores.databricks_vector_search.DatabricksVectorSearch",
    "vectorstores.deeplake.DeepLake",
    "vectorstores.elastic_vector_search.ElasticKnnSearch",
    "vectorstores.elastic_vector_search.ElasticVectorSearch",
    "vectorstores.elasticsearch.ApproxRetrievalStrategy",
    "vectorstores.elasticsearch.ElasticsearchStore",
    "vectorstores.elasticsearch.ExactRetrievalStrategy",
    "vectorstores.elasticsearch.SparseRetrievalStrategy",
    "vectorstores.hanavector.HanaDB",
    "vectorstores.matching_engine.MatchingEngine",
    "vectorstores.milvus.Milvus",
    "vectorstores.mongodb_atlas.MongoDBAtlasVectorSearch",
    "vectorstores.neo4j_vector.IndexType",
    "vectorstores.neo4j_vector.Neo4jVector",
    "vectorstores.neo4j_vector.SearchType",
    "vectorstores.pgvector.PGVector",
    "vectorstores.pinecone.Pinecone",
    "vectorstores.qdrant.Qdrant",
    "vectorstores.redis.base.Redis",
    "vectorstores.singlestoredb.SingleStoreDB",
    "vectorstores.vdms.VDMS",
    "vectorstores.weaviate.Weaviate",
    "vectorstores.neo4j_vector.check_if_not_null",
    "vectorstores.neo4j_vector.collect_params",
    "vectorstores.neo4j_vector.combine_queries",
    "vectorstores.neo4j_vector.construct_metadata_filter",
    "vectorstores.neo4j_vector.dict_to_yaml_str",
    "vectorstores.neo4j_vector.remove_lucene_chars",
    "vectorstores.neo4j_vector.sort_by_index_name"
  ],
  "api_signatures": [],
  "parameters": []
}
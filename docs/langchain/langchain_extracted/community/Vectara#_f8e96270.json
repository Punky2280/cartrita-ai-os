{
  "url": "https://python.langchain.com/api_reference/community/vectorstores/langchain_community.vectorstores.vectara.Vectara.html",
  "title": "Vectara#",
  "sections": [
    {
      "type": "li",
      "content": "LangChain Python API Reference"
    },
    {
      "type": "li",
      "content": "langchain-community: 0.3.29"
    },
    {
      "type": "li",
      "content": "vectorstores"
    },
    {
      "type": "p",
      "content": "Vectara APIvector store."
    },
    {
      "type": "p",
      "content": "See (https://vectara.com)."
    },
    {
      "type": "p",
      "content": "Initialize with Vectara API."
    },
    {
      "type": "p",
      "content": "Access the query embedding object if available."
    },
    {
      "type": "p",
      "content": "__init__([vectara_customer_id, ...])"
    },
    {
      "type": "p",
      "content": "Initialize with Vectara API."
    },
    {
      "type": "p",
      "content": "aadd_documents(documents, **kwargs)"
    },
    {
      "type": "p",
      "content": "Async run more documents through the embeddings and add to the vectorstore."
    },
    {
      "type": "p",
      "content": "aadd_texts(texts[, metadatas, ids])"
    },
    {
      "type": "p",
      "content": "Async run more texts through the embeddings and add to the vectorstore."
    },
    {
      "type": "p",
      "content": "add_documents(documents, **kwargs)"
    },
    {
      "type": "p",
      "content": "Add or update documents in the vectorstore."
    },
    {
      "type": "p",
      "content": "add_files(files_list[, metadatas])"
    },
    {
      "type": "p",
      "content": "Vectara provides a way to add documents directly via our API where pre-processing and chunking occurs internally in an optimal way This method provides a way to use that API in LangChain"
    },
    {
      "type": "p",
      "content": "add_texts(texts[, metadatas, doc_metadata])"
    },
    {
      "type": "p",
      "content": "Run more texts through the embeddings and add to the vectorstore."
    },
    {
      "type": "p",
      "content": "adelete([ids])"
    },
    {
      "type": "p",
      "content": "Async delete by vector ID or other criteria."
    },
    {
      "type": "p",
      "content": "afrom_documents(documents, embedding, **kwargs)"
    },
    {
      "type": "p",
      "content": "Async return VectorStore initialized from documents and embeddings."
    },
    {
      "type": "p",
      "content": "afrom_texts(texts, embedding[, metadatas, ids])"
    },
    {
      "type": "p",
      "content": "Async return VectorStore initialized from texts and embeddings."
    },
    {
      "type": "p",
      "content": "aget_by_ids(ids, /)"
    },
    {
      "type": "p",
      "content": "Async get documents by their IDs."
    },
    {
      "type": "p",
      "content": "amax_marginal_relevance_search(query[, k, ...])"
    },
    {
      "type": "p",
      "content": "Async return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "amax_marginal_relevance_search_by_vector(...)"
    },
    {
      "type": "p",
      "content": "Async return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "as_chat(config)"
    },
    {
      "type": "p",
      "content": "Return a Vectara RAG runnable for chat."
    },
    {
      "type": "p",
      "content": "as_rag(config)"
    },
    {
      "type": "p",
      "content": "Return a Vectara RAG runnable."
    },
    {
      "type": "p",
      "content": "as_retriever(**kwargs)"
    },
    {
      "type": "p",
      "content": "return a retriever object."
    },
    {
      "type": "p",
      "content": "asearch(query, search_type, **kwargs)"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to query using a specified search type."
    },
    {
      "type": "p",
      "content": "asimilarity_search(query[, k])"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to query."
    },
    {
      "type": "p",
      "content": "asimilarity_search_by_vector(embedding[, k])"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to embedding vector."
    },
    {
      "type": "p",
      "content": "asimilarity_search_with_relevance_scores(query)"
    },
    {
      "type": "p",
      "content": "Async return docs and relevance scores in the range [0, 1]."
    },
    {
      "type": "p",
      "content": "asimilarity_search_with_score(*args, **kwargs)"
    },
    {
      "type": "p",
      "content": "Async run similarity search with distance."
    },
    {
      "type": "p",
      "content": "delete([ids])"
    },
    {
      "type": "p",
      "content": "Delete by vector ID or other criteria."
    },
    {
      "type": "p",
      "content": "from_documents(documents, embedding, **kwargs)"
    },
    {
      "type": "p",
      "content": "Return VectorStore initialized from documents and embeddings."
    },
    {
      "type": "p",
      "content": "from_files(files[, embedding, metadatas])"
    },
    {
      "type": "p",
      "content": "Construct Vectara wrapper from raw documents."
    },
    {
      "type": "p",
      "content": "from_texts(texts[, embedding, metadatas])"
    },
    {
      "type": "p",
      "content": "Construct Vectara wrapper from raw documents."
    },
    {
      "type": "p",
      "content": "get_by_ids(ids, /)"
    },
    {
      "type": "p",
      "content": "Get documents by their IDs."
    },
    {
      "type": "p",
      "content": "max_marginal_relevance_search(query[, ...])"
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "max_marginal_relevance_search_by_vector(...)"
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "search(query, search_type, **kwargs)"
    },
    {
      "type": "p",
      "content": "Return docs most similar to query using a specified search type."
    },
    {
      "type": "p",
      "content": "similarity_search(query, **kwargs)"
    },
    {
      "type": "p",
      "content": "Return Vectara documents most similar to query, along with scores."
    },
    {
      "type": "p",
      "content": "similarity_search_by_vector(embedding[, k])"
    },
    {
      "type": "p",
      "content": "Return docs most similar to embedding vector."
    },
    {
      "type": "p",
      "content": "similarity_search_with_relevance_scores(query)"
    },
    {
      "type": "p",
      "content": "Return docs and relevance scores in the range [0, 1]."
    },
    {
      "type": "p",
      "content": "similarity_search_with_score(query, **kwargs)"
    },
    {
      "type": "p",
      "content": "Return Vectara documents most similar to query, along with scores."
    },
    {
      "type": "p",
      "content": "vectara_query(query, config, **kwargs)"
    },
    {
      "type": "p",
      "content": "Run a Vectara query"
    },
    {
      "type": "li",
      "content": "vectara_customer_id(Optional[str])"
    },
    {
      "type": "p",
      "content": "vectara_customer_id(Optional[str])"
    },
    {
      "type": "li",
      "content": "vectara_corpus_id(Optional[str])"
    },
    {
      "type": "p",
      "content": "vectara_corpus_id(Optional[str])"
    },
    {
      "type": "li",
      "content": "vectara_api_key(Optional[str])"
    },
    {
      "type": "p",
      "content": "vectara_api_key(Optional[str])"
    },
    {
      "type": "li",
      "content": "vectara_api_timeout(int)"
    },
    {
      "type": "p",
      "content": "vectara_api_timeout(int)"
    },
    {
      "type": "li",
      "content": "source(str)"
    },
    {
      "type": "p",
      "content": "source(str)"
    },
    {
      "type": "p",
      "content": "Initialize with Vectara API."
    },
    {
      "type": "li",
      "content": "vectara_customer_id(str|None)"
    },
    {
      "type": "p",
      "content": "vectara_customer_id(str|None)"
    },
    {
      "type": "li",
      "content": "vectara_corpus_id(str|None)"
    },
    {
      "type": "p",
      "content": "vectara_corpus_id(str|None)"
    },
    {
      "type": "li",
      "content": "vectara_api_key(str|None)"
    },
    {
      "type": "p",
      "content": "vectara_api_key(str|None)"
    },
    {
      "type": "li",
      "content": "vectara_api_timeout(int)"
    },
    {
      "type": "p",
      "content": "vectara_api_timeout(int)"
    },
    {
      "type": "li",
      "content": "source(str)"
    },
    {
      "type": "p",
      "content": "source(str)"
    },
    {
      "type": "p",
      "content": "Async run more documents through the embeddings and add to the vectorstore."
    },
    {
      "type": "li",
      "content": "documents(list[Document]) – Documents to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "documents(list[Document]) – Documents to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "List of IDs of the added texts."
    },
    {
      "type": "p",
      "content": "Async run more texts through the embeddings and add to the vectorstore."
    },
    {
      "type": "li",
      "content": "texts(Iterable[str]) – Iterable of strings to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "texts(Iterable[str]) – Iterable of strings to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "metadatas(Optional[list[dict]]) – Optional list of metadatas associated with the texts.\nDefault is None."
    },
    {
      "type": "p",
      "content": "metadatas(Optional[list[dict]]) – Optional list of metadatas associated with the texts.\nDefault is None."
    },
    {
      "type": "li",
      "content": "ids(Optional[list[str]]) – Optional list"
    },
    {
      "type": "p",
      "content": "ids(Optional[list[str]]) – Optional list"
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – vectorstore specific parameters."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – vectorstore specific parameters."
    },
    {
      "type": "p",
      "content": "List of ids from adding the texts into the vectorstore."
    },
    {
      "type": "li",
      "content": "ValueError– If the number of metadatas does not match the number of texts."
    },
    {
      "type": "p",
      "content": "ValueError– If the number of metadatas does not match the number of texts."
    },
    {
      "type": "li",
      "content": "ValueError– If the number of ids does not match the number of texts."
    },
    {
      "type": "p",
      "content": "ValueError– If the number of ids does not match the number of texts."
    },
    {
      "type": "p",
      "content": "Add or update documents in the vectorstore."
    },
    {
      "type": "li",
      "content": "documents(list[Document]) – Documents to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "documents(list[Document]) – Documents to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments.\nif kwargs contains ids and documents contain ids,\nthe ids in the kwargs will receive precedence."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments.\nif kwargs contains ids and documents contain ids,\nthe ids in the kwargs will receive precedence."
    },
    {
      "type": "p",
      "content": "List of IDs of the added texts."
    },
    {
      "type": "p",
      "content": "Vectara provides a way to add documents directly via our API where\npre-processing and chunking occurs internally in an optimal way\nThis method provides a way to use that API in LangChain"
    },
    {
      "type": "li",
      "content": "files_list(Iterable[str]) – Iterable of strings, each representing a local file path.\nFiles could be text, HTML, PDF, markdown, doc/docx, ppt/pptx, etc.\nsee API docs for full list"
    },
    {
      "type": "p",
      "content": "files_list(Iterable[str]) – Iterable of strings, each representing a local file path.\nFiles could be text, HTML, PDF, markdown, doc/docx, ppt/pptx, etc.\nsee API docs for full list"
    },
    {
      "type": "li",
      "content": "metadatas(List[dict]|None) – Optional list of metadatas associated with each file"
    },
    {
      "type": "p",
      "content": "metadatas(List[dict]|None) – Optional list of metadatas associated with each file"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "List of ids associated with each of the files indexed"
    },
    {
      "type": "p",
      "content": "Run more texts through the embeddings and add to the vectorstore."
    },
    {
      "type": "li",
      "content": "texts(Iterable[str]) – Iterable of strings to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "texts(Iterable[str]) – Iterable of strings to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "metadatas(List[dict]|None) – Optional list of metadatas associated with the texts."
    },
    {
      "type": "p",
      "content": "metadatas(List[dict]|None) – Optional list of metadatas associated with the texts."
    },
    {
      "type": "li",
      "content": "doc_metadata(dict|None) – optional metadata for the document"
    },
    {
      "type": "p",
      "content": "doc_metadata(dict|None) – optional metadata for the document"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "This function indexes all the input text strings in the Vectara corpus as a\nsingle Vectara document, where each input text is considered a “section” and the\nmetadata are associated with each section.\nif ‘doc_metadata’ is provided, it is associated with the Vectara document."
    },
    {
      "type": "p",
      "content": "document ID of the document added"
    },
    {
      "type": "li",
      "content": "texts(Iterable[str])"
    },
    {
      "type": "p",
      "content": "texts(Iterable[str])"
    },
    {
      "type": "li",
      "content": "metadatas(List[dict]|None)"
    },
    {
      "type": "p",
      "content": "metadatas(List[dict]|None)"
    },
    {
      "type": "li",
      "content": "doc_metadata(dict|None)"
    },
    {
      "type": "p",
      "content": "doc_metadata(dict|None)"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "Async delete by vector ID or other criteria."
    },
    {
      "type": "li",
      "content": "ids(list[str]|None) – List of ids to delete. If None, delete all. Default is None."
    },
    {
      "type": "p",
      "content": "ids(list[str]|None) – List of ids to delete. If None, delete all. Default is None."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Other keyword arguments that subclasses might use."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Other keyword arguments that subclasses might use."
    },
    {
      "type": "p",
      "content": "True if deletion is successful,\nFalse otherwise, None if not implemented."
    },
    {
      "type": "p",
      "content": "Optional[bool]"
    },
    {
      "type": "p",
      "content": "Async return VectorStore initialized from documents and embeddings."
    },
    {
      "type": "li",
      "content": "documents(list[Document]) – List of Documents to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "documents(list[Document]) – List of Documents to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "p",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "VectorStore initialized from documents and embeddings."
    },
    {
      "type": "p",
      "content": "VectorStore"
    },
    {
      "type": "p",
      "content": "Async return VectorStore initialized from texts and embeddings."
    },
    {
      "type": "li",
      "content": "texts(list[str]) – Texts to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "texts(list[str]) – Texts to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "p",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "li",
      "content": "metadatas(list[dict]|None) – Optional list of metadatas associated with the texts.\nDefault is None."
    },
    {
      "type": "p",
      "content": "metadatas(list[dict]|None) – Optional list of metadatas associated with the texts.\nDefault is None."
    },
    {
      "type": "li",
      "content": "ids(list[str]|None) – Optional list of IDs associated with the texts."
    },
    {
      "type": "p",
      "content": "ids(list[str]|None) – Optional list of IDs associated with the texts."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "VectorStore initialized from texts and embeddings."
    },
    {
      "type": "p",
      "content": "VectorStore"
    },
    {
      "type": "p",
      "content": "Async get documents by their IDs."
    },
    {
      "type": "p",
      "content": "The returned documents are expected to have the ID field set to the ID of the\ndocument in the vector store."
    },
    {
      "type": "p",
      "content": "Fewer documents may be returned than requested if some IDs are not found or\nif there are duplicated IDs."
    },
    {
      "type": "p",
      "content": "Users should not assume that the order of the returned documents matches\nthe order of the input IDs. Instead, users should rely on the ID field of the\nreturned documents."
    },
    {
      "type": "p",
      "content": "This method shouldNOTraise exceptions if no documents are found for\nsome IDs."
    },
    {
      "type": "p",
      "content": "ids(Sequence[str]) – List of ids to retrieve."
    },
    {
      "type": "p",
      "content": "List of Documents."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Added in version 0.2.11."
    },
    {
      "type": "p",
      "content": "Async return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "Maximal marginal relevance optimizes for similarity to query AND diversity\namong selected documents."
    },
    {
      "type": "li",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "p",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Async return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "Maximal marginal relevance optimizes for similarity to query AND diversity\namong selected documents."
    },
    {
      "type": "li",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Return a Vectara RAG runnable for chat."
    },
    {
      "type": "p",
      "content": "config(VectaraQueryConfig)"
    },
    {
      "type": "p",
      "content": "Return a Vectara RAG runnable."
    },
    {
      "type": "p",
      "content": "config(VectaraQueryConfig)"
    },
    {
      "type": "p",
      "content": "return a retriever object."
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "VectaraRetriever"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to query using a specified search type."
    },
    {
      "type": "li",
      "content": "query(str) – Input text."
    },
    {
      "type": "p",
      "content": "query(str) – Input text."
    },
    {
      "type": "li",
      "content": "search_type(str) – Type of search to perform. Can be “similarity”,\n“mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "search_type(str) – Type of search to perform. Can be “similarity”,\n“mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query."
    },
    {
      "type": "p",
      "content": "ValueError– If search_type is not one of “similarity”,\n    “mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to query."
    },
    {
      "type": "li",
      "content": "query(str) – Input text."
    },
    {
      "type": "p",
      "content": "query(str) – Input text."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Async return docs most similar to embedding vector."
    },
    {
      "type": "li",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query vector."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Async return docs and relevance scores in the range [0, 1]."
    },
    {
      "type": "p",
      "content": "0 is dissimilar, 1 is most similar."
    },
    {
      "type": "li",
      "content": "query(str) – Input text."
    },
    {
      "type": "p",
      "content": "query(str) – Input text."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) –kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 tofilter the resulting set of retrieved docs"
    },
    {
      "type": "p",
      "content": "**kwargs(Any) –kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 tofilter the resulting set of retrieved docs"
    },
    {
      "type": "p",
      "content": "kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 to"
    },
    {
      "type": "p",
      "content": "filter the resulting set of retrieved docs"
    },
    {
      "type": "p",
      "content": "List of Tuples of (doc, similarity_score)"
    },
    {
      "type": "p",
      "content": "list[tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Async run similarity search with distance."
    },
    {
      "type": "li",
      "content": "*args(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "*args(Any) – Arguments to pass to the search method."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Tuples of (doc, similarity_score)."
    },
    {
      "type": "p",
      "content": "list[tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Delete by vector ID or other criteria.\n:param ids: List of ids to delete."
    },
    {
      "type": "p",
      "content": "True if deletion is successful,\nFalse otherwise, None if not implemented."
    },
    {
      "type": "p",
      "content": "Optional[bool]"
    },
    {
      "type": "li",
      "content": "ids(List[str]|None)"
    },
    {
      "type": "p",
      "content": "ids(List[str]|None)"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "Return VectorStore initialized from documents and embeddings."
    },
    {
      "type": "li",
      "content": "documents(list[Document]) – List of Documents to add to the vectorstore."
    },
    {
      "type": "p",
      "content": "documents(list[Document]) – List of Documents to add to the vectorstore."
    },
    {
      "type": "li",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "p",
      "content": "embedding(Embeddings) – Embedding function to use."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "kwargs(Any) – Additional keyword arguments."
    },
    {
      "type": "p",
      "content": "VectorStore initialized from documents and embeddings."
    },
    {
      "type": "p",
      "content": "VectorStore"
    },
    {
      "type": "p",
      "content": "Construct Vectara wrapper from raw documents.\nThis is intended to be a quick way to get started.\n.. rubric:: Example"
    },
    {
      "type": "li",
      "content": "files(List[str])"
    },
    {
      "type": "p",
      "content": "files(List[str])"
    },
    {
      "type": "li",
      "content": "embedding(Embeddings|None)"
    },
    {
      "type": "p",
      "content": "embedding(Embeddings|None)"
    },
    {
      "type": "li",
      "content": "metadatas(List[dict]|None)"
    },
    {
      "type": "p",
      "content": "metadatas(List[dict]|None)"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "Construct Vectara wrapper from raw documents.\nThis is intended to be a quick way to get started.\n.. rubric:: Example"
    },
    {
      "type": "li",
      "content": "texts(List[str])"
    },
    {
      "type": "p",
      "content": "texts(List[str])"
    },
    {
      "type": "li",
      "content": "embedding(Embeddings|None)"
    },
    {
      "type": "p",
      "content": "embedding(Embeddings|None)"
    },
    {
      "type": "li",
      "content": "metadatas(List[dict]|None)"
    },
    {
      "type": "p",
      "content": "metadatas(List[dict]|None)"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "Get documents by their IDs."
    },
    {
      "type": "p",
      "content": "The returned documents are expected to have the ID field set to the ID of the\ndocument in the vector store."
    },
    {
      "type": "p",
      "content": "Fewer documents may be returned than requested if some IDs are not found or\nif there are duplicated IDs."
    },
    {
      "type": "p",
      "content": "Users should not assume that the order of the returned documents matches\nthe order of the input IDs. Instead, users should rely on the ID field of the\nreturned documents."
    },
    {
      "type": "p",
      "content": "This method shouldNOTraise exceptions if no documents are found for\nsome IDs."
    },
    {
      "type": "p",
      "content": "ids(Sequence[str]) – List of ids to retrieve."
    },
    {
      "type": "p",
      "content": "List of Documents."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Added in version 0.2.11."
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance.\nMaximal marginal relevance optimizes for similarity to query AND diversity\namong selected documents."
    },
    {
      "type": "li",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "p",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k– Number of Documents to return. Defaults to 5."
    },
    {
      "type": "p",
      "content": "k– Number of Documents to return. Defaults to 5."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefaults to 50"
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefaults to 50"
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "kwargs(Any) – any other querying variable in VectaraQueryConfig"
    },
    {
      "type": "p",
      "content": "kwargs(Any) – any other querying variable in VectaraQueryConfig"
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "List[Document]"
    },
    {
      "type": "p",
      "content": "Return docs selected using the maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "Maximal marginal relevance optimizes for similarity to query AND diversity\namong selected documents."
    },
    {
      "type": "li",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "p",
      "content": "fetch_k(int) – Number of Documents to fetch to pass to MMR algorithm.\nDefault is 20."
    },
    {
      "type": "li",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "p",
      "content": "lambda_mult(float) – Number between 0 and 1 that determines the degree\nof diversity among the results with 0 corresponding\nto maximum diversity and 1 to minimum diversity.\nDefaults to 0.5."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents selected by maximal marginal relevance."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Return docs most similar to query using a specified search type."
    },
    {
      "type": "li",
      "content": "query(str) – Input text"
    },
    {
      "type": "p",
      "content": "query(str) – Input text"
    },
    {
      "type": "li",
      "content": "search_type(str) – Type of search to perform. Can be “similarity”,\n“mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "search_type(str) – Type of search to perform. Can be “similarity”,\n“mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query."
    },
    {
      "type": "p",
      "content": "ValueError– If search_type is not one of “similarity”,\n    “mmr”, or “similarity_score_threshold”."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Return Vectara documents most similar to query, along with scores."
    },
    {
      "type": "li",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "p",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "li",
      "content": "VectaraQueryConfig(any other querying variable in)"
    },
    {
      "type": "p",
      "content": "VectaraQueryConfig(any other querying variable in)"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query"
    },
    {
      "type": "p",
      "content": "List[Document]"
    },
    {
      "type": "p",
      "content": "Return docs most similar to embedding vector."
    },
    {
      "type": "li",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "p",
      "content": "embedding(list[float]) – Embedding to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) – Arguments to pass to the search method."
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query vector."
    },
    {
      "type": "p",
      "content": "list[Document]"
    },
    {
      "type": "p",
      "content": "Return docs and relevance scores in the range [0, 1]."
    },
    {
      "type": "p",
      "content": "0 is dissimilar, 1 is most similar."
    },
    {
      "type": "li",
      "content": "query(str) – Input text."
    },
    {
      "type": "p",
      "content": "query(str) – Input text."
    },
    {
      "type": "li",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "p",
      "content": "k(int) – Number of Documents to return. Defaults to 4."
    },
    {
      "type": "li",
      "content": "**kwargs(Any) –kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 tofilter the resulting set of retrieved docs."
    },
    {
      "type": "p",
      "content": "**kwargs(Any) –kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 tofilter the resulting set of retrieved docs."
    },
    {
      "type": "p",
      "content": "kwargs to be passed to similarity search. Should include:\nscore_threshold: Optional, a floating point value between 0 to 1 to"
    },
    {
      "type": "p",
      "content": "filter the resulting set of retrieved docs."
    },
    {
      "type": "p",
      "content": "List of Tuples of (doc, similarity_score)."
    },
    {
      "type": "p",
      "content": "list[tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Return Vectara documents most similar to query, along with scores."
    },
    {
      "type": "li",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "p",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "li",
      "content": "k– Number of Documents to return. Defaults to 10."
    },
    {
      "type": "p",
      "content": "k– Number of Documents to return. Defaults to 10."
    },
    {
      "type": "li",
      "content": "like(any other querying variable in VectaraQueryConfig)"
    },
    {
      "type": "p",
      "content": "like(any other querying variable in VectaraQueryConfig)"
    },
    {
      "type": "li",
      "content": "lambda_val(-) – lexical match parameter for hybrid search."
    },
    {
      "type": "p",
      "content": "lambda_val(-) – lexical match parameter for hybrid search."
    },
    {
      "type": "li",
      "content": "filter(-) – filter string"
    },
    {
      "type": "p",
      "content": "filter(-) – filter string"
    },
    {
      "type": "li",
      "content": "score_threshold(-) – minimal score threshold for the result."
    },
    {
      "type": "p",
      "content": "score_threshold(-) – minimal score threshold for the result."
    },
    {
      "type": "li",
      "content": "n_sentence_before(-) – number of sentences before the matching segment"
    },
    {
      "type": "p",
      "content": "n_sentence_before(-) – number of sentences before the matching segment"
    },
    {
      "type": "li",
      "content": "n_sentence_after(-) – number of sentences after the matching segment"
    },
    {
      "type": "p",
      "content": "n_sentence_after(-) – number of sentences after the matching segment"
    },
    {
      "type": "li",
      "content": "rerank_config(-) – optional configuration for Reranking\n(see RerankConfig dataclass)"
    },
    {
      "type": "p",
      "content": "rerank_config(-) – optional configuration for Reranking\n(see RerankConfig dataclass)"
    },
    {
      "type": "li",
      "content": "summary_config(-) – optional configuration for summary\n(see SummaryConfig dataclass)"
    },
    {
      "type": "p",
      "content": "summary_config(-) – optional configuration for summary\n(see SummaryConfig dataclass)"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "List of Documents most similar to the query and score for each."
    },
    {
      "type": "p",
      "content": "List[Tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Run a Vectara query"
    },
    {
      "type": "li",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "p",
      "content": "query(str) – Text to look up documents similar to."
    },
    {
      "type": "li",
      "content": "config(VectaraQueryConfig) – VectaraQueryConfig object"
    },
    {
      "type": "p",
      "content": "config(VectaraQueryConfig) – VectaraQueryConfig object"
    },
    {
      "type": "li",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "kwargs(Any)"
    },
    {
      "type": "p",
      "content": "A list of k Documents matching the given query\nIf summary is enabled, last document is the summary text with ‘summary’=True"
    },
    {
      "type": "p",
      "content": "List[Tuple[Document, float]]"
    },
    {
      "type": "p",
      "content": "Examples using Vectara"
    },
    {
      "type": "li",
      "content": "Vectara Chat"
    },
    {
      "type": "p",
      "content": "Vectara Chat"
    },
    {
      "type": "li",
      "content": "Vectara self-querying"
    },
    {
      "type": "p",
      "content": "Vectara self-querying"
    },
    {
      "type": "li",
      "content": "Vectara__init__()aadd_documents()aadd_texts()add_documents()add_files()add_texts()adelete()afrom_documents()afrom_texts()aget_by_ids()amax_marginal_relevance_search()amax_marginal_relevance_search_by_vector()as_chat()as_rag()as_retriever()asearch()asimilarity_search()asimilarity_search_by_vector()asimilarity_search_with_relevance_scores()asimilarity_search_with_score()delete()from_documents()from_files()from_texts()get_by_ids()max_marginal_relevance_search()max_marginal_relevance_search_by_vector()search()similarity_search()similarity_search_by_vector()similarity_search_with_relevance_scores()similarity_search_with_score()vectara_query()"
    },
    {
      "type": "li",
      "content": "aadd_documents()"
    },
    {
      "type": "li",
      "content": "aadd_texts()"
    },
    {
      "type": "li",
      "content": "add_documents()"
    },
    {
      "type": "li",
      "content": "add_files()"
    },
    {
      "type": "li",
      "content": "add_texts()"
    },
    {
      "type": "li",
      "content": "afrom_documents()"
    },
    {
      "type": "li",
      "content": "afrom_texts()"
    },
    {
      "type": "li",
      "content": "aget_by_ids()"
    },
    {
      "type": "li",
      "content": "amax_marginal_relevance_search()"
    },
    {
      "type": "li",
      "content": "amax_marginal_relevance_search_by_vector()"
    },
    {
      "type": "li",
      "content": "as_retriever()"
    },
    {
      "type": "li",
      "content": "asimilarity_search()"
    },
    {
      "type": "li",
      "content": "asimilarity_search_by_vector()"
    },
    {
      "type": "li",
      "content": "asimilarity_search_with_relevance_scores()"
    },
    {
      "type": "li",
      "content": "asimilarity_search_with_score()"
    },
    {
      "type": "li",
      "content": "from_documents()"
    },
    {
      "type": "li",
      "content": "from_files()"
    },
    {
      "type": "li",
      "content": "from_texts()"
    },
    {
      "type": "li",
      "content": "get_by_ids()"
    },
    {
      "type": "li",
      "content": "max_marginal_relevance_search()"
    },
    {
      "type": "li",
      "content": "max_marginal_relevance_search_by_vector()"
    },
    {
      "type": "li",
      "content": "similarity_search()"
    },
    {
      "type": "li",
      "content": "similarity_search_by_vector()"
    },
    {
      "type": "li",
      "content": "similarity_search_with_relevance_scores()"
    },
    {
      "type": "li",
      "content": "similarity_search_with_score()"
    },
    {
      "type": "li",
      "content": "vectara_query()"
    }
  ],
  "code_examples": [
    "vectorstores",
    "fromlangchain_community.vectorstoresimportVectaravectorstore=Vectara(vectara_customer_id=vectara_customer_id,vectara_corpus_id=vectara_corpus_id,vectara_api_key=vectara_api_key)",
    "embeddings",
    "__init__",
    "aadd_documents",
    "aadd_texts",
    "add_documents",
    "add_files",
    "add_texts",
    "adelete",
    "afrom_documents",
    "afrom_texts",
    "aget_by_ids",
    "amax_marginal_relevance_search",
    "amax_marginal_relevance_search_by_vector",
    "as_chat",
    "as_rag",
    "as_retriever",
    "asearch",
    "asimilarity_search",
    "asimilarity_search_by_vector",
    "asimilarity_search_with_relevance_scores",
    "asimilarity_search_with_score",
    "delete",
    "from_documents",
    "from_files",
    "from_texts",
    "get_by_ids",
    "max_marginal_relevance_search",
    "max_marginal_relevance_search_by_vector",
    "search",
    "similarity_search",
    "similarity_search_by_vector",
    "similarity_search_with_relevance_scores",
    "similarity_search_with_score",
    "vectara_query",
    "fromlangchain_community.vectorstoresimportVectaravectara=Vectara.from_files(files_list,vectara_customer_id=customer_id,vectara_corpus_id=corpus_id,vectara_api_key=api_key,)",
    "fromlangchain_community.vectorstoresimportVectaravectara=Vectara.from_texts(texts,vectara_customer_id=customer_id,vectara_corpus_id=corpus_id,vectara_api_key=api_key,)",
    "Vectara",
    "__init__()",
    "aadd_documents()",
    "aadd_texts()",
    "add_documents()",
    "add_files()",
    "add_texts()",
    "adelete()",
    "afrom_documents()",
    "afrom_texts()",
    "aget_by_ids()",
    "amax_marginal_relevance_search()",
    "amax_marginal_relevance_search_by_vector()",
    "as_chat()",
    "as_rag()",
    "as_retriever()",
    "asearch()",
    "asimilarity_search()",
    "asimilarity_search_by_vector()",
    "asimilarity_search_with_relevance_scores()",
    "asimilarity_search_with_score()",
    "delete()",
    "from_documents()",
    "from_files()",
    "from_texts()",
    "get_by_ids()",
    "max_marginal_relevance_search()",
    "max_marginal_relevance_search_by_vector()",
    "search()",
    "similarity_search()",
    "similarity_search_by_vector()",
    "similarity_search_with_relevance_scores()",
    "similarity_search_with_score()",
    "vectara_query()"
  ],
  "api_signatures": [
    "classlangchain_community.vectorstores.vectara.Vectara(vectara_customer_id:str|None=None,vectara_corpus_id:str|None=None,vectara_api_key:str|None=None,vectara_api_timeout:int=120,source:str='langchain',)[source]#",
    "langchain_community.vectorstores.vectara.",
    "Vectara",
    "(",
    "vectara_customer_id:str|None=None",
    "vectara_corpus_id:str|None=None",
    "vectara_api_key:str|None=None",
    "vectara_api_timeout:int=120",
    "source:str='langchain'",
    ")",
    "__init__(vectara_customer_id:str|None=None,vectara_corpus_id:str|None=None,vectara_api_key:str|None=None,vectara_api_timeout:int=120,source:str='langchain',)[source]#",
    "__init__",
    "(",
    "vectara_customer_id:str|None=None",
    "vectara_corpus_id:str|None=None",
    "vectara_api_key:str|None=None",
    "vectara_api_timeout:int=120",
    "source:str='langchain'",
    ")",
    "asyncaadd_documents(documents:list[Document],**kwargs:Any,)→list[str]#",
    "aadd_documents",
    "(",
    "documents:list[Document]",
    "**kwargs:Any",
    ")",
    "→list[str]",
    "→",
    "list[str]",
    "asyncaadd_texts(texts:Iterable[str],metadatas:list[dict]|None=None,*,ids:list[str]|None=None,**kwargs:Any,)→list[str]#",
    "aadd_texts",
    "(",
    "texts:Iterable[str]",
    "metadatas:list[dict]|None=None",
    "*",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    ")",
    "→list[str]",
    "→",
    "list[str]",
    "add_documents(documents:list[Document],**kwargs:Any,)→list[str]#",
    "add_documents",
    "(",
    "documents:list[Document]",
    "**kwargs:Any",
    ")",
    "→list[str]",
    "→",
    "list[str]",
    "add_files(files_list:Iterable[str],metadatas:List[dict]|None=None,**kwargs:Any,)→List[str][source]#",
    "add_files",
    "(",
    "files_list:Iterable[str]",
    "metadatas:List[dict]|None=None",
    "**kwargs:Any",
    ")",
    "→List[str]",
    "→",
    "List[str]",
    "add_texts(texts:Iterable[str],metadatas:List[dict]|None=None,doc_metadata:dict|None=None,**kwargs:Any,)→List[str][source]#",
    "add_texts",
    "(",
    "texts:Iterable[str]",
    "metadatas:List[dict]|None=None",
    "doc_metadata:dict|None=None",
    "**kwargs:Any",
    ")",
    "→List[str]",
    "→",
    "List[str]",
    "asyncadelete(ids:list[str]|None=None,**kwargs:Any,)→bool|None#",
    "adelete",
    "(",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    ")",
    "→bool|None",
    "→",
    "bool|None",
    "asyncclassmethodafrom_documents(documents:list[Document],embedding:Embeddings,**kwargs:Any,)→Self#",
    "afrom_documents",
    "(",
    "documents:list[Document]",
    "embedding:Embeddings",
    "**kwargs:Any",
    ")",
    "→Self",
    "→",
    "Self",
    "asyncclassmethodafrom_texts(texts:list[str],embedding:Embeddings,metadatas:list[dict]|None=None,*,ids:list[str]|None=None,**kwargs:Any,)→Self#",
    "afrom_texts",
    "(",
    "texts:list[str]",
    "embedding:Embeddings",
    "metadatas:list[dict]|None=None",
    "*",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    ")",
    "→Self",
    "→",
    "Self",
    "asyncaget_by_ids(ids:Sequence[str],/)→list[Document]#",
    "aget_by_ids",
    "(",
    "ids:Sequence[str]",
    "/",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncamax_marginal_relevance_search(query:str,k:int=4,fetch_k:int=20,lambda_mult:float=0.5,**kwargs:Any,)→list[Document]#",
    "amax_marginal_relevance_search",
    "(",
    "query:str",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncamax_marginal_relevance_search_by_vector(embedding:list[float],k:int=4,fetch_k:int=20,lambda_mult:float=0.5,**kwargs:Any,)→list[Document]#",
    "amax_marginal_relevance_search_by_vector",
    "(",
    "embedding:list[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "as_chat(config:VectaraQueryConfig,)→VectaraRAG[source]#",
    "as_chat",
    "(",
    "config:VectaraQueryConfig",
    ")",
    "→VectaraRAG",
    "→",
    "VectaraRAG",
    "as_rag(config:VectaraQueryConfig,)→VectaraRAG[source]#",
    "as_rag",
    "(",
    "config:VectaraQueryConfig",
    ")",
    "→VectaraRAG",
    "→",
    "VectaraRAG",
    "as_retriever(**kwargs:Any,)→VectaraRetriever[source]#",
    "as_retriever",
    "(",
    "**kwargs:Any",
    ")",
    "→VectaraRetriever",
    "→",
    "VectaraRetriever",
    "asyncasearch(query:str,search_type:str,**kwargs:Any,)→list[Document]#",
    "asearch",
    "(",
    "query:str",
    "search_type:str",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncasimilarity_search(query:str,k:int=4,**kwargs:Any,)→list[Document]#",
    "asimilarity_search",
    "(",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncasimilarity_search_by_vector(embedding:list[float],k:int=4,**kwargs:Any,)→list[Document]#",
    "asimilarity_search_by_vector",
    "(",
    "embedding:list[float]",
    "k:int=4",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "asyncasimilarity_search_with_relevance_scores(query:str,k:int=4,**kwargs:Any,)→list[tuple[Document,float]]#",
    "asimilarity_search_with_relevance_scores",
    "(",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    ")",
    "→list[tuple[Document,float]]",
    "→",
    "list[tuple[Document,float]]",
    "asyncasimilarity_search_with_score(*args:Any,**kwargs:Any,)→list[tuple[Document,float]]#",
    "asimilarity_search_with_score",
    "(",
    "*args:Any",
    "**kwargs:Any",
    ")",
    "→list[tuple[Document,float]]",
    "→",
    "list[tuple[Document,float]]",
    "delete(ids:List[str]|None=None,**kwargs:Any,)→bool|None[source]#",
    "delete",
    "(",
    "ids:List[str]|None=None",
    "**kwargs:Any",
    ")",
    "→bool|None",
    "→",
    "bool|None",
    "classmethodfrom_documents(documents:list[Document],embedding:Embeddings,**kwargs:Any,)→Self#",
    "from_documents",
    "(",
    "documents:list[Document]",
    "embedding:Embeddings",
    "**kwargs:Any",
    ")",
    "→Self",
    "→",
    "Self",
    "classmethodfrom_files(files:List[str],embedding:Embeddings|None=None,metadatas:List[dict]|None=None,**kwargs:Any,)→Vectara[source]#",
    "from_files",
    "(",
    "files:List[str]",
    "embedding:Embeddings|None=None",
    "metadatas:List[dict]|None=None",
    "**kwargs:Any",
    ")",
    "→Vectara",
    "→",
    "Vectara",
    "classmethodfrom_texts(texts:List[str],embedding:Embeddings|None=None,metadatas:List[dict]|None=None,**kwargs:Any,)→Vectara[source]#",
    "from_texts",
    "(",
    "texts:List[str]",
    "embedding:Embeddings|None=None",
    "metadatas:List[dict]|None=None",
    "**kwargs:Any",
    ")",
    "→Vectara",
    "→",
    "Vectara",
    "get_by_ids(ids:Sequence[str],/)→list[Document]#",
    "get_by_ids",
    "(",
    "ids:Sequence[str]",
    "/",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "max_marginal_relevance_search(query:str,fetch_k:int=50,lambda_mult:float=0.5,**kwargs:Any,)→List[Document][source]#",
    "max_marginal_relevance_search",
    "(",
    "query:str",
    "fetch_k:int=50",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    ")",
    "→List[Document]",
    "→",
    "List[Document]",
    "max_marginal_relevance_search_by_vector(embedding:list[float],k:int=4,fetch_k:int=20,lambda_mult:float=0.5,**kwargs:Any,)→list[Document]#",
    "max_marginal_relevance_search_by_vector",
    "(",
    "embedding:list[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "search(query:str,search_type:str,**kwargs:Any,)→list[Document]#",
    "search",
    "(",
    "query:str",
    "search_type:str",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "similarity_search(query:str,**kwargs:Any,)→List[Document][source]#",
    "similarity_search",
    "(",
    "query:str",
    "**kwargs:Any",
    ")",
    "→List[Document]",
    "→",
    "List[Document]",
    "similarity_search_by_vector(embedding:list[float],k:int=4,**kwargs:Any,)→list[Document]#",
    "similarity_search_by_vector",
    "(",
    "embedding:list[float]",
    "k:int=4",
    "**kwargs:Any",
    ")",
    "→list[Document]",
    "→",
    "list[Document]",
    "similarity_search_with_relevance_scores(query:str,k:int=4,**kwargs:Any,)→list[tuple[Document,float]]#",
    "similarity_search_with_relevance_scores",
    "(",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    ")",
    "→list[tuple[Document,float]]",
    "→",
    "list[tuple[Document,float]]",
    "similarity_search_with_score(query:str,**kwargs:Any,)→List[Tuple[Document,float]][source]#",
    "similarity_search_with_score",
    "(",
    "query:str",
    "**kwargs:Any",
    ")",
    "→List[Tuple[Document,float]]",
    "→",
    "List[Tuple[Document,float]]",
    "vectara_query(query:str,config:VectaraQueryConfig,**kwargs:Any,)→List[Tuple[Document,float]][source]#",
    "vectara_query",
    "(",
    "query:str",
    "config:VectaraQueryConfig",
    "**kwargs:Any",
    ")",
    "→List[Tuple[Document,float]]",
    "→",
    "List[Tuple[Document,float]]"
  ],
  "parameters": [
    "vectara_customer_id:str|None=None",
    "vectara_corpus_id:str|None=None",
    "vectara_api_key:str|None=None",
    "vectara_api_timeout:int=120",
    "source:str='langchain'",
    "vectara_customer_id:str|None=None",
    "vectara_corpus_id:str|None=None",
    "vectara_api_key:str|None=None",
    "vectara_api_timeout:int=120",
    "source:str='langchain'",
    "documents:list[Document]",
    "**kwargs:Any",
    "texts:Iterable[str]",
    "metadatas:list[dict]|None=None",
    "*",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    "documents:list[Document]",
    "**kwargs:Any",
    "files_list:Iterable[str]",
    "metadatas:List[dict]|None=None",
    "**kwargs:Any",
    "texts:Iterable[str]",
    "metadatas:List[dict]|None=None",
    "doc_metadata:dict|None=None",
    "**kwargs:Any",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    "documents:list[Document]",
    "embedding:Embeddings",
    "**kwargs:Any",
    "texts:list[str]",
    "embedding:Embeddings",
    "metadatas:list[dict]|None=None",
    "*",
    "ids:list[str]|None=None",
    "**kwargs:Any",
    "ids:Sequence[str]",
    "/",
    "query:str",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    "embedding:list[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    "config:VectaraQueryConfig",
    "config:VectaraQueryConfig",
    "**kwargs:Any",
    "query:str",
    "search_type:str",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    "embedding:list[float]",
    "k:int=4",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    "*args:Any",
    "**kwargs:Any",
    "ids:List[str]|None=None",
    "**kwargs:Any",
    "documents:list[Document]",
    "embedding:Embeddings",
    "**kwargs:Any",
    "files:List[str]",
    "embedding:Embeddings|None=None",
    "metadatas:List[dict]|None=None",
    "**kwargs:Any",
    "texts:List[str]",
    "embedding:Embeddings|None=None",
    "metadatas:List[dict]|None=None",
    "**kwargs:Any",
    "ids:Sequence[str]",
    "/",
    "query:str",
    "fetch_k:int=50",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    "embedding:list[float]",
    "k:int=4",
    "fetch_k:int=20",
    "lambda_mult:float=0.5",
    "**kwargs:Any",
    "query:str",
    "search_type:str",
    "**kwargs:Any",
    "query:str",
    "**kwargs:Any",
    "embedding:list[float]",
    "k:int=4",
    "**kwargs:Any",
    "query:str",
    "k:int=4",
    "**kwargs:Any",
    "query:str",
    "**kwargs:Any",
    "query:str",
    "config:VectaraQueryConfig",
    "**kwargs:Any"
  ]
}
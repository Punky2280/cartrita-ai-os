{
  "url": "https://python.langchain.com/api_reference/_modules/langchain_community/vectorstores/redis/schema.html#TagFieldSchema",
  "title": "Source code for langchain_community.vectorstores.redis.schema",
  "sections": [
    {
      "type": "li",
      "content": "Module code"
    },
    {
      "type": "li",
      "content": "langchain_community.vectorstores.redis.schema"
    }
  ],
  "code_examples": [
    "from__future__importannotationsimportosfromenumimportEnumfrompathlibimportPathfromtypingimportAny,Dict,List,Optional,Unionimportnumpyasnpimportyamlfromlangchain_core.utils.pydanticimportget_fieldsfrompydanticimportBaseModel,Field,field_validator,validatorfromtyping_extensionsimportTYPE_CHECKING,Literalfromlangchain_community.vectorstores.redis.constantsimportREDIS_VECTOR_DTYPE_MAPifTYPE_CHECKING:fromredis.commands.search.fieldimport(NumericField,TagField,TextField,VectorField,)[docs]classRedisDistanceMetric(str,Enum):\"\"\"Distance metrics for Redis vector fields.\"\"\"l2=\"L2\"cosine=\"COSINE\"ip=\"IP\"[docs]classRedisField(BaseModel):\"\"\"Base class for Redis fields.\"\"\"name:str=Field(...)[docs]classTextFieldSchema(RedisField):\"\"\"Schema for text fields in Redis.\"\"\"weight:float=1no_stem:bool=Falsephonetic_matcher:Optional[str]=Nonewithsuffixtrie:bool=Falseno_index:bool=Falsesortable:Optional[bool]=False[docs]defas_field(self)->TextField:fromredis.commands.search.fieldimportTextFieldreturnTextField(self.name,weight=self.weight,no_stem=self.no_stem,phonetic_matcher=self.phonetic_matcher,sortable=self.sortable,no_index=self.no_index,)[docs]classTagFieldSchema(RedisField):\"\"\"Schema for tag fields in Redis.\"\"\"separator:str=\",\"case_sensitive:bool=Falseno_index:bool=Falsesortable:Optional[bool]=False[docs]defas_field(self)->TagField:fromredis.commands.search.fieldimportTagFieldreturnTagField(self.name,separator=self.separator,case_sensitive=self.case_sensitive,sortable=self.sortable,no_index=self.no_index,)[docs]classNumericFieldSchema(RedisField):\"\"\"Schema for numeric fields in Redis.\"\"\"no_index:bool=Falsesortable:Optional[bool]=False[docs]defas_field(self)->NumericField:fromredis.commands.search.fieldimportNumericFieldreturnNumericField(self.name,sortable=self.sortable,no_index=self.no_index)[docs]classRedisVectorField(RedisField):\"\"\"Base class for Redis vector fields.\"\"\"dims:int=Field(...)algorithm:object=Field(...)datatype:str=Field(default=\"FLOAT32\")distance_metric:RedisDistanceMetric=Field(default=\"COSINE\")# type: ignore[assignment]initial_cap:Optional[int]=None@field_validator(\"algorithm\",\"datatype\",\"distance_metric\",mode=\"before\")@classmethoddefuppercase_strings(cls,v:str)->str:returnv.upper()[docs]@validator(\"datatype\",pre=True)defuppercase_and_check_dtype(cls,v:str)->str:ifv.upper()notinREDIS_VECTOR_DTYPE_MAP:raiseValueError(f\"datatype must be one of{REDIS_VECTOR_DTYPE_MAP.keys()}. Got{v}\")returnv.upper()def_fields(self)->Dict[str,Any]:field_data={\"TYPE\":self.datatype,\"DIM\":self.dims,\"DISTANCE_METRIC\":self.distance_metric,}ifself.initial_capisnotNone:# Only include it if it's setfield_data[\"INITIAL_CAP\"]=self.initial_capreturnfield_data[docs]classFlatVectorField(RedisVectorField):\"\"\"Schema for flat vector fields in Redis.\"\"\"algorithm:Literal[\"FLAT\"]=\"FLAT\"block_size:Optional[int]=None[docs]defas_field(self)->VectorField:fromredis.commands.search.fieldimportVectorFieldfield_data=super()._fields()ifself.block_sizeisnotNone:field_data[\"BLOCK_SIZE\"]=self.block_sizereturnVectorField(self.name,self.algorithm,field_data)[docs]classHNSWVectorField(RedisVectorField):\"\"\"Schema for HNSW vector fields in Redis.\"\"\"algorithm:Literal[\"HNSW\"]=\"HNSW\"m:int=Field(default=16)ef_construction:int=Field(default=200)ef_runtime:int=Field(default=10)epsilon:float=Field(default=0.01)[docs]defas_field(self)->VectorField:fromredis.commands.search.fieldimportVectorFieldfield_data=super()._fields()field_data.update({\"M\":self.m,\"EF_CONSTRUCTION\":self.ef_construction,\"EF_RUNTIME\":self.ef_runtime,\"EPSILON\":self.epsilon,})returnVectorField(self.name,self.algorithm,field_data)[docs]classRedisModel(BaseModel):\"\"\"Schema for Redis index.\"\"\"# always have a content field for texttext:List[TextFieldSchema]=[TextFieldSchema(name=\"content\")]tag:Optional[List[TagFieldSchema]]=Nonenumeric:Optional[List[NumericFieldSchema]]=Noneextra:Optional[List[RedisField]]=None# filled by default_vector_schemavector:Optional[List[Union[FlatVectorField,HNSWVectorField]]]=Nonecontent_key:str=\"content\"content_vector_key:str=\"content_vector\"[docs]defadd_content_field(self)->None:ifself.textisNone:self.text=[]forfieldinself.text:iffield.name==self.content_key:returnself.text.append(TextFieldSchema(name=self.content_key))[docs]defadd_vector_field(self,vector_field:Dict[str,Any])->None:# catch case where user inputted no vector field spec# in the index schemaifself.vectorisNone:self.vector=[]# ignore types as pydantic is handling type validation and conversionifvector_field[\"algorithm\"]==\"FLAT\":self.vector.append(FlatVectorField(**vector_field))elifvector_field[\"algorithm\"]==\"HNSW\":self.vector.append(HNSWVectorField(**vector_field))else:raiseValueError(f\"algorithm must be either FLAT or HNSW. Got \"f\"{vector_field['algorithm']}\")[docs]defas_dict(self)->Dict[str,List[Any]]:schemas:Dict[str,List[Any]]={\"text\":[],\"tag\":[],\"numeric\":[]}# iter over all class attributesforattr,attr_valueinself.__dict__.items():# only non-empty listsifisinstance(attr_value,list)andlen(attr_value)>0:field_values:List[Dict[str,Any]]=[]# iterate over all fields in each category (tag, text, etc)forvalinattr_value:value:Dict[str,Any]={}# iterate over values within each field to extract# settings for that field (i.e. name, weight, etc)forfield,field_valueinval.__dict__.items():# make enums into stringsifisinstance(field_value,Enum):value[field]=field_value.value# don't write null valueseliffield_valueisnotNone:value[field]=field_valuefield_values.append(value)schemas[attr]=field_valuesschema:Dict[str,List[Any]]={}# only write non-empty lists from defaultsfork,vinschemas.items():iflen(v)>0:schema[k]=vreturnschema@propertydefcontent_vector(self)->Union[FlatVectorField,HNSWVectorField]:ifnotself.vector:raiseValueError(\"No vector fields found\")forfieldinself.vector:iffield.name==self.content_vector_key:returnfieldraiseValueError(\"No content_vector field found\")@propertydefvector_dtype(self)->np.dtype:# should only ever be called after pydantic has validated the schemareturnREDIS_VECTOR_DTYPE_MAP[self.content_vector.datatype]@propertydefis_empty(self)->bool:returnall(fieldisNoneforfieldin[self.tag,self.text,self.numeric,self.vector])[docs]defget_fields(self)->List[\"RedisField\"]:redis_fields:List[\"RedisField\"]=[]ifself.is_empty:returnredis_fieldsforfield_nameinget_fields(self).keys():iffield_namenotin[\"content_key\",\"content_vector_key\",\"extra\"]:field_group=getattr(self,field_name)iffield_groupisnotNone:forfieldinfield_group:redis_fields.append(field.as_field())returnredis_fields@propertydefmetadata_keys(self)->List[str]:keys:List[str]=[]ifself.is_empty:returnkeysforfield_nameinget_fields(self).keys():field_group=getattr(self,field_name)iffield_groupisnotNone:forfieldinfield_group:# check if it's a metadata field. exclude vector and content keyifnotisinstance(field,str)andfield.namenotin[self.content_key,self.content_vector_key,]:keys.append(field.name)returnkeys[docs]defread_schema(index_schema:Optional[Union[Dict[str,List[Any]],str,os.PathLike]],)->Dict[str,Any]:\"\"\"Read in the index schema from a dict or yaml file.Check if it is a dict and return RedisModel otherwise, check if it's a path andread in the file assuming it's a yaml file and return a RedisModel\"\"\"ifisinstance(index_schema,dict):returnindex_schemaelifisinstance(index_schema,Path):withopen(index_schema,\"rb\")asf:returnyaml.safe_load(f)elifisinstance(index_schema,str):ifPath(index_schema).resolve().is_file():withopen(index_schema,\"rb\")asf:returnyaml.safe_load(f)else:raiseFileNotFoundError(f\"index_schema file{index_schema}does not exist\")else:raiseTypeError(f\"index_schema must be a dict, or path to a yaml file \"f\"Got{type(index_schema)}\")"
  ],
  "api_signatures": [],
  "parameters": []
}